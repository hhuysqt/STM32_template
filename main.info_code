
main.elf:     file format elf32-littlearm


Disassembly of section .text:

20000000 <g_pfnVectors>:
20000000:	00 00 01 20 59 30 00 20 9d 30 00 20 9d 30 00 20     ... Y0. .0. .0. 
20000010:	9d 30 00 20 9d 30 00 20 9d 30 00 20 00 00 00 00     .0. .0. .0. ....
	...
2000002c:	9d 30 00 20 9d 30 00 20 00 00 00 00 9d 30 00 20     .0. .0. .....0. 
2000003c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000004c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000005c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000006c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000007c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000008c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000009c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
200000ac:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
200000bc:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
200000cc:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
200000dc:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
200000ec:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
200000fc:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000010c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000011c:	9d 30 00 20 9d 30 00 20 9d 30 00 20 9d 30 00 20     .0. .0. .0. .0. 
2000012c:	9d 30 00 20 00 00 00 00 00 00 00 00 00 00 00 00     .0. ............
	...
200001e0:	5f f8 e0 f1                                         _...

200001e4 <InitWorld>:
#define LED_PIN GPIO_Pin_6
#define LED_ON GPIO_ResetBits(GPIOF, LED_PIN);
#define LED_OFF GPIO_SetBits(GPIOF, LED_PIN);

void InitWorld(void)
{
200001e4:	b580      	push	{r7, lr}
200001e6:	b084      	sub	sp, #16
200001e8:	af00      	add	r7, sp, #0
	TIM_TimeBaseInitTypeDef tim2_base;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
200001ea:	2001      	movs	r0, #1
200001ec:	2101      	movs	r1, #1
200001ee:	f000 fe3f 	bl	20000e70 <RCC_APB1PeriphClockCmd>
	
	TIM_DeInit(TIM2);
200001f2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
200001f6:	f000 ff39 	bl	2000106c <TIM_DeInit>
	tim2_base.TIM_Prescaler = 71;
200001fa:	2347      	movs	r3, #71	; 0x47
200001fc:	80bb      	strh	r3, [r7, #4]
	tim2_base.TIM_CounterMode = TIM_CounterMode_Up;
200001fe:	2300      	movs	r3, #0
20000200:	80fb      	strh	r3, [r7, #6]
	tim2_base.TIM_ClockDivision = 0;
20000202:	2300      	movs	r3, #0
20000204:	817b      	strh	r3, [r7, #10]
	tim2_base.TIM_Period = 1000; 
20000206:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
2000020a:	813b      	strh	r3, [r7, #8]
	TIM_TimeBaseInit(TIM2, &tim2_base);
2000020c:	1d3b      	adds	r3, r7, #4
2000020e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
20000212:	4619      	mov	r1, r3
20000214:	f001 f840 	bl	20001298 <TIM_TimeBaseInit>
	TIM_Cmd(TIM2, ENABLE);
20000218:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
2000021c:	2101      	movs	r1, #1
2000021e:	f001 fc03 	bl	20001a28 <TIM_Cmd>
}
20000222:	3710      	adds	r7, #16
20000224:	46bd      	mov	sp, r7
20000226:	bd80      	pop	{r7, pc}

20000228 <delay_ms>:

void delay_ms(u16 n)
{
20000228:	b580      	push	{r7, lr}
2000022a:	b082      	sub	sp, #8
2000022c:	af00      	add	r7, sp, #0
2000022e:	4603      	mov	r3, r0
20000230:	80fb      	strh	r3, [r7, #6]
	while(n--)
20000232:	e00d      	b.n	20000250 <delay_ms+0x28>
	{
		while(TIM_GetFlagStatus(TIM2, TIM_FLAG_Update) != SET);
20000234:	bf00      	nop
20000236:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
2000023a:	2101      	movs	r1, #1
2000023c:	f002 fbbc 	bl	200029b8 <TIM_GetFlagStatus>
20000240:	4603      	mov	r3, r0
20000242:	2b01      	cmp	r3, #1
20000244:	d1f7      	bne.n	20000236 <delay_ms+0xe>
		TIM_ClearFlag(TIM2, TIM_FLAG_Update);
20000246:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
2000024a:	2101      	movs	r1, #1
2000024c:	f002 fbd0 	bl	200029f0 <TIM_ClearFlag>
	TIM_Cmd(TIM2, ENABLE);
}

void delay_ms(u16 n)
{
	while(n--)
20000250:	88fb      	ldrh	r3, [r7, #6]
20000252:	1e5a      	subs	r2, r3, #1
20000254:	80fa      	strh	r2, [r7, #6]
20000256:	2b00      	cmp	r3, #0
20000258:	d1ec      	bne.n	20000234 <delay_ms+0xc>
	{
		while(TIM_GetFlagStatus(TIM2, TIM_FLAG_Update) != SET);
		TIM_ClearFlag(TIM2, TIM_FLAG_Update);
	}
}
2000025a:	3708      	adds	r7, #8
2000025c:	46bd      	mov	sp, r7
2000025e:	bd80      	pop	{r7, pc}

20000260 <main>:

int main()
{
20000260:	b580      	push	{r7, lr}
20000262:	b082      	sub	sp, #8
20000264:	af00      	add	r7, sp, #0
	InitWorld();
20000266:	f7ff ffbd 	bl	200001e4 <InitWorld>

	{
		GPIO_InitTypeDef LEDIO;
		
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);
2000026a:	2080      	movs	r0, #128	; 0x80
2000026c:	2101      	movs	r1, #1
2000026e:	f000 fde1 	bl	20000e34 <RCC_APB2PeriphClockCmd>
		
		LEDIO.GPIO_Mode = GPIO_Mode_Out_PP;
20000272:	2310      	movs	r3, #16
20000274:	71fb      	strb	r3, [r7, #7]
		LEDIO.GPIO_Speed = GPIO_Speed_50MHz;
20000276:	2303      	movs	r3, #3
20000278:	71bb      	strb	r3, [r7, #6]
		LEDIO.GPIO_Pin = LED_PIN;
2000027a:	2340      	movs	r3, #64	; 0x40
2000027c:	80bb      	strh	r3, [r7, #4]
		
		GPIO_Init(GPIOF, &LEDIO);
2000027e:	1d3b      	adds	r3, r7, #4
20000280:	480a      	ldr	r0, [pc, #40]	; (200002ac <main+0x4c>)
20000282:	4619      	mov	r1, r3
20000284:	f000 f892 	bl	200003ac <GPIO_Init>
	}

	while(1)
	{
		delay_ms(500);
20000288:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
2000028c:	f7ff ffcc 	bl	20000228 <delay_ms>
		LED_ON;
20000290:	4806      	ldr	r0, [pc, #24]	; (200002ac <main+0x4c>)
20000292:	2140      	movs	r1, #64	; 0x40
20000294:	f000 f9b8 	bl	20000608 <GPIO_ResetBits>
		delay_ms(500);
20000298:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
2000029c:	f7ff ffc4 	bl	20000228 <delay_ms>
		LED_OFF;
200002a0:	4802      	ldr	r0, [pc, #8]	; (200002ac <main+0x4c>)
200002a2:	2140      	movs	r1, #64	; 0x40
200002a4:	f000 f9a2 	bl	200005ec <GPIO_SetBits>
	}
200002a8:	e7ee      	b.n	20000288 <main+0x28>
200002aa:	bf00      	nop
200002ac:	40011c00 	.word	0x40011c00

200002b0 <GPIO_DeInit>:
  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
200002b0:	b580      	push	{r7, lr}
200002b2:	b082      	sub	sp, #8
200002b4:	af00      	add	r7, sp, #0
200002b6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  if (GPIOx == GPIOA)
200002b8:	687a      	ldr	r2, [r7, #4]
200002ba:	4b2f      	ldr	r3, [pc, #188]	; (20000378 <GPIO_DeInit+0xc8>)
200002bc:	429a      	cmp	r2, r3
200002be:	d108      	bne.n	200002d2 <GPIO_DeInit+0x22>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
200002c0:	2004      	movs	r0, #4
200002c2:	2101      	movs	r1, #1
200002c4:	f000 fdf2 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
200002c8:	2004      	movs	r0, #4
200002ca:	2100      	movs	r1, #0
200002cc:	f000 fdee 	bl	20000eac <RCC_APB2PeriphResetCmd>
200002d0:	e04e      	b.n	20000370 <GPIO_DeInit+0xc0>
  }
  else if (GPIOx == GPIOB)
200002d2:	687a      	ldr	r2, [r7, #4]
200002d4:	4b29      	ldr	r3, [pc, #164]	; (2000037c <GPIO_DeInit+0xcc>)
200002d6:	429a      	cmp	r2, r3
200002d8:	d108      	bne.n	200002ec <GPIO_DeInit+0x3c>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
200002da:	2008      	movs	r0, #8
200002dc:	2101      	movs	r1, #1
200002de:	f000 fde5 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
200002e2:	2008      	movs	r0, #8
200002e4:	2100      	movs	r1, #0
200002e6:	f000 fde1 	bl	20000eac <RCC_APB2PeriphResetCmd>
200002ea:	e041      	b.n	20000370 <GPIO_DeInit+0xc0>
  }
  else if (GPIOx == GPIOC)
200002ec:	687a      	ldr	r2, [r7, #4]
200002ee:	4b24      	ldr	r3, [pc, #144]	; (20000380 <GPIO_DeInit+0xd0>)
200002f0:	429a      	cmp	r2, r3
200002f2:	d108      	bne.n	20000306 <GPIO_DeInit+0x56>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
200002f4:	2010      	movs	r0, #16
200002f6:	2101      	movs	r1, #1
200002f8:	f000 fdd8 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
200002fc:	2010      	movs	r0, #16
200002fe:	2100      	movs	r1, #0
20000300:	f000 fdd4 	bl	20000eac <RCC_APB2PeriphResetCmd>
20000304:	e034      	b.n	20000370 <GPIO_DeInit+0xc0>
  }
  else if (GPIOx == GPIOD)
20000306:	687a      	ldr	r2, [r7, #4]
20000308:	4b1e      	ldr	r3, [pc, #120]	; (20000384 <GPIO_DeInit+0xd4>)
2000030a:	429a      	cmp	r2, r3
2000030c:	d108      	bne.n	20000320 <GPIO_DeInit+0x70>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
2000030e:	2020      	movs	r0, #32
20000310:	2101      	movs	r1, #1
20000312:	f000 fdcb 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
20000316:	2020      	movs	r0, #32
20000318:	2100      	movs	r1, #0
2000031a:	f000 fdc7 	bl	20000eac <RCC_APB2PeriphResetCmd>
2000031e:	e027      	b.n	20000370 <GPIO_DeInit+0xc0>
  }    
  else if (GPIOx == GPIOE)
20000320:	687a      	ldr	r2, [r7, #4]
20000322:	4b19      	ldr	r3, [pc, #100]	; (20000388 <GPIO_DeInit+0xd8>)
20000324:	429a      	cmp	r2, r3
20000326:	d108      	bne.n	2000033a <GPIO_DeInit+0x8a>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
20000328:	2040      	movs	r0, #64	; 0x40
2000032a:	2101      	movs	r1, #1
2000032c:	f000 fdbe 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
20000330:	2040      	movs	r0, #64	; 0x40
20000332:	2100      	movs	r1, #0
20000334:	f000 fdba 	bl	20000eac <RCC_APB2PeriphResetCmd>
20000338:	e01a      	b.n	20000370 <GPIO_DeInit+0xc0>
  } 
  else if (GPIOx == GPIOF)
2000033a:	687a      	ldr	r2, [r7, #4]
2000033c:	4b13      	ldr	r3, [pc, #76]	; (2000038c <GPIO_DeInit+0xdc>)
2000033e:	429a      	cmp	r2, r3
20000340:	d108      	bne.n	20000354 <GPIO_DeInit+0xa4>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
20000342:	2080      	movs	r0, #128	; 0x80
20000344:	2101      	movs	r1, #1
20000346:	f000 fdb1 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
2000034a:	2080      	movs	r0, #128	; 0x80
2000034c:	2100      	movs	r1, #0
2000034e:	f000 fdad 	bl	20000eac <RCC_APB2PeriphResetCmd>
20000352:	e00d      	b.n	20000370 <GPIO_DeInit+0xc0>
  }
  else
  {
    if (GPIOx == GPIOG)
20000354:	687a      	ldr	r2, [r7, #4]
20000356:	4b0e      	ldr	r3, [pc, #56]	; (20000390 <GPIO_DeInit+0xe0>)
20000358:	429a      	cmp	r2, r3
2000035a:	d109      	bne.n	20000370 <GPIO_DeInit+0xc0>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
2000035c:	f44f 7080 	mov.w	r0, #256	; 0x100
20000360:	2101      	movs	r1, #1
20000362:	f000 fda3 	bl	20000eac <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
20000366:	f44f 7080 	mov.w	r0, #256	; 0x100
2000036a:	2100      	movs	r1, #0
2000036c:	f000 fd9e 	bl	20000eac <RCC_APB2PeriphResetCmd>
    }
  }
}
20000370:	3708      	adds	r7, #8
20000372:	46bd      	mov	sp, r7
20000374:	bd80      	pop	{r7, pc}
20000376:	bf00      	nop
20000378:	40010800 	.word	0x40010800
2000037c:	40010c00 	.word	0x40010c00
20000380:	40011000 	.word	0x40011000
20000384:	40011400 	.word	0x40011400
20000388:	40011800 	.word	0x40011800
2000038c:	40011c00 	.word	0x40011c00
20000390:	40012000 	.word	0x40012000

20000394 <GPIO_AFIODeInit>:
  *   and EXTI configuration) registers to their default reset values.
  * @param  None
  * @retval None
  */
void GPIO_AFIODeInit(void)
{
20000394:	b580      	push	{r7, lr}
20000396:	af00      	add	r7, sp, #0
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
20000398:	2001      	movs	r0, #1
2000039a:	2101      	movs	r1, #1
2000039c:	f000 fd86 	bl	20000eac <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
200003a0:	2001      	movs	r0, #1
200003a2:	2100      	movs	r1, #0
200003a4:	f000 fd82 	bl	20000eac <RCC_APB2PeriphResetCmd>
}
200003a8:	bd80      	pop	{r7, pc}
200003aa:	bf00      	nop

200003ac <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *         contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
200003ac:	b480      	push	{r7}
200003ae:	b089      	sub	sp, #36	; 0x24
200003b0:	af00      	add	r7, sp, #0
200003b2:	6078      	str	r0, [r7, #4]
200003b4:	6039      	str	r1, [r7, #0]
  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
200003b6:	2300      	movs	r3, #0
200003b8:	61fb      	str	r3, [r7, #28]
200003ba:	2300      	movs	r3, #0
200003bc:	613b      	str	r3, [r7, #16]
200003be:	2300      	movs	r3, #0
200003c0:	61bb      	str	r3, [r7, #24]
200003c2:	2300      	movs	r3, #0
200003c4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg = 0x00, pinmask = 0x00;
200003c6:	2300      	movs	r3, #0
200003c8:	617b      	str	r3, [r7, #20]
200003ca:	2300      	movs	r3, #0
200003cc:	60bb      	str	r3, [r7, #8]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
200003ce:	683b      	ldr	r3, [r7, #0]
200003d0:	78db      	ldrb	r3, [r3, #3]
200003d2:	f003 030f 	and.w	r3, r3, #15
200003d6:	61fb      	str	r3, [r7, #28]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
200003d8:	683b      	ldr	r3, [r7, #0]
200003da:	78db      	ldrb	r3, [r3, #3]
200003dc:	f003 0310 	and.w	r3, r3, #16
200003e0:	2b00      	cmp	r3, #0
200003e2:	d004      	beq.n	200003ee <GPIO_Init+0x42>
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
200003e4:	683b      	ldr	r3, [r7, #0]
200003e6:	789b      	ldrb	r3, [r3, #2]
200003e8:	69fa      	ldr	r2, [r7, #28]
200003ea:	4313      	orrs	r3, r2
200003ec:	61fb      	str	r3, [r7, #28]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
200003ee:	683b      	ldr	r3, [r7, #0]
200003f0:	881b      	ldrh	r3, [r3, #0]
200003f2:	b2db      	uxtb	r3, r3
200003f4:	2b00      	cmp	r3, #0
200003f6:	d044      	beq.n	20000482 <GPIO_Init+0xd6>
  {
    tmpreg = GPIOx->CRL;
200003f8:	687b      	ldr	r3, [r7, #4]
200003fa:	681b      	ldr	r3, [r3, #0]
200003fc:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
200003fe:	2300      	movs	r3, #0
20000400:	61bb      	str	r3, [r7, #24]
20000402:	e038      	b.n	20000476 <GPIO_Init+0xca>
    {
      pos = ((uint32_t)0x01) << pinpos;
20000404:	69bb      	ldr	r3, [r7, #24]
20000406:	2201      	movs	r2, #1
20000408:	fa02 f303 	lsl.w	r3, r2, r3
2000040c:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
2000040e:	683b      	ldr	r3, [r7, #0]
20000410:	881b      	ldrh	r3, [r3, #0]
20000412:	461a      	mov	r2, r3
20000414:	68fb      	ldr	r3, [r7, #12]
20000416:	4013      	ands	r3, r2
20000418:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
2000041a:	693a      	ldr	r2, [r7, #16]
2000041c:	68fb      	ldr	r3, [r7, #12]
2000041e:	429a      	cmp	r2, r3
20000420:	d126      	bne.n	20000470 <GPIO_Init+0xc4>
      {
        pos = pinpos << 2;
20000422:	69bb      	ldr	r3, [r7, #24]
20000424:	009b      	lsls	r3, r3, #2
20000426:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
20000428:	68fb      	ldr	r3, [r7, #12]
2000042a:	220f      	movs	r2, #15
2000042c:	fa02 f303 	lsl.w	r3, r2, r3
20000430:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
20000432:	68bb      	ldr	r3, [r7, #8]
20000434:	43db      	mvns	r3, r3
20000436:	697a      	ldr	r2, [r7, #20]
20000438:	4013      	ands	r3, r2
2000043a:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
2000043c:	68fb      	ldr	r3, [r7, #12]
2000043e:	69fa      	ldr	r2, [r7, #28]
20000440:	fa02 f303 	lsl.w	r3, r2, r3
20000444:	697a      	ldr	r2, [r7, #20]
20000446:	4313      	orrs	r3, r2
20000448:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
2000044a:	683b      	ldr	r3, [r7, #0]
2000044c:	78db      	ldrb	r3, [r3, #3]
2000044e:	2b28      	cmp	r3, #40	; 0x28
20000450:	d105      	bne.n	2000045e <GPIO_Init+0xb2>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
20000452:	69bb      	ldr	r3, [r7, #24]
20000454:	2201      	movs	r2, #1
20000456:	409a      	lsls	r2, r3
20000458:	687b      	ldr	r3, [r7, #4]
2000045a:	615a      	str	r2, [r3, #20]
2000045c:	e008      	b.n	20000470 <GPIO_Init+0xc4>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
2000045e:	683b      	ldr	r3, [r7, #0]
20000460:	78db      	ldrb	r3, [r3, #3]
20000462:	2b48      	cmp	r3, #72	; 0x48
20000464:	d104      	bne.n	20000470 <GPIO_Init+0xc4>
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
20000466:	69bb      	ldr	r3, [r7, #24]
20000468:	2201      	movs	r2, #1
2000046a:	409a      	lsls	r2, r3
2000046c:	687b      	ldr	r3, [r7, #4]
2000046e:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
20000470:	69bb      	ldr	r3, [r7, #24]
20000472:	3301      	adds	r3, #1
20000474:	61bb      	str	r3, [r7, #24]
20000476:	69bb      	ldr	r3, [r7, #24]
20000478:	2b07      	cmp	r3, #7
2000047a:	d9c3      	bls.n	20000404 <GPIO_Init+0x58>
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
2000047c:	687b      	ldr	r3, [r7, #4]
2000047e:	697a      	ldr	r2, [r7, #20]
20000480:	601a      	str	r2, [r3, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
20000482:	683b      	ldr	r3, [r7, #0]
20000484:	881b      	ldrh	r3, [r3, #0]
20000486:	2bff      	cmp	r3, #255	; 0xff
20000488:	d946      	bls.n	20000518 <GPIO_Init+0x16c>
  {
    tmpreg = GPIOx->CRH;
2000048a:	687b      	ldr	r3, [r7, #4]
2000048c:	685b      	ldr	r3, [r3, #4]
2000048e:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
20000490:	2300      	movs	r3, #0
20000492:	61bb      	str	r3, [r7, #24]
20000494:	e03a      	b.n	2000050c <GPIO_Init+0x160>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
20000496:	69bb      	ldr	r3, [r7, #24]
20000498:	3308      	adds	r3, #8
2000049a:	2201      	movs	r2, #1
2000049c:	fa02 f303 	lsl.w	r3, r2, r3
200004a0:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
200004a2:	683b      	ldr	r3, [r7, #0]
200004a4:	881b      	ldrh	r3, [r3, #0]
200004a6:	461a      	mov	r2, r3
200004a8:	68fb      	ldr	r3, [r7, #12]
200004aa:	4013      	ands	r3, r2
200004ac:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
200004ae:	693a      	ldr	r2, [r7, #16]
200004b0:	68fb      	ldr	r3, [r7, #12]
200004b2:	429a      	cmp	r2, r3
200004b4:	d127      	bne.n	20000506 <GPIO_Init+0x15a>
      {
        pos = pinpos << 2;
200004b6:	69bb      	ldr	r3, [r7, #24]
200004b8:	009b      	lsls	r3, r3, #2
200004ba:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
200004bc:	68fb      	ldr	r3, [r7, #12]
200004be:	220f      	movs	r2, #15
200004c0:	fa02 f303 	lsl.w	r3, r2, r3
200004c4:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
200004c6:	68bb      	ldr	r3, [r7, #8]
200004c8:	43db      	mvns	r3, r3
200004ca:	697a      	ldr	r2, [r7, #20]
200004cc:	4013      	ands	r3, r2
200004ce:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
200004d0:	68fb      	ldr	r3, [r7, #12]
200004d2:	69fa      	ldr	r2, [r7, #28]
200004d4:	fa02 f303 	lsl.w	r3, r2, r3
200004d8:	697a      	ldr	r2, [r7, #20]
200004da:	4313      	orrs	r3, r2
200004dc:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
200004de:	683b      	ldr	r3, [r7, #0]
200004e0:	78db      	ldrb	r3, [r3, #3]
200004e2:	2b28      	cmp	r3, #40	; 0x28
200004e4:	d105      	bne.n	200004f2 <GPIO_Init+0x146>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
200004e6:	69bb      	ldr	r3, [r7, #24]
200004e8:	3308      	adds	r3, #8
200004ea:	2201      	movs	r2, #1
200004ec:	409a      	lsls	r2, r3
200004ee:	687b      	ldr	r3, [r7, #4]
200004f0:	615a      	str	r2, [r3, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
200004f2:	683b      	ldr	r3, [r7, #0]
200004f4:	78db      	ldrb	r3, [r3, #3]
200004f6:	2b48      	cmp	r3, #72	; 0x48
200004f8:	d105      	bne.n	20000506 <GPIO_Init+0x15a>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
200004fa:	69bb      	ldr	r3, [r7, #24]
200004fc:	3308      	adds	r3, #8
200004fe:	2201      	movs	r2, #1
20000500:	409a      	lsls	r2, r3
20000502:	687b      	ldr	r3, [r7, #4]
20000504:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
20000506:	69bb      	ldr	r3, [r7, #24]
20000508:	3301      	adds	r3, #1
2000050a:	61bb      	str	r3, [r7, #24]
2000050c:	69bb      	ldr	r3, [r7, #24]
2000050e:	2b07      	cmp	r3, #7
20000510:	d9c1      	bls.n	20000496 <GPIO_Init+0xea>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
20000512:	687b      	ldr	r3, [r7, #4]
20000514:	697a      	ldr	r2, [r7, #20]
20000516:	605a      	str	r2, [r3, #4]
  }
}
20000518:	3724      	adds	r7, #36	; 0x24
2000051a:	46bd      	mov	sp, r7
2000051c:	f85d 7b04 	ldr.w	r7, [sp], #4
20000520:	4770      	bx	lr
20000522:	bf00      	nop

20000524 <GPIO_StructInit>:
  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
20000524:	b480      	push	{r7}
20000526:	b083      	sub	sp, #12
20000528:	af00      	add	r7, sp, #0
2000052a:	6078      	str	r0, [r7, #4]
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
2000052c:	687b      	ldr	r3, [r7, #4]
2000052e:	f64f 72ff 	movw	r2, #65535	; 0xffff
20000532:	801a      	strh	r2, [r3, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
20000534:	687b      	ldr	r3, [r7, #4]
20000536:	2202      	movs	r2, #2
20000538:	709a      	strb	r2, [r3, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
2000053a:	687b      	ldr	r3, [r7, #4]
2000053c:	2204      	movs	r2, #4
2000053e:	70da      	strb	r2, [r3, #3]
}
20000540:	370c      	adds	r7, #12
20000542:	46bd      	mov	sp, r7
20000544:	f85d 7b04 	ldr.w	r7, [sp], #4
20000548:	4770      	bx	lr
2000054a:	bf00      	nop

2000054c <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin:  specifies the port bit to read.
  *   This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
2000054c:	b480      	push	{r7}
2000054e:	b085      	sub	sp, #20
20000550:	af00      	add	r7, sp, #0
20000552:	6078      	str	r0, [r7, #4]
20000554:	460b      	mov	r3, r1
20000556:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
20000558:	2300      	movs	r3, #0
2000055a:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
2000055c:	687b      	ldr	r3, [r7, #4]
2000055e:	689a      	ldr	r2, [r3, #8]
20000560:	887b      	ldrh	r3, [r7, #2]
20000562:	4013      	ands	r3, r2
20000564:	2b00      	cmp	r3, #0
20000566:	d002      	beq.n	2000056e <GPIO_ReadInputDataBit+0x22>
  {
    bitstatus = (uint8_t)Bit_SET;
20000568:	2301      	movs	r3, #1
2000056a:	73fb      	strb	r3, [r7, #15]
2000056c:	e001      	b.n	20000572 <GPIO_ReadInputDataBit+0x26>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
2000056e:	2300      	movs	r3, #0
20000570:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
20000572:	7bfb      	ldrb	r3, [r7, #15]
}
20000574:	4618      	mov	r0, r3
20000576:	3714      	adds	r7, #20
20000578:	46bd      	mov	sp, r7
2000057a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000057e:	4770      	bx	lr

20000580 <GPIO_ReadInputData>:
  * @brief  Reads the specified GPIO input data port.
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @retval GPIO input data port value.
  */
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
20000580:	b480      	push	{r7}
20000582:	b083      	sub	sp, #12
20000584:	af00      	add	r7, sp, #0
20000586:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->IDR);
20000588:	687b      	ldr	r3, [r7, #4]
2000058a:	689b      	ldr	r3, [r3, #8]
2000058c:	b29b      	uxth	r3, r3
}
2000058e:	4618      	mov	r0, r3
20000590:	370c      	adds	r7, #12
20000592:	46bd      	mov	sp, r7
20000594:	f85d 7b04 	ldr.w	r7, [sp], #4
20000598:	4770      	bx	lr
2000059a:	bf00      	nop

2000059c <GPIO_ReadOutputDataBit>:
  * @param  GPIO_Pin:  specifies the port bit to read.
  *   This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The output port pin value.
  */
uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
2000059c:	b480      	push	{r7}
2000059e:	b085      	sub	sp, #20
200005a0:	af00      	add	r7, sp, #0
200005a2:	6078      	str	r0, [r7, #4]
200005a4:	460b      	mov	r3, r1
200005a6:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
200005a8:	2300      	movs	r3, #0
200005aa:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
200005ac:	687b      	ldr	r3, [r7, #4]
200005ae:	68da      	ldr	r2, [r3, #12]
200005b0:	887b      	ldrh	r3, [r7, #2]
200005b2:	4013      	ands	r3, r2
200005b4:	2b00      	cmp	r3, #0
200005b6:	d002      	beq.n	200005be <GPIO_ReadOutputDataBit+0x22>
  {
    bitstatus = (uint8_t)Bit_SET;
200005b8:	2301      	movs	r3, #1
200005ba:	73fb      	strb	r3, [r7, #15]
200005bc:	e001      	b.n	200005c2 <GPIO_ReadOutputDataBit+0x26>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
200005be:	2300      	movs	r3, #0
200005c0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
200005c2:	7bfb      	ldrb	r3, [r7, #15]
}
200005c4:	4618      	mov	r0, r3
200005c6:	3714      	adds	r7, #20
200005c8:	46bd      	mov	sp, r7
200005ca:	f85d 7b04 	ldr.w	r7, [sp], #4
200005ce:	4770      	bx	lr

200005d0 <GPIO_ReadOutputData>:
  * @brief  Reads the specified GPIO output data port.
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @retval GPIO output data port value.
  */
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
200005d0:	b480      	push	{r7}
200005d2:	b083      	sub	sp, #12
200005d4:	af00      	add	r7, sp, #0
200005d6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    
  return ((uint16_t)GPIOx->ODR);
200005d8:	687b      	ldr	r3, [r7, #4]
200005da:	68db      	ldr	r3, [r3, #12]
200005dc:	b29b      	uxth	r3, r3
}
200005de:	4618      	mov	r0, r3
200005e0:	370c      	adds	r7, #12
200005e2:	46bd      	mov	sp, r7
200005e4:	f85d 7b04 	ldr.w	r7, [sp], #4
200005e8:	4770      	bx	lr
200005ea:	bf00      	nop

200005ec <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
200005ec:	b480      	push	{r7}
200005ee:	b083      	sub	sp, #12
200005f0:	af00      	add	r7, sp, #0
200005f2:	6078      	str	r0, [r7, #4]
200005f4:	460b      	mov	r3, r1
200005f6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
200005f8:	887a      	ldrh	r2, [r7, #2]
200005fa:	687b      	ldr	r3, [r7, #4]
200005fc:	611a      	str	r2, [r3, #16]
}
200005fe:	370c      	adds	r7, #12
20000600:	46bd      	mov	sp, r7
20000602:	f85d 7b04 	ldr.w	r7, [sp], #4
20000606:	4770      	bx	lr

20000608 <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
20000608:	b480      	push	{r7}
2000060a:	b083      	sub	sp, #12
2000060c:	af00      	add	r7, sp, #0
2000060e:	6078      	str	r0, [r7, #4]
20000610:	460b      	mov	r3, r1
20000612:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
20000614:	887a      	ldrh	r2, [r7, #2]
20000616:	687b      	ldr	r3, [r7, #4]
20000618:	615a      	str	r2, [r3, #20]
}
2000061a:	370c      	adds	r7, #12
2000061c:	46bd      	mov	sp, r7
2000061e:	f85d 7b04 	ldr.w	r7, [sp], #4
20000622:	4770      	bx	lr

20000624 <GPIO_WriteBit>:
  *     @arg Bit_RESET: to clear the port pin
  *     @arg Bit_SET: to set the port pin
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
20000624:	b480      	push	{r7}
20000626:	b083      	sub	sp, #12
20000628:	af00      	add	r7, sp, #0
2000062a:	6078      	str	r0, [r7, #4]
2000062c:	4613      	mov	r3, r2
2000062e:	460a      	mov	r2, r1
20000630:	807a      	strh	r2, [r7, #2]
20000632:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
20000634:	787b      	ldrb	r3, [r7, #1]
20000636:	2b00      	cmp	r3, #0
20000638:	d003      	beq.n	20000642 <GPIO_WriteBit+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
2000063a:	887a      	ldrh	r2, [r7, #2]
2000063c:	687b      	ldr	r3, [r7, #4]
2000063e:	611a      	str	r2, [r3, #16]
20000640:	e002      	b.n	20000648 <GPIO_WriteBit+0x24>
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
20000642:	887a      	ldrh	r2, [r7, #2]
20000644:	687b      	ldr	r3, [r7, #4]
20000646:	615a      	str	r2, [r3, #20]
  }
}
20000648:	370c      	adds	r7, #12
2000064a:	46bd      	mov	sp, r7
2000064c:	f85d 7b04 	ldr.w	r7, [sp], #4
20000650:	4770      	bx	lr
20000652:	bf00      	nop

20000654 <GPIO_Write>:
  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
  * @param  PortVal: specifies the value to be written to the port output data register.
  * @retval None
  */
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
20000654:	b480      	push	{r7}
20000656:	b083      	sub	sp, #12
20000658:	af00      	add	r7, sp, #0
2000065a:	6078      	str	r0, [r7, #4]
2000065c:	460b      	mov	r3, r1
2000065e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
20000660:	887a      	ldrh	r2, [r7, #2]
20000662:	687b      	ldr	r3, [r7, #4]
20000664:	60da      	str	r2, [r3, #12]
}
20000666:	370c      	adds	r7, #12
20000668:	46bd      	mov	sp, r7
2000066a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000066e:	4770      	bx	lr

20000670 <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
20000670:	b480      	push	{r7}
20000672:	b085      	sub	sp, #20
20000674:	af00      	add	r7, sp, #0
20000676:	6078      	str	r0, [r7, #4]
20000678:	460b      	mov	r3, r1
2000067a:	807b      	strh	r3, [r7, #2]
  uint32_t tmp = 0x00010000;
2000067c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
20000680:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
20000682:	887b      	ldrh	r3, [r7, #2]
20000684:	68fa      	ldr	r2, [r7, #12]
20000686:	4313      	orrs	r3, r2
20000688:	60fb      	str	r3, [r7, #12]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
2000068a:	687b      	ldr	r3, [r7, #4]
2000068c:	68fa      	ldr	r2, [r7, #12]
2000068e:	619a      	str	r2, [r3, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
20000690:	887a      	ldrh	r2, [r7, #2]
20000692:	687b      	ldr	r3, [r7, #4]
20000694:	619a      	str	r2, [r3, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
20000696:	687b      	ldr	r3, [r7, #4]
20000698:	68fa      	ldr	r2, [r7, #12]
2000069a:	619a      	str	r2, [r3, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
2000069c:	687b      	ldr	r3, [r7, #4]
2000069e:	699b      	ldr	r3, [r3, #24]
200006a0:	60fb      	str	r3, [r7, #12]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
200006a2:	687b      	ldr	r3, [r7, #4]
200006a4:	699b      	ldr	r3, [r3, #24]
200006a6:	60fb      	str	r3, [r7, #12]
}
200006a8:	3714      	adds	r7, #20
200006aa:	46bd      	mov	sp, r7
200006ac:	f85d 7b04 	ldr.w	r7, [sp], #4
200006b0:	4770      	bx	lr
200006b2:	bf00      	nop

200006b4 <GPIO_EventOutputConfig>:
  * @param  GPIO_PinSource: specifies the pin for the Event output.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
200006b4:	b480      	push	{r7}
200006b6:	b085      	sub	sp, #20
200006b8:	af00      	add	r7, sp, #0
200006ba:	4602      	mov	r2, r0
200006bc:	460b      	mov	r3, r1
200006be:	71fa      	strb	r2, [r7, #7]
200006c0:	71bb      	strb	r3, [r7, #6]
  uint32_t tmpreg = 0x00;
200006c2:	2300      	movs	r3, #0
200006c4:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
200006c6:	4b0c      	ldr	r3, [pc, #48]	; (200006f8 <GPIO_EventOutputConfig+0x44>)
200006c8:	681b      	ldr	r3, [r3, #0]
200006ca:	60fb      	str	r3, [r7, #12]
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
200006cc:	68fa      	ldr	r2, [r7, #12]
200006ce:	f64f 7380 	movw	r3, #65408	; 0xff80
200006d2:	4013      	ands	r3, r2
200006d4:	60fb      	str	r3, [r7, #12]
  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
200006d6:	79fb      	ldrb	r3, [r7, #7]
200006d8:	011b      	lsls	r3, r3, #4
200006da:	68fa      	ldr	r2, [r7, #12]
200006dc:	4313      	orrs	r3, r2
200006de:	60fb      	str	r3, [r7, #12]
  tmpreg |= GPIO_PinSource;
200006e0:	79bb      	ldrb	r3, [r7, #6]
200006e2:	68fa      	ldr	r2, [r7, #12]
200006e4:	4313      	orrs	r3, r2
200006e6:	60fb      	str	r3, [r7, #12]
  AFIO->EVCR = tmpreg;
200006e8:	4b03      	ldr	r3, [pc, #12]	; (200006f8 <GPIO_EventOutputConfig+0x44>)
200006ea:	68fa      	ldr	r2, [r7, #12]
200006ec:	601a      	str	r2, [r3, #0]
}
200006ee:	3714      	adds	r7, #20
200006f0:	46bd      	mov	sp, r7
200006f2:	f85d 7b04 	ldr.w	r7, [sp], #4
200006f6:	4770      	bx	lr
200006f8:	40010000 	.word	0x40010000

200006fc <GPIO_EventOutputCmd>:
  * @param  NewState: new state of the Event output.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_EventOutputCmd(FunctionalState NewState)
{
200006fc:	b480      	push	{r7}
200006fe:	b083      	sub	sp, #12
20000700:	af00      	add	r7, sp, #0
20000702:	4603      	mov	r3, r0
20000704:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
20000706:	4b04      	ldr	r3, [pc, #16]	; (20000718 <GPIO_EventOutputCmd+0x1c>)
20000708:	79fa      	ldrb	r2, [r7, #7]
2000070a:	601a      	str	r2, [r3, #0]
}
2000070c:	370c      	adds	r7, #12
2000070e:	46bd      	mov	sp, r7
20000710:	f85d 7b04 	ldr.w	r7, [sp], #4
20000714:	4770      	bx	lr
20000716:	bf00      	nop
20000718:	4220001c 	.word	0x4220001c

2000071c <GPIO_PinRemapConfig>:
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
2000071c:	b480      	push	{r7}
2000071e:	b087      	sub	sp, #28
20000720:	af00      	add	r7, sp, #0
20000722:	6078      	str	r0, [r7, #4]
20000724:	460b      	mov	r3, r1
20000726:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
20000728:	2300      	movs	r3, #0
2000072a:	613b      	str	r3, [r7, #16]
2000072c:	2300      	movs	r3, #0
2000072e:	60fb      	str	r3, [r7, #12]
20000730:	2300      	movs	r3, #0
20000732:	617b      	str	r3, [r7, #20]
20000734:	2300      	movs	r3, #0
20000736:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if((GPIO_Remap & 0x80000000) == 0x80000000)
20000738:	687b      	ldr	r3, [r7, #4]
2000073a:	2b00      	cmp	r3, #0
2000073c:	da03      	bge.n	20000746 <GPIO_PinRemapConfig+0x2a>
  {
    tmpreg = AFIO->MAPR2;
2000073e:	4b2e      	ldr	r3, [pc, #184]	; (200007f8 <GPIO_PinRemapConfig+0xdc>)
20000740:	69db      	ldr	r3, [r3, #28]
20000742:	617b      	str	r3, [r7, #20]
20000744:	e002      	b.n	2000074c <GPIO_PinRemapConfig+0x30>
  }
  else
  {
    tmpreg = AFIO->MAPR;
20000746:	4b2c      	ldr	r3, [pc, #176]	; (200007f8 <GPIO_PinRemapConfig+0xdc>)
20000748:	685b      	ldr	r3, [r3, #4]
2000074a:	617b      	str	r3, [r7, #20]
  }

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
2000074c:	687b      	ldr	r3, [r7, #4]
2000074e:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
20000752:	0c1b      	lsrs	r3, r3, #16
20000754:	60bb      	str	r3, [r7, #8]
  tmp = GPIO_Remap & LSB_MASK;
20000756:	687b      	ldr	r3, [r7, #4]
20000758:	b29b      	uxth	r3, r3
2000075a:	613b      	str	r3, [r7, #16]

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
2000075c:	687b      	ldr	r3, [r7, #4]
2000075e:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
20000762:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
20000766:	d10a      	bne.n	2000077e <GPIO_PinRemapConfig+0x62>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
20000768:	697b      	ldr	r3, [r7, #20]
2000076a:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
2000076e:	617b      	str	r3, [r7, #20]
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
20000770:	4b21      	ldr	r3, [pc, #132]	; (200007f8 <GPIO_PinRemapConfig+0xdc>)
20000772:	4a21      	ldr	r2, [pc, #132]	; (200007f8 <GPIO_PinRemapConfig+0xdc>)
20000774:	6852      	ldr	r2, [r2, #4]
20000776:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
2000077a:	605a      	str	r2, [r3, #4]
2000077c:	e021      	b.n	200007c2 <GPIO_PinRemapConfig+0xa6>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
2000077e:	687b      	ldr	r3, [r7, #4]
20000780:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
20000784:	2b00      	cmp	r3, #0
20000786:	d00e      	beq.n	200007a6 <GPIO_PinRemapConfig+0x8a>
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
20000788:	68bb      	ldr	r3, [r7, #8]
2000078a:	2203      	movs	r2, #3
2000078c:	fa02 f303 	lsl.w	r3, r2, r3
20000790:	60fb      	str	r3, [r7, #12]
    tmpreg &= ~tmp1;
20000792:	68fb      	ldr	r3, [r7, #12]
20000794:	43db      	mvns	r3, r3
20000796:	697a      	ldr	r2, [r7, #20]
20000798:	4013      	ands	r3, r2
2000079a:	617b      	str	r3, [r7, #20]
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
2000079c:	697b      	ldr	r3, [r7, #20]
2000079e:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
200007a2:	617b      	str	r3, [r7, #20]
200007a4:	e00d      	b.n	200007c2 <GPIO_PinRemapConfig+0xa6>
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
200007a6:	687b      	ldr	r3, [r7, #4]
200007a8:	0d5b      	lsrs	r3, r3, #21
200007aa:	011b      	lsls	r3, r3, #4
200007ac:	693a      	ldr	r2, [r7, #16]
200007ae:	fa02 f303 	lsl.w	r3, r2, r3
200007b2:	43db      	mvns	r3, r3
200007b4:	697a      	ldr	r2, [r7, #20]
200007b6:	4013      	ands	r3, r2
200007b8:	617b      	str	r3, [r7, #20]
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
200007ba:	697b      	ldr	r3, [r7, #20]
200007bc:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
200007c0:	617b      	str	r3, [r7, #20]
  }

  if (NewState != DISABLE)
200007c2:	78fb      	ldrb	r3, [r7, #3]
200007c4:	2b00      	cmp	r3, #0
200007c6:	d008      	beq.n	200007da <GPIO_PinRemapConfig+0xbe>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
200007c8:	687b      	ldr	r3, [r7, #4]
200007ca:	0d5b      	lsrs	r3, r3, #21
200007cc:	011b      	lsls	r3, r3, #4
200007ce:	693a      	ldr	r2, [r7, #16]
200007d0:	fa02 f303 	lsl.w	r3, r2, r3
200007d4:	697a      	ldr	r2, [r7, #20]
200007d6:	4313      	orrs	r3, r2
200007d8:	617b      	str	r3, [r7, #20]
  }

  if((GPIO_Remap & 0x80000000) == 0x80000000)
200007da:	687b      	ldr	r3, [r7, #4]
200007dc:	2b00      	cmp	r3, #0
200007de:	da03      	bge.n	200007e8 <GPIO_PinRemapConfig+0xcc>
  {
    AFIO->MAPR2 = tmpreg;
200007e0:	4b05      	ldr	r3, [pc, #20]	; (200007f8 <GPIO_PinRemapConfig+0xdc>)
200007e2:	697a      	ldr	r2, [r7, #20]
200007e4:	61da      	str	r2, [r3, #28]
200007e6:	e002      	b.n	200007ee <GPIO_PinRemapConfig+0xd2>
  }
  else
  {
    AFIO->MAPR = tmpreg;
200007e8:	4b03      	ldr	r3, [pc, #12]	; (200007f8 <GPIO_PinRemapConfig+0xdc>)
200007ea:	697a      	ldr	r2, [r7, #20]
200007ec:	605a      	str	r2, [r3, #4]
  }  
}
200007ee:	371c      	adds	r7, #28
200007f0:	46bd      	mov	sp, r7
200007f2:	f85d 7b04 	ldr.w	r7, [sp], #4
200007f6:	4770      	bx	lr
200007f8:	40010000 	.word	0x40010000

200007fc <GPIO_EXTILineConfig>:
  * @param  GPIO_PinSource: specifies the EXTI line to be configured.
  *   This parameter can be GPIO_PinSourcex where x can be (0..15).
  * @retval None
  */
void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
{
200007fc:	b490      	push	{r4, r7}
200007fe:	b084      	sub	sp, #16
20000800:	af00      	add	r7, sp, #0
20000802:	4602      	mov	r2, r0
20000804:	460b      	mov	r3, r1
20000806:	71fa      	strb	r2, [r7, #7]
20000808:	71bb      	strb	r3, [r7, #6]
  uint32_t tmp = 0x00;
2000080a:	2300      	movs	r3, #0
2000080c:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
2000080e:	79bb      	ldrb	r3, [r7, #6]
20000810:	f003 0303 	and.w	r3, r3, #3
20000814:	009b      	lsls	r3, r3, #2
20000816:	220f      	movs	r2, #15
20000818:	fa02 f303 	lsl.w	r3, r2, r3
2000081c:	60fb      	str	r3, [r7, #12]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
2000081e:	4b15      	ldr	r3, [pc, #84]	; (20000874 <GPIO_EXTILineConfig+0x78>)
20000820:	79ba      	ldrb	r2, [r7, #6]
20000822:	0892      	lsrs	r2, r2, #2
20000824:	b2d2      	uxtb	r2, r2
20000826:	4913      	ldr	r1, [pc, #76]	; (20000874 <GPIO_EXTILineConfig+0x78>)
20000828:	79b8      	ldrb	r0, [r7, #6]
2000082a:	0880      	lsrs	r0, r0, #2
2000082c:	b2c0      	uxtb	r0, r0
2000082e:	3002      	adds	r0, #2
20000830:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
20000834:	68f9      	ldr	r1, [r7, #12]
20000836:	43c9      	mvns	r1, r1
20000838:	4001      	ands	r1, r0
2000083a:	3202      	adds	r2, #2
2000083c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
20000840:	4b0c      	ldr	r3, [pc, #48]	; (20000874 <GPIO_EXTILineConfig+0x78>)
20000842:	79ba      	ldrb	r2, [r7, #6]
20000844:	0892      	lsrs	r2, r2, #2
20000846:	b2d2      	uxtb	r2, r2
20000848:	490a      	ldr	r1, [pc, #40]	; (20000874 <GPIO_EXTILineConfig+0x78>)
2000084a:	79b8      	ldrb	r0, [r7, #6]
2000084c:	0880      	lsrs	r0, r0, #2
2000084e:	b2c0      	uxtb	r0, r0
20000850:	3002      	adds	r0, #2
20000852:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
20000856:	79fc      	ldrb	r4, [r7, #7]
20000858:	79b9      	ldrb	r1, [r7, #6]
2000085a:	f001 0103 	and.w	r1, r1, #3
2000085e:	0089      	lsls	r1, r1, #2
20000860:	fa04 f101 	lsl.w	r1, r4, r1
20000864:	4301      	orrs	r1, r0
20000866:	3202      	adds	r2, #2
20000868:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
2000086c:	3710      	adds	r7, #16
2000086e:	46bd      	mov	sp, r7
20000870:	bc90      	pop	{r4, r7}
20000872:	4770      	bx	lr
20000874:	40010000 	.word	0x40010000

20000878 <GPIO_ETH_MediaInterfaceConfig>:
  *     @arg GPIO_ETH_MediaInterface_MII: MII mode
  *     @arg GPIO_ETH_MediaInterface_RMII: RMII mode    
  * @retval None
  */
void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
{ 
20000878:	b480      	push	{r7}
2000087a:	b083      	sub	sp, #12
2000087c:	af00      	add	r7, sp, #0
2000087e:	6078      	str	r0, [r7, #4]
  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 

  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
20000880:	4b03      	ldr	r3, [pc, #12]	; (20000890 <GPIO_ETH_MediaInterfaceConfig+0x18>)
20000882:	687a      	ldr	r2, [r7, #4]
20000884:	601a      	str	r2, [r3, #0]
}
20000886:	370c      	adds	r7, #12
20000888:	46bd      	mov	sp, r7
2000088a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000088e:	4770      	bx	lr
20000890:	422000dc 	.word	0x422000dc

20000894 <RCC_DeInit>:
  * @brief  Resets the RCC clock configuration to the default reset state.
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
20000894:	b480      	push	{r7}
20000896:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
20000898:	4b13      	ldr	r3, [pc, #76]	; (200008e8 <RCC_DeInit+0x54>)
2000089a:	4a13      	ldr	r2, [pc, #76]	; (200008e8 <RCC_DeInit+0x54>)
2000089c:	6812      	ldr	r2, [r2, #0]
2000089e:	f042 0201 	orr.w	r2, r2, #1
200008a2:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
200008a4:	4a10      	ldr	r2, [pc, #64]	; (200008e8 <RCC_DeInit+0x54>)
200008a6:	4b10      	ldr	r3, [pc, #64]	; (200008e8 <RCC_DeInit+0x54>)
200008a8:	6859      	ldr	r1, [r3, #4]
200008aa:	4b10      	ldr	r3, [pc, #64]	; (200008ec <RCC_DeInit+0x58>)
200008ac:	400b      	ands	r3, r1
200008ae:	6053      	str	r3, [r2, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
200008b0:	4a0d      	ldr	r2, [pc, #52]	; (200008e8 <RCC_DeInit+0x54>)
200008b2:	4b0d      	ldr	r3, [pc, #52]	; (200008e8 <RCC_DeInit+0x54>)
200008b4:	681b      	ldr	r3, [r3, #0]
200008b6:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
200008ba:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
200008be:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
200008c0:	4b09      	ldr	r3, [pc, #36]	; (200008e8 <RCC_DeInit+0x54>)
200008c2:	4a09      	ldr	r2, [pc, #36]	; (200008e8 <RCC_DeInit+0x54>)
200008c4:	6812      	ldr	r2, [r2, #0]
200008c6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
200008ca:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
200008cc:	4b06      	ldr	r3, [pc, #24]	; (200008e8 <RCC_DeInit+0x54>)
200008ce:	4a06      	ldr	r2, [pc, #24]	; (200008e8 <RCC_DeInit+0x54>)
200008d0:	6852      	ldr	r2, [r2, #4]
200008d2:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
200008d6:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
200008d8:	4b03      	ldr	r3, [pc, #12]	; (200008e8 <RCC_DeInit+0x54>)
200008da:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
200008de:	609a      	str	r2, [r3, #8]
#endif /* STM32F10X_CL */

}
200008e0:	46bd      	mov	sp, r7
200008e2:	f85d 7b04 	ldr.w	r7, [sp], #4
200008e6:	4770      	bx	lr
200008e8:	40021000 	.word	0x40021000
200008ec:	f8ff0000 	.word	0xf8ff0000

200008f0 <RCC_HSEConfig>:
  *     @arg RCC_HSE_ON: HSE oscillator ON
  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint32_t RCC_HSE)
{
200008f0:	b480      	push	{r7}
200008f2:	b083      	sub	sp, #12
200008f4:	af00      	add	r7, sp, #0
200008f6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
200008f8:	4b13      	ldr	r3, [pc, #76]	; (20000948 <RCC_HSEConfig+0x58>)
200008fa:	4a13      	ldr	r2, [pc, #76]	; (20000948 <RCC_HSEConfig+0x58>)
200008fc:	6812      	ldr	r2, [r2, #0]
200008fe:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
20000902:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
20000904:	4b10      	ldr	r3, [pc, #64]	; (20000948 <RCC_HSEConfig+0x58>)
20000906:	4a10      	ldr	r2, [pc, #64]	; (20000948 <RCC_HSEConfig+0x58>)
20000908:	6812      	ldr	r2, [r2, #0]
2000090a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
2000090e:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
20000910:	687b      	ldr	r3, [r7, #4]
20000912:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
20000916:	d003      	beq.n	20000920 <RCC_HSEConfig+0x30>
20000918:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
2000091c:	d007      	beq.n	2000092e <RCC_HSEConfig+0x3e>
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
      break;
      
    default:
      break;
2000091e:	e00d      	b.n	2000093c <RCC_HSEConfig+0x4c>
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
20000920:	4b09      	ldr	r3, [pc, #36]	; (20000948 <RCC_HSEConfig+0x58>)
20000922:	4a09      	ldr	r2, [pc, #36]	; (20000948 <RCC_HSEConfig+0x58>)
20000924:	6812      	ldr	r2, [r2, #0]
20000926:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
2000092a:	601a      	str	r2, [r3, #0]
      break;
2000092c:	e006      	b.n	2000093c <RCC_HSEConfig+0x4c>
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
2000092e:	4b06      	ldr	r3, [pc, #24]	; (20000948 <RCC_HSEConfig+0x58>)
20000930:	4a05      	ldr	r2, [pc, #20]	; (20000948 <RCC_HSEConfig+0x58>)
20000932:	6812      	ldr	r2, [r2, #0]
20000934:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
20000938:	601a      	str	r2, [r3, #0]
      break;
2000093a:	bf00      	nop
      
    default:
      break;
  }
}
2000093c:	370c      	adds	r7, #12
2000093e:	46bd      	mov	sp, r7
20000940:	f85d 7b04 	ldr.w	r7, [sp], #4
20000944:	4770      	bx	lr
20000946:	bf00      	nop
20000948:	40021000 	.word	0x40021000

2000094c <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
2000094c:	b580      	push	{r7, lr}
2000094e:	b082      	sub	sp, #8
20000950:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0;
20000952:	2300      	movs	r3, #0
20000954:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
20000956:	2300      	movs	r3, #0
20000958:	71fb      	strb	r3, [r7, #7]
  FlagStatus HSEStatus = RESET;
2000095a:	2300      	movs	r3, #0
2000095c:	71bb      	strb	r3, [r7, #6]
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
2000095e:	2031      	movs	r0, #49	; 0x31
20000960:	f000 fb10 	bl	20000f84 <RCC_GetFlagStatus>
20000964:	4603      	mov	r3, r0
20000966:	71bb      	strb	r3, [r7, #6]
    StartUpCounter++;  
20000968:	683b      	ldr	r3, [r7, #0]
2000096a:	3301      	adds	r3, #1
2000096c:	603b      	str	r3, [r7, #0]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
2000096e:	683b      	ldr	r3, [r7, #0]
20000970:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
20000974:	d002      	beq.n	2000097c <RCC_WaitForHSEStartUp+0x30>
20000976:	79bb      	ldrb	r3, [r7, #6]
20000978:	2b00      	cmp	r3, #0
2000097a:	d0f0      	beq.n	2000095e <RCC_WaitForHSEStartUp+0x12>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
2000097c:	2031      	movs	r0, #49	; 0x31
2000097e:	f000 fb01 	bl	20000f84 <RCC_GetFlagStatus>
20000982:	4603      	mov	r3, r0
20000984:	2b00      	cmp	r3, #0
20000986:	d002      	beq.n	2000098e <RCC_WaitForHSEStartUp+0x42>
  {
    status = SUCCESS;
20000988:	2301      	movs	r3, #1
2000098a:	71fb      	strb	r3, [r7, #7]
2000098c:	e001      	b.n	20000992 <RCC_WaitForHSEStartUp+0x46>
  }
  else
  {
    status = ERROR;
2000098e:	2300      	movs	r3, #0
20000990:	71fb      	strb	r3, [r7, #7]
  }  
  return (status);
20000992:	79fb      	ldrb	r3, [r7, #7]
}
20000994:	4618      	mov	r0, r3
20000996:	3708      	adds	r7, #8
20000998:	46bd      	mov	sp, r7
2000099a:	bd80      	pop	{r7, pc}

2000099c <RCC_AdjustHSICalibrationValue>:
  * @param  HSICalibrationValue: specifies the calibration trimming value.
  *   This parameter must be a number between 0 and 0x1F.
  * @retval None
  */
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
2000099c:	b480      	push	{r7}
2000099e:	b085      	sub	sp, #20
200009a0:	af00      	add	r7, sp, #0
200009a2:	4603      	mov	r3, r0
200009a4:	71fb      	strb	r3, [r7, #7]
  uint32_t tmpreg = 0;
200009a6:	2300      	movs	r3, #0
200009a8:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
  tmpreg = RCC->CR;
200009aa:	4b0a      	ldr	r3, [pc, #40]	; (200009d4 <RCC_AdjustHSICalibrationValue+0x38>)
200009ac:	681b      	ldr	r3, [r3, #0]
200009ae:	60fb      	str	r3, [r7, #12]
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
200009b0:	68fb      	ldr	r3, [r7, #12]
200009b2:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
200009b6:	60fb      	str	r3, [r7, #12]
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
200009b8:	79fb      	ldrb	r3, [r7, #7]
200009ba:	00db      	lsls	r3, r3, #3
200009bc:	68fa      	ldr	r2, [r7, #12]
200009be:	4313      	orrs	r3, r2
200009c0:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CR = tmpreg;
200009c2:	4b04      	ldr	r3, [pc, #16]	; (200009d4 <RCC_AdjustHSICalibrationValue+0x38>)
200009c4:	68fa      	ldr	r2, [r7, #12]
200009c6:	601a      	str	r2, [r3, #0]
}
200009c8:	3714      	adds	r7, #20
200009ca:	46bd      	mov	sp, r7
200009cc:	f85d 7b04 	ldr.w	r7, [sp], #4
200009d0:	4770      	bx	lr
200009d2:	bf00      	nop
200009d4:	40021000 	.word	0x40021000

200009d8 <RCC_HSICmd>:
  * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.
  * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_HSICmd(FunctionalState NewState)
{
200009d8:	b480      	push	{r7}
200009da:	b083      	sub	sp, #12
200009dc:	af00      	add	r7, sp, #0
200009de:	4603      	mov	r3, r0
200009e0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
200009e2:	4b04      	ldr	r3, [pc, #16]	; (200009f4 <RCC_HSICmd+0x1c>)
200009e4:	79fa      	ldrb	r2, [r7, #7]
200009e6:	601a      	str	r2, [r3, #0]
}
200009e8:	370c      	adds	r7, #12
200009ea:	46bd      	mov	sp, r7
200009ec:	f85d 7b04 	ldr.w	r7, [sp], #4
200009f0:	4770      	bx	lr
200009f2:	bf00      	nop
200009f4:	42420000 	.word	0x42420000

200009f8 <RCC_PLLConfig>:
  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
{
200009f8:	b480      	push	{r7}
200009fa:	b085      	sub	sp, #20
200009fc:	af00      	add	r7, sp, #0
200009fe:	6078      	str	r0, [r7, #4]
20000a00:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
20000a02:	2300      	movs	r3, #0
20000a04:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
20000a06:	4b0a      	ldr	r3, [pc, #40]	; (20000a30 <RCC_PLLConfig+0x38>)
20000a08:	685b      	ldr	r3, [r3, #4]
20000a0a:	60fb      	str	r3, [r7, #12]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
20000a0c:	68fb      	ldr	r3, [r7, #12]
20000a0e:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
20000a12:	60fb      	str	r3, [r7, #12]
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
20000a14:	687a      	ldr	r2, [r7, #4]
20000a16:	683b      	ldr	r3, [r7, #0]
20000a18:	4313      	orrs	r3, r2
20000a1a:	68fa      	ldr	r2, [r7, #12]
20000a1c:	4313      	orrs	r3, r2
20000a1e:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
20000a20:	4b03      	ldr	r3, [pc, #12]	; (20000a30 <RCC_PLLConfig+0x38>)
20000a22:	68fa      	ldr	r2, [r7, #12]
20000a24:	605a      	str	r2, [r3, #4]
}
20000a26:	3714      	adds	r7, #20
20000a28:	46bd      	mov	sp, r7
20000a2a:	f85d 7b04 	ldr.w	r7, [sp], #4
20000a2e:	4770      	bx	lr
20000a30:	40021000 	.word	0x40021000

20000a34 <RCC_PLLCmd>:
  * @note   The PLL can not be disabled if it is used as system clock.
  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
20000a34:	b480      	push	{r7}
20000a36:	b083      	sub	sp, #12
20000a38:	af00      	add	r7, sp, #0
20000a3a:	4603      	mov	r3, r0
20000a3c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
20000a3e:	4b04      	ldr	r3, [pc, #16]	; (20000a50 <RCC_PLLCmd+0x1c>)
20000a40:	79fa      	ldrb	r2, [r7, #7]
20000a42:	601a      	str	r2, [r3, #0]
}
20000a44:	370c      	adds	r7, #12
20000a46:	46bd      	mov	sp, r7
20000a48:	f85d 7b04 	ldr.w	r7, [sp], #4
20000a4c:	4770      	bx	lr
20000a4e:	bf00      	nop
20000a50:	42420060 	.word	0x42420060

20000a54 <RCC_SYSCLKConfig>:
  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
20000a54:	b480      	push	{r7}
20000a56:	b085      	sub	sp, #20
20000a58:	af00      	add	r7, sp, #0
20000a5a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
20000a5c:	2300      	movs	r3, #0
20000a5e:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
20000a60:	4b09      	ldr	r3, [pc, #36]	; (20000a88 <RCC_SYSCLKConfig+0x34>)
20000a62:	685b      	ldr	r3, [r3, #4]
20000a64:	60fb      	str	r3, [r7, #12]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
20000a66:	68fb      	ldr	r3, [r7, #12]
20000a68:	f023 0303 	bic.w	r3, r3, #3
20000a6c:	60fb      	str	r3, [r7, #12]
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
20000a6e:	68fa      	ldr	r2, [r7, #12]
20000a70:	687b      	ldr	r3, [r7, #4]
20000a72:	4313      	orrs	r3, r2
20000a74:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
20000a76:	4b04      	ldr	r3, [pc, #16]	; (20000a88 <RCC_SYSCLKConfig+0x34>)
20000a78:	68fa      	ldr	r2, [r7, #12]
20000a7a:	605a      	str	r2, [r3, #4]
}
20000a7c:	3714      	adds	r7, #20
20000a7e:	46bd      	mov	sp, r7
20000a80:	f85d 7b04 	ldr.w	r7, [sp], #4
20000a84:	4770      	bx	lr
20000a86:	bf00      	nop
20000a88:	40021000 	.word	0x40021000

20000a8c <RCC_GetSYSCLKSource>:
  *     - 0x00: HSI used as system clock
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
20000a8c:	b480      	push	{r7}
20000a8e:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
20000a90:	4b05      	ldr	r3, [pc, #20]	; (20000aa8 <RCC_GetSYSCLKSource+0x1c>)
20000a92:	685b      	ldr	r3, [r3, #4]
20000a94:	b2db      	uxtb	r3, r3
20000a96:	f003 030c 	and.w	r3, r3, #12
20000a9a:	b2db      	uxtb	r3, r3
}
20000a9c:	4618      	mov	r0, r3
20000a9e:	46bd      	mov	sp, r7
20000aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
20000aa4:	4770      	bx	lr
20000aa6:	bf00      	nop
20000aa8:	40021000 	.word	0x40021000

20000aac <RCC_HCLKConfig>:
  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
20000aac:	b480      	push	{r7}
20000aae:	b085      	sub	sp, #20
20000ab0:	af00      	add	r7, sp, #0
20000ab2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
20000ab4:	2300      	movs	r3, #0
20000ab6:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
20000ab8:	4b09      	ldr	r3, [pc, #36]	; (20000ae0 <RCC_HCLKConfig+0x34>)
20000aba:	685b      	ldr	r3, [r3, #4]
20000abc:	60fb      	str	r3, [r7, #12]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
20000abe:	68fb      	ldr	r3, [r7, #12]
20000ac0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
20000ac4:	60fb      	str	r3, [r7, #12]
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
20000ac6:	68fa      	ldr	r2, [r7, #12]
20000ac8:	687b      	ldr	r3, [r7, #4]
20000aca:	4313      	orrs	r3, r2
20000acc:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
20000ace:	4b04      	ldr	r3, [pc, #16]	; (20000ae0 <RCC_HCLKConfig+0x34>)
20000ad0:	68fa      	ldr	r2, [r7, #12]
20000ad2:	605a      	str	r2, [r3, #4]
}
20000ad4:	3714      	adds	r7, #20
20000ad6:	46bd      	mov	sp, r7
20000ad8:	f85d 7b04 	ldr.w	r7, [sp], #4
20000adc:	4770      	bx	lr
20000ade:	bf00      	nop
20000ae0:	40021000 	.word	0x40021000

20000ae4 <RCC_PCLK1Config>:
  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
20000ae4:	b480      	push	{r7}
20000ae6:	b085      	sub	sp, #20
20000ae8:	af00      	add	r7, sp, #0
20000aea:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
20000aec:	2300      	movs	r3, #0
20000aee:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
20000af0:	4b09      	ldr	r3, [pc, #36]	; (20000b18 <RCC_PCLK1Config+0x34>)
20000af2:	685b      	ldr	r3, [r3, #4]
20000af4:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
20000af6:	68fb      	ldr	r3, [r7, #12]
20000af8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
20000afc:	60fb      	str	r3, [r7, #12]
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
20000afe:	68fa      	ldr	r2, [r7, #12]
20000b00:	687b      	ldr	r3, [r7, #4]
20000b02:	4313      	orrs	r3, r2
20000b04:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
20000b06:	4b04      	ldr	r3, [pc, #16]	; (20000b18 <RCC_PCLK1Config+0x34>)
20000b08:	68fa      	ldr	r2, [r7, #12]
20000b0a:	605a      	str	r2, [r3, #4]
}
20000b0c:	3714      	adds	r7, #20
20000b0e:	46bd      	mov	sp, r7
20000b10:	f85d 7b04 	ldr.w	r7, [sp], #4
20000b14:	4770      	bx	lr
20000b16:	bf00      	nop
20000b18:	40021000 	.word	0x40021000

20000b1c <RCC_PCLK2Config>:
  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
20000b1c:	b480      	push	{r7}
20000b1e:	b085      	sub	sp, #20
20000b20:	af00      	add	r7, sp, #0
20000b22:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
20000b24:	2300      	movs	r3, #0
20000b26:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
20000b28:	4b09      	ldr	r3, [pc, #36]	; (20000b50 <RCC_PCLK2Config+0x34>)
20000b2a:	685b      	ldr	r3, [r3, #4]
20000b2c:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
20000b2e:	68fb      	ldr	r3, [r7, #12]
20000b30:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
20000b34:	60fb      	str	r3, [r7, #12]
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
20000b36:	687b      	ldr	r3, [r7, #4]
20000b38:	00db      	lsls	r3, r3, #3
20000b3a:	68fa      	ldr	r2, [r7, #12]
20000b3c:	4313      	orrs	r3, r2
20000b3e:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
20000b40:	4b03      	ldr	r3, [pc, #12]	; (20000b50 <RCC_PCLK2Config+0x34>)
20000b42:	68fa      	ldr	r2, [r7, #12]
20000b44:	605a      	str	r2, [r3, #4]
}
20000b46:	3714      	adds	r7, #20
20000b48:	46bd      	mov	sp, r7
20000b4a:	f85d 7b04 	ldr.w	r7, [sp], #4
20000b4e:	4770      	bx	lr
20000b50:	40021000 	.word	0x40021000

20000b54 <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
20000b54:	b480      	push	{r7}
20000b56:	b083      	sub	sp, #12
20000b58:	af00      	add	r7, sp, #0
20000b5a:	4602      	mov	r2, r0
20000b5c:	460b      	mov	r3, r1
20000b5e:	71fa      	strb	r2, [r7, #7]
20000b60:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20000b62:	79bb      	ldrb	r3, [r7, #6]
20000b64:	2b00      	cmp	r3, #0
20000b66:	d008      	beq.n	20000b7a <RCC_ITConfig+0x26>
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
20000b68:	4b0b      	ldr	r3, [pc, #44]	; (20000b98 <RCC_ITConfig+0x44>)
20000b6a:	4a0b      	ldr	r2, [pc, #44]	; (20000b98 <RCC_ITConfig+0x44>)
20000b6c:	7812      	ldrb	r2, [r2, #0]
20000b6e:	b2d1      	uxtb	r1, r2
20000b70:	79fa      	ldrb	r2, [r7, #7]
20000b72:	430a      	orrs	r2, r1
20000b74:	b2d2      	uxtb	r2, r2
20000b76:	701a      	strb	r2, [r3, #0]
20000b78:	e009      	b.n	20000b8e <RCC_ITConfig+0x3a>
  }
  else
  {
    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
20000b7a:	4b07      	ldr	r3, [pc, #28]	; (20000b98 <RCC_ITConfig+0x44>)
20000b7c:	4a06      	ldr	r2, [pc, #24]	; (20000b98 <RCC_ITConfig+0x44>)
20000b7e:	7812      	ldrb	r2, [r2, #0]
20000b80:	b2d1      	uxtb	r1, r2
20000b82:	79fa      	ldrb	r2, [r7, #7]
20000b84:	43d2      	mvns	r2, r2
20000b86:	b2d2      	uxtb	r2, r2
20000b88:	400a      	ands	r2, r1
20000b8a:	b2d2      	uxtb	r2, r2
20000b8c:	701a      	strb	r2, [r3, #0]
  }
}
20000b8e:	370c      	adds	r7, #12
20000b90:	46bd      	mov	sp, r7
20000b92:	f85d 7b04 	ldr.w	r7, [sp], #4
20000b96:	4770      	bx	lr
20000b98:	40021009 	.word	0x40021009

20000b9c <RCC_USBCLKConfig>:
  *                                     clock source
  *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
  * @retval None
  */
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
20000b9c:	b480      	push	{r7}
20000b9e:	b083      	sub	sp, #12
20000ba0:	af00      	add	r7, sp, #0
20000ba2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
20000ba4:	4b03      	ldr	r3, [pc, #12]	; (20000bb4 <RCC_USBCLKConfig+0x18>)
20000ba6:	687a      	ldr	r2, [r7, #4]
20000ba8:	601a      	str	r2, [r3, #0]
}
20000baa:	370c      	adds	r7, #12
20000bac:	46bd      	mov	sp, r7
20000bae:	f85d 7b04 	ldr.w	r7, [sp], #4
20000bb2:	4770      	bx	lr
20000bb4:	424200d8 	.word	0x424200d8

20000bb8 <RCC_ADCCLKConfig>:
  *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
  *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
  * @retval None
  */
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
20000bb8:	b480      	push	{r7}
20000bba:	b085      	sub	sp, #20
20000bbc:	af00      	add	r7, sp, #0
20000bbe:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
20000bc0:	2300      	movs	r3, #0
20000bc2:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
20000bc4:	4b09      	ldr	r3, [pc, #36]	; (20000bec <RCC_ADCCLKConfig+0x34>)
20000bc6:	685b      	ldr	r3, [r3, #4]
20000bc8:	60fb      	str	r3, [r7, #12]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
20000bca:	68fb      	ldr	r3, [r7, #12]
20000bcc:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
20000bd0:	60fb      	str	r3, [r7, #12]
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
20000bd2:	68fa      	ldr	r2, [r7, #12]
20000bd4:	687b      	ldr	r3, [r7, #4]
20000bd6:	4313      	orrs	r3, r2
20000bd8:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
20000bda:	4b04      	ldr	r3, [pc, #16]	; (20000bec <RCC_ADCCLKConfig+0x34>)
20000bdc:	68fa      	ldr	r2, [r7, #12]
20000bde:	605a      	str	r2, [r3, #4]
}
20000be0:	3714      	adds	r7, #20
20000be2:	46bd      	mov	sp, r7
20000be4:	f85d 7b04 	ldr.w	r7, [sp], #4
20000be8:	4770      	bx	lr
20000bea:	bf00      	nop
20000bec:	40021000 	.word	0x40021000

20000bf0 <RCC_LSEConfig>:
  *     @arg RCC_LSE_ON: LSE oscillator ON
  *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_LSEConfig(uint8_t RCC_LSE)
{
20000bf0:	b480      	push	{r7}
20000bf2:	b083      	sub	sp, #12
20000bf4:	af00      	add	r7, sp, #0
20000bf6:	4603      	mov	r3, r0
20000bf8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
20000bfa:	4b0c      	ldr	r3, [pc, #48]	; (20000c2c <RCC_LSEConfig+0x3c>)
20000bfc:	2200      	movs	r2, #0
20000bfe:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
20000c00:	4b0a      	ldr	r3, [pc, #40]	; (20000c2c <RCC_LSEConfig+0x3c>)
20000c02:	2200      	movs	r2, #0
20000c04:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
20000c06:	79fb      	ldrb	r3, [r7, #7]
20000c08:	2b01      	cmp	r3, #1
20000c0a:	d002      	beq.n	20000c12 <RCC_LSEConfig+0x22>
20000c0c:	2b04      	cmp	r3, #4
20000c0e:	d004      	beq.n	20000c1a <RCC_LSEConfig+0x2a>
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
      break;            
      
    default:
      break;      
20000c10:	e007      	b.n	20000c22 <RCC_LSEConfig+0x32>
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
20000c12:	4b06      	ldr	r3, [pc, #24]	; (20000c2c <RCC_LSEConfig+0x3c>)
20000c14:	2201      	movs	r2, #1
20000c16:	701a      	strb	r2, [r3, #0]
      break;
20000c18:	e003      	b.n	20000c22 <RCC_LSEConfig+0x32>
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
20000c1a:	4b04      	ldr	r3, [pc, #16]	; (20000c2c <RCC_LSEConfig+0x3c>)
20000c1c:	2205      	movs	r2, #5
20000c1e:	701a      	strb	r2, [r3, #0]
      break;            
20000c20:	bf00      	nop
      
    default:
      break;      
  }
}
20000c22:	370c      	adds	r7, #12
20000c24:	46bd      	mov	sp, r7
20000c26:	f85d 7b04 	ldr.w	r7, [sp], #4
20000c2a:	4770      	bx	lr
20000c2c:	40021020 	.word	0x40021020

20000c30 <RCC_LSICmd>:
  * @note   LSI can not be disabled if the IWDG is running.
  * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_LSICmd(FunctionalState NewState)
{
20000c30:	b480      	push	{r7}
20000c32:	b083      	sub	sp, #12
20000c34:	af00      	add	r7, sp, #0
20000c36:	4603      	mov	r3, r0
20000c38:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
20000c3a:	4b04      	ldr	r3, [pc, #16]	; (20000c4c <RCC_LSICmd+0x1c>)
20000c3c:	79fa      	ldrb	r2, [r7, #7]
20000c3e:	601a      	str	r2, [r3, #0]
}
20000c40:	370c      	adds	r7, #12
20000c42:	46bd      	mov	sp, r7
20000c44:	f85d 7b04 	ldr.w	r7, [sp], #4
20000c48:	4770      	bx	lr
20000c4a:	bf00      	nop
20000c4c:	42420480 	.word	0x42420480

20000c50 <RCC_RTCCLKConfig>:
  *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
  *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
  * @retval None
  */
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
20000c50:	b480      	push	{r7}
20000c52:	b083      	sub	sp, #12
20000c54:	af00      	add	r7, sp, #0
20000c56:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
20000c58:	4b05      	ldr	r3, [pc, #20]	; (20000c70 <RCC_RTCCLKConfig+0x20>)
20000c5a:	4a05      	ldr	r2, [pc, #20]	; (20000c70 <RCC_RTCCLKConfig+0x20>)
20000c5c:	6a11      	ldr	r1, [r2, #32]
20000c5e:	687a      	ldr	r2, [r7, #4]
20000c60:	430a      	orrs	r2, r1
20000c62:	621a      	str	r2, [r3, #32]
}
20000c64:	370c      	adds	r7, #12
20000c66:	46bd      	mov	sp, r7
20000c68:	f85d 7b04 	ldr.w	r7, [sp], #4
20000c6c:	4770      	bx	lr
20000c6e:	bf00      	nop
20000c70:	40021000 	.word	0x40021000

20000c74 <RCC_RTCCLKCmd>:
  * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
20000c74:	b480      	push	{r7}
20000c76:	b083      	sub	sp, #12
20000c78:	af00      	add	r7, sp, #0
20000c7a:	4603      	mov	r3, r0
20000c7c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
20000c7e:	4b04      	ldr	r3, [pc, #16]	; (20000c90 <RCC_RTCCLKCmd+0x1c>)
20000c80:	79fa      	ldrb	r2, [r7, #7]
20000c82:	601a      	str	r2, [r3, #0]
}
20000c84:	370c      	adds	r7, #12
20000c86:	46bd      	mov	sp, r7
20000c88:	f85d 7b04 	ldr.w	r7, [sp], #4
20000c8c:	4770      	bx	lr
20000c8e:	bf00      	nop
20000c90:	4242043c 	.word	0x4242043c

20000c94 <RCC_GetClocksFreq>:
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
20000c94:	b480      	push	{r7}
20000c96:	b087      	sub	sp, #28
20000c98:	af00      	add	r7, sp, #0
20000c9a:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
20000c9c:	2300      	movs	r3, #0
20000c9e:	617b      	str	r3, [r7, #20]
20000ca0:	2300      	movs	r3, #0
20000ca2:	613b      	str	r3, [r7, #16]
20000ca4:	2300      	movs	r3, #0
20000ca6:	60fb      	str	r3, [r7, #12]
20000ca8:	2300      	movs	r3, #0
20000caa:	60bb      	str	r3, [r7, #8]
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
20000cac:	4b4d      	ldr	r3, [pc, #308]	; (20000de4 <RCC_GetClocksFreq+0x150>)
20000cae:	685b      	ldr	r3, [r3, #4]
20000cb0:	f003 030c 	and.w	r3, r3, #12
20000cb4:	617b      	str	r3, [r7, #20]
  
  switch (tmp)
20000cb6:	697b      	ldr	r3, [r7, #20]
20000cb8:	2b04      	cmp	r3, #4
20000cba:	d007      	beq.n	20000ccc <RCC_GetClocksFreq+0x38>
20000cbc:	2b08      	cmp	r3, #8
20000cbe:	d009      	beq.n	20000cd4 <RCC_GetClocksFreq+0x40>
20000cc0:	2b00      	cmp	r3, #0
20000cc2:	d134      	bne.n	20000d2e <RCC_GetClocksFreq+0x9a>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
20000cc4:	687b      	ldr	r3, [r7, #4]
20000cc6:	4a48      	ldr	r2, [pc, #288]	; (20000de8 <RCC_GetClocksFreq+0x154>)
20000cc8:	601a      	str	r2, [r3, #0]
      break;
20000cca:	e034      	b.n	20000d36 <RCC_GetClocksFreq+0xa2>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
20000ccc:	687b      	ldr	r3, [r7, #4]
20000cce:	4a46      	ldr	r2, [pc, #280]	; (20000de8 <RCC_GetClocksFreq+0x154>)
20000cd0:	601a      	str	r2, [r3, #0]
      break;
20000cd2:	e030      	b.n	20000d36 <RCC_GetClocksFreq+0xa2>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
20000cd4:	4b43      	ldr	r3, [pc, #268]	; (20000de4 <RCC_GetClocksFreq+0x150>)
20000cd6:	685b      	ldr	r3, [r3, #4]
20000cd8:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
20000cdc:	613b      	str	r3, [r7, #16]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
20000cde:	4b41      	ldr	r3, [pc, #260]	; (20000de4 <RCC_GetClocksFreq+0x150>)
20000ce0:	685b      	ldr	r3, [r3, #4]
20000ce2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20000ce6:	60fb      	str	r3, [r7, #12]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
20000ce8:	693b      	ldr	r3, [r7, #16]
20000cea:	0c9b      	lsrs	r3, r3, #18
20000cec:	3302      	adds	r3, #2
20000cee:	613b      	str	r3, [r7, #16]
      
      if (pllsource == 0x00)
20000cf0:	68fb      	ldr	r3, [r7, #12]
20000cf2:	2b00      	cmp	r3, #0
20000cf4:	d106      	bne.n	20000d04 <RCC_GetClocksFreq+0x70>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
20000cf6:	693b      	ldr	r3, [r7, #16]
20000cf8:	4a3c      	ldr	r2, [pc, #240]	; (20000dec <RCC_GetClocksFreq+0x158>)
20000cfa:	fb02 f203 	mul.w	r2, r2, r3
20000cfe:	687b      	ldr	r3, [r7, #4]
20000d00:	601a      	str	r2, [r3, #0]
20000d02:	e013      	b.n	20000d2c <RCC_GetClocksFreq+0x98>
       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
20000d04:	4b37      	ldr	r3, [pc, #220]	; (20000de4 <RCC_GetClocksFreq+0x150>)
20000d06:	685b      	ldr	r3, [r3, #4]
20000d08:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20000d0c:	2b00      	cmp	r3, #0
20000d0e:	d006      	beq.n	20000d1e <RCC_GetClocksFreq+0x8a>
        {/* HSE oscillator clock divided by 2 */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
20000d10:	693b      	ldr	r3, [r7, #16]
20000d12:	4a36      	ldr	r2, [pc, #216]	; (20000dec <RCC_GetClocksFreq+0x158>)
20000d14:	fb02 f203 	mul.w	r2, r2, r3
20000d18:	687b      	ldr	r3, [r7, #4]
20000d1a:	601a      	str	r2, [r3, #0]
20000d1c:	e006      	b.n	20000d2c <RCC_GetClocksFreq+0x98>
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
20000d1e:	693b      	ldr	r3, [r7, #16]
20000d20:	4a31      	ldr	r2, [pc, #196]	; (20000de8 <RCC_GetClocksFreq+0x154>)
20000d22:	fb02 f203 	mul.w	r2, r2, r3
20000d26:	687b      	ldr	r3, [r7, #4]
20000d28:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
20000d2a:	e004      	b.n	20000d36 <RCC_GetClocksFreq+0xa2>
20000d2c:	e003      	b.n	20000d36 <RCC_GetClocksFreq+0xa2>

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
20000d2e:	687b      	ldr	r3, [r7, #4]
20000d30:	4a2d      	ldr	r2, [pc, #180]	; (20000de8 <RCC_GetClocksFreq+0x154>)
20000d32:	601a      	str	r2, [r3, #0]
      break;
20000d34:	bf00      	nop
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
20000d36:	4b2b      	ldr	r3, [pc, #172]	; (20000de4 <RCC_GetClocksFreq+0x150>)
20000d38:	685b      	ldr	r3, [r3, #4]
20000d3a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
20000d3e:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 4;
20000d40:	697b      	ldr	r3, [r7, #20]
20000d42:	091b      	lsrs	r3, r3, #4
20000d44:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
20000d46:	4a2a      	ldr	r2, [pc, #168]	; (20000df0 <RCC_GetClocksFreq+0x15c>)
20000d48:	697b      	ldr	r3, [r7, #20]
20000d4a:	4413      	add	r3, r2
20000d4c:	781b      	ldrb	r3, [r3, #0]
20000d4e:	b2db      	uxtb	r3, r3
20000d50:	60bb      	str	r3, [r7, #8]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
20000d52:	687b      	ldr	r3, [r7, #4]
20000d54:	681a      	ldr	r2, [r3, #0]
20000d56:	68bb      	ldr	r3, [r7, #8]
20000d58:	40da      	lsrs	r2, r3
20000d5a:	687b      	ldr	r3, [r7, #4]
20000d5c:	605a      	str	r2, [r3, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
20000d5e:	4b21      	ldr	r3, [pc, #132]	; (20000de4 <RCC_GetClocksFreq+0x150>)
20000d60:	685b      	ldr	r3, [r3, #4]
20000d62:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
20000d66:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 8;
20000d68:	697b      	ldr	r3, [r7, #20]
20000d6a:	0a1b      	lsrs	r3, r3, #8
20000d6c:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
20000d6e:	4a20      	ldr	r2, [pc, #128]	; (20000df0 <RCC_GetClocksFreq+0x15c>)
20000d70:	697b      	ldr	r3, [r7, #20]
20000d72:	4413      	add	r3, r2
20000d74:	781b      	ldrb	r3, [r3, #0]
20000d76:	b2db      	uxtb	r3, r3
20000d78:	60bb      	str	r3, [r7, #8]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
20000d7a:	687b      	ldr	r3, [r7, #4]
20000d7c:	685a      	ldr	r2, [r3, #4]
20000d7e:	68bb      	ldr	r3, [r7, #8]
20000d80:	40da      	lsrs	r2, r3
20000d82:	687b      	ldr	r3, [r7, #4]
20000d84:	609a      	str	r2, [r3, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
20000d86:	4b17      	ldr	r3, [pc, #92]	; (20000de4 <RCC_GetClocksFreq+0x150>)
20000d88:	685b      	ldr	r3, [r3, #4]
20000d8a:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
20000d8e:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 11;
20000d90:	697b      	ldr	r3, [r7, #20]
20000d92:	0adb      	lsrs	r3, r3, #11
20000d94:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
20000d96:	4a16      	ldr	r2, [pc, #88]	; (20000df0 <RCC_GetClocksFreq+0x15c>)
20000d98:	697b      	ldr	r3, [r7, #20]
20000d9a:	4413      	add	r3, r2
20000d9c:	781b      	ldrb	r3, [r3, #0]
20000d9e:	b2db      	uxtb	r3, r3
20000da0:	60bb      	str	r3, [r7, #8]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
20000da2:	687b      	ldr	r3, [r7, #4]
20000da4:	685a      	ldr	r2, [r3, #4]
20000da6:	68bb      	ldr	r3, [r7, #8]
20000da8:	40da      	lsrs	r2, r3
20000daa:	687b      	ldr	r3, [r7, #4]
20000dac:	60da      	str	r2, [r3, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
20000dae:	4b0d      	ldr	r3, [pc, #52]	; (20000de4 <RCC_GetClocksFreq+0x150>)
20000db0:	685b      	ldr	r3, [r3, #4]
20000db2:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
20000db6:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 14;
20000db8:	697b      	ldr	r3, [r7, #20]
20000dba:	0b9b      	lsrs	r3, r3, #14
20000dbc:	617b      	str	r3, [r7, #20]
  presc = ADCPrescTable[tmp];
20000dbe:	4a0d      	ldr	r2, [pc, #52]	; (20000df4 <RCC_GetClocksFreq+0x160>)
20000dc0:	697b      	ldr	r3, [r7, #20]
20000dc2:	4413      	add	r3, r2
20000dc4:	781b      	ldrb	r3, [r3, #0]
20000dc6:	b2db      	uxtb	r3, r3
20000dc8:	60bb      	str	r3, [r7, #8]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
20000dca:	687b      	ldr	r3, [r7, #4]
20000dcc:	68da      	ldr	r2, [r3, #12]
20000dce:	68bb      	ldr	r3, [r7, #8]
20000dd0:	fbb2 f2f3 	udiv	r2, r2, r3
20000dd4:	687b      	ldr	r3, [r7, #4]
20000dd6:	611a      	str	r2, [r3, #16]
}
20000dd8:	371c      	adds	r7, #28
20000dda:	46bd      	mov	sp, r7
20000ddc:	f85d 7b04 	ldr.w	r7, [sp], #4
20000de0:	4770      	bx	lr
20000de2:	bf00      	nop
20000de4:	40021000 	.word	0x40021000
20000de8:	007a1200 	.word	0x007a1200
20000dec:	003d0900 	.word	0x003d0900
20000df0:	20005000 	.word	0x20005000
20000df4:	20005010 	.word	0x20005010

20000df8 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
20000df8:	b480      	push	{r7}
20000dfa:	b083      	sub	sp, #12
20000dfc:	af00      	add	r7, sp, #0
20000dfe:	6078      	str	r0, [r7, #4]
20000e00:	460b      	mov	r3, r1
20000e02:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
20000e04:	78fb      	ldrb	r3, [r7, #3]
20000e06:	2b00      	cmp	r3, #0
20000e08:	d006      	beq.n	20000e18 <RCC_AHBPeriphClockCmd+0x20>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
20000e0a:	4b09      	ldr	r3, [pc, #36]	; (20000e30 <RCC_AHBPeriphClockCmd+0x38>)
20000e0c:	4a08      	ldr	r2, [pc, #32]	; (20000e30 <RCC_AHBPeriphClockCmd+0x38>)
20000e0e:	6951      	ldr	r1, [r2, #20]
20000e10:	687a      	ldr	r2, [r7, #4]
20000e12:	430a      	orrs	r2, r1
20000e14:	615a      	str	r2, [r3, #20]
20000e16:	e006      	b.n	20000e26 <RCC_AHBPeriphClockCmd+0x2e>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
20000e18:	4b05      	ldr	r3, [pc, #20]	; (20000e30 <RCC_AHBPeriphClockCmd+0x38>)
20000e1a:	4a05      	ldr	r2, [pc, #20]	; (20000e30 <RCC_AHBPeriphClockCmd+0x38>)
20000e1c:	6951      	ldr	r1, [r2, #20]
20000e1e:	687a      	ldr	r2, [r7, #4]
20000e20:	43d2      	mvns	r2, r2
20000e22:	400a      	ands	r2, r1
20000e24:	615a      	str	r2, [r3, #20]
  }
}
20000e26:	370c      	adds	r7, #12
20000e28:	46bd      	mov	sp, r7
20000e2a:	f85d 7b04 	ldr.w	r7, [sp], #4
20000e2e:	4770      	bx	lr
20000e30:	40021000 	.word	0x40021000

20000e34 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
20000e34:	b480      	push	{r7}
20000e36:	b083      	sub	sp, #12
20000e38:	af00      	add	r7, sp, #0
20000e3a:	6078      	str	r0, [r7, #4]
20000e3c:	460b      	mov	r3, r1
20000e3e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20000e40:	78fb      	ldrb	r3, [r7, #3]
20000e42:	2b00      	cmp	r3, #0
20000e44:	d006      	beq.n	20000e54 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
20000e46:	4b09      	ldr	r3, [pc, #36]	; (20000e6c <RCC_APB2PeriphClockCmd+0x38>)
20000e48:	4a08      	ldr	r2, [pc, #32]	; (20000e6c <RCC_APB2PeriphClockCmd+0x38>)
20000e4a:	6991      	ldr	r1, [r2, #24]
20000e4c:	687a      	ldr	r2, [r7, #4]
20000e4e:	430a      	orrs	r2, r1
20000e50:	619a      	str	r2, [r3, #24]
20000e52:	e006      	b.n	20000e62 <RCC_APB2PeriphClockCmd+0x2e>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
20000e54:	4b05      	ldr	r3, [pc, #20]	; (20000e6c <RCC_APB2PeriphClockCmd+0x38>)
20000e56:	4a05      	ldr	r2, [pc, #20]	; (20000e6c <RCC_APB2PeriphClockCmd+0x38>)
20000e58:	6991      	ldr	r1, [r2, #24]
20000e5a:	687a      	ldr	r2, [r7, #4]
20000e5c:	43d2      	mvns	r2, r2
20000e5e:	400a      	ands	r2, r1
20000e60:	619a      	str	r2, [r3, #24]
  }
}
20000e62:	370c      	adds	r7, #12
20000e64:	46bd      	mov	sp, r7
20000e66:	f85d 7b04 	ldr.w	r7, [sp], #4
20000e6a:	4770      	bx	lr
20000e6c:	40021000 	.word	0x40021000

20000e70 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
20000e70:	b480      	push	{r7}
20000e72:	b083      	sub	sp, #12
20000e74:	af00      	add	r7, sp, #0
20000e76:	6078      	str	r0, [r7, #4]
20000e78:	460b      	mov	r3, r1
20000e7a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20000e7c:	78fb      	ldrb	r3, [r7, #3]
20000e7e:	2b00      	cmp	r3, #0
20000e80:	d006      	beq.n	20000e90 <RCC_APB1PeriphClockCmd+0x20>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
20000e82:	4b09      	ldr	r3, [pc, #36]	; (20000ea8 <RCC_APB1PeriphClockCmd+0x38>)
20000e84:	4a08      	ldr	r2, [pc, #32]	; (20000ea8 <RCC_APB1PeriphClockCmd+0x38>)
20000e86:	69d1      	ldr	r1, [r2, #28]
20000e88:	687a      	ldr	r2, [r7, #4]
20000e8a:	430a      	orrs	r2, r1
20000e8c:	61da      	str	r2, [r3, #28]
20000e8e:	e006      	b.n	20000e9e <RCC_APB1PeriphClockCmd+0x2e>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
20000e90:	4b05      	ldr	r3, [pc, #20]	; (20000ea8 <RCC_APB1PeriphClockCmd+0x38>)
20000e92:	4a05      	ldr	r2, [pc, #20]	; (20000ea8 <RCC_APB1PeriphClockCmd+0x38>)
20000e94:	69d1      	ldr	r1, [r2, #28]
20000e96:	687a      	ldr	r2, [r7, #4]
20000e98:	43d2      	mvns	r2, r2
20000e9a:	400a      	ands	r2, r1
20000e9c:	61da      	str	r2, [r3, #28]
  }
}
20000e9e:	370c      	adds	r7, #12
20000ea0:	46bd      	mov	sp, r7
20000ea2:	f85d 7b04 	ldr.w	r7, [sp], #4
20000ea6:	4770      	bx	lr
20000ea8:	40021000 	.word	0x40021000

20000eac <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
20000eac:	b480      	push	{r7}
20000eae:	b083      	sub	sp, #12
20000eb0:	af00      	add	r7, sp, #0
20000eb2:	6078      	str	r0, [r7, #4]
20000eb4:	460b      	mov	r3, r1
20000eb6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20000eb8:	78fb      	ldrb	r3, [r7, #3]
20000eba:	2b00      	cmp	r3, #0
20000ebc:	d006      	beq.n	20000ecc <RCC_APB2PeriphResetCmd+0x20>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
20000ebe:	4b09      	ldr	r3, [pc, #36]	; (20000ee4 <RCC_APB2PeriphResetCmd+0x38>)
20000ec0:	4a08      	ldr	r2, [pc, #32]	; (20000ee4 <RCC_APB2PeriphResetCmd+0x38>)
20000ec2:	68d1      	ldr	r1, [r2, #12]
20000ec4:	687a      	ldr	r2, [r7, #4]
20000ec6:	430a      	orrs	r2, r1
20000ec8:	60da      	str	r2, [r3, #12]
20000eca:	e006      	b.n	20000eda <RCC_APB2PeriphResetCmd+0x2e>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
20000ecc:	4b05      	ldr	r3, [pc, #20]	; (20000ee4 <RCC_APB2PeriphResetCmd+0x38>)
20000ece:	4a05      	ldr	r2, [pc, #20]	; (20000ee4 <RCC_APB2PeriphResetCmd+0x38>)
20000ed0:	68d1      	ldr	r1, [r2, #12]
20000ed2:	687a      	ldr	r2, [r7, #4]
20000ed4:	43d2      	mvns	r2, r2
20000ed6:	400a      	ands	r2, r1
20000ed8:	60da      	str	r2, [r3, #12]
  }
}
20000eda:	370c      	adds	r7, #12
20000edc:	46bd      	mov	sp, r7
20000ede:	f85d 7b04 	ldr.w	r7, [sp], #4
20000ee2:	4770      	bx	lr
20000ee4:	40021000 	.word	0x40021000

20000ee8 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
20000ee8:	b480      	push	{r7}
20000eea:	b083      	sub	sp, #12
20000eec:	af00      	add	r7, sp, #0
20000eee:	6078      	str	r0, [r7, #4]
20000ef0:	460b      	mov	r3, r1
20000ef2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20000ef4:	78fb      	ldrb	r3, [r7, #3]
20000ef6:	2b00      	cmp	r3, #0
20000ef8:	d006      	beq.n	20000f08 <RCC_APB1PeriphResetCmd+0x20>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
20000efa:	4b09      	ldr	r3, [pc, #36]	; (20000f20 <RCC_APB1PeriphResetCmd+0x38>)
20000efc:	4a08      	ldr	r2, [pc, #32]	; (20000f20 <RCC_APB1PeriphResetCmd+0x38>)
20000efe:	6911      	ldr	r1, [r2, #16]
20000f00:	687a      	ldr	r2, [r7, #4]
20000f02:	430a      	orrs	r2, r1
20000f04:	611a      	str	r2, [r3, #16]
20000f06:	e006      	b.n	20000f16 <RCC_APB1PeriphResetCmd+0x2e>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
20000f08:	4b05      	ldr	r3, [pc, #20]	; (20000f20 <RCC_APB1PeriphResetCmd+0x38>)
20000f0a:	4a05      	ldr	r2, [pc, #20]	; (20000f20 <RCC_APB1PeriphResetCmd+0x38>)
20000f0c:	6911      	ldr	r1, [r2, #16]
20000f0e:	687a      	ldr	r2, [r7, #4]
20000f10:	43d2      	mvns	r2, r2
20000f12:	400a      	ands	r2, r1
20000f14:	611a      	str	r2, [r3, #16]
  }
}
20000f16:	370c      	adds	r7, #12
20000f18:	46bd      	mov	sp, r7
20000f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
20000f1e:	4770      	bx	lr
20000f20:	40021000 	.word	0x40021000

20000f24 <RCC_BackupResetCmd>:
  * @param  NewState: new state of the Backup domain reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
20000f24:	b480      	push	{r7}
20000f26:	b083      	sub	sp, #12
20000f28:	af00      	add	r7, sp, #0
20000f2a:	4603      	mov	r3, r0
20000f2c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
20000f2e:	4b04      	ldr	r3, [pc, #16]	; (20000f40 <RCC_BackupResetCmd+0x1c>)
20000f30:	79fa      	ldrb	r2, [r7, #7]
20000f32:	601a      	str	r2, [r3, #0]
}
20000f34:	370c      	adds	r7, #12
20000f36:	46bd      	mov	sp, r7
20000f38:	f85d 7b04 	ldr.w	r7, [sp], #4
20000f3c:	4770      	bx	lr
20000f3e:	bf00      	nop
20000f40:	42420440 	.word	0x42420440

20000f44 <RCC_ClockSecuritySystemCmd>:
  * @param  NewState: new state of the Clock Security System..
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
20000f44:	b480      	push	{r7}
20000f46:	b083      	sub	sp, #12
20000f48:	af00      	add	r7, sp, #0
20000f4a:	4603      	mov	r3, r0
20000f4c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
20000f4e:	4b04      	ldr	r3, [pc, #16]	; (20000f60 <RCC_ClockSecuritySystemCmd+0x1c>)
20000f50:	79fa      	ldrb	r2, [r7, #7]
20000f52:	601a      	str	r2, [r3, #0]
}
20000f54:	370c      	adds	r7, #12
20000f56:	46bd      	mov	sp, r7
20000f58:	f85d 7b04 	ldr.w	r7, [sp], #4
20000f5c:	4770      	bx	lr
20000f5e:	bf00      	nop
20000f60:	4242004c 	.word	0x4242004c

20000f64 <RCC_MCOConfig>:
  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
  *   
  * @retval None
  */
void RCC_MCOConfig(uint8_t RCC_MCO)
{
20000f64:	b480      	push	{r7}
20000f66:	b083      	sub	sp, #12
20000f68:	af00      	add	r7, sp, #0
20000f6a:	4603      	mov	r3, r0
20000f6c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO bits to select the MCO source */
  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
20000f6e:	4b04      	ldr	r3, [pc, #16]	; (20000f80 <RCC_MCOConfig+0x1c>)
20000f70:	79fa      	ldrb	r2, [r7, #7]
20000f72:	701a      	strb	r2, [r3, #0]
}
20000f74:	370c      	adds	r7, #12
20000f76:	46bd      	mov	sp, r7
20000f78:	f85d 7b04 	ldr.w	r7, [sp], #4
20000f7c:	4770      	bx	lr
20000f7e:	bf00      	nop
20000f80:	40021007 	.word	0x40021007

20000f84 <RCC_GetFlagStatus>:
  *     @arg RCC_FLAG_LPWRRST: Low Power reset
  *   
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
20000f84:	b480      	push	{r7}
20000f86:	b087      	sub	sp, #28
20000f88:	af00      	add	r7, sp, #0
20000f8a:	4603      	mov	r3, r0
20000f8c:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
20000f8e:	2300      	movs	r3, #0
20000f90:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
20000f92:	2300      	movs	r3, #0
20000f94:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
20000f96:	2300      	movs	r3, #0
20000f98:	74fb      	strb	r3, [r7, #19]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
20000f9a:	79fb      	ldrb	r3, [r7, #7]
20000f9c:	095b      	lsrs	r3, r3, #5
20000f9e:	b2db      	uxtb	r3, r3
20000fa0:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
20000fa2:	68fb      	ldr	r3, [r7, #12]
20000fa4:	2b01      	cmp	r3, #1
20000fa6:	d103      	bne.n	20000fb0 <RCC_GetFlagStatus+0x2c>
  {
    statusreg = RCC->CR;
20000fa8:	4b12      	ldr	r3, [pc, #72]	; (20000ff4 <RCC_GetFlagStatus+0x70>)
20000faa:	681b      	ldr	r3, [r3, #0]
20000fac:	617b      	str	r3, [r7, #20]
20000fae:	e009      	b.n	20000fc4 <RCC_GetFlagStatus+0x40>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
20000fb0:	68fb      	ldr	r3, [r7, #12]
20000fb2:	2b02      	cmp	r3, #2
20000fb4:	d103      	bne.n	20000fbe <RCC_GetFlagStatus+0x3a>
  {
    statusreg = RCC->BDCR;
20000fb6:	4b0f      	ldr	r3, [pc, #60]	; (20000ff4 <RCC_GetFlagStatus+0x70>)
20000fb8:	6a1b      	ldr	r3, [r3, #32]
20000fba:	617b      	str	r3, [r7, #20]
20000fbc:	e002      	b.n	20000fc4 <RCC_GetFlagStatus+0x40>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
20000fbe:	4b0d      	ldr	r3, [pc, #52]	; (20000ff4 <RCC_GetFlagStatus+0x70>)
20000fc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
20000fc2:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
20000fc4:	79fb      	ldrb	r3, [r7, #7]
20000fc6:	f003 031f 	and.w	r3, r3, #31
20000fca:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
20000fcc:	68fb      	ldr	r3, [r7, #12]
20000fce:	697a      	ldr	r2, [r7, #20]
20000fd0:	fa22 f303 	lsr.w	r3, r2, r3
20000fd4:	f003 0301 	and.w	r3, r3, #1
20000fd8:	2b00      	cmp	r3, #0
20000fda:	d002      	beq.n	20000fe2 <RCC_GetFlagStatus+0x5e>
  {
    bitstatus = SET;
20000fdc:	2301      	movs	r3, #1
20000fde:	74fb      	strb	r3, [r7, #19]
20000fe0:	e001      	b.n	20000fe6 <RCC_GetFlagStatus+0x62>
  }
  else
  {
    bitstatus = RESET;
20000fe2:	2300      	movs	r3, #0
20000fe4:	74fb      	strb	r3, [r7, #19]
  }

  /* Return the flag status */
  return bitstatus;
20000fe6:	7cfb      	ldrb	r3, [r7, #19]
}
20000fe8:	4618      	mov	r0, r3
20000fea:	371c      	adds	r7, #28
20000fec:	46bd      	mov	sp, r7
20000fee:	f85d 7b04 	ldr.w	r7, [sp], #4
20000ff2:	4770      	bx	lr
20000ff4:	40021000 	.word	0x40021000

20000ff8 <RCC_ClearFlag>:
  *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
  * @param  None
  * @retval None
  */
void RCC_ClearFlag(void)
{
20000ff8:	b480      	push	{r7}
20000ffa:	af00      	add	r7, sp, #0
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
20000ffc:	4b04      	ldr	r3, [pc, #16]	; (20001010 <RCC_ClearFlag+0x18>)
20000ffe:	4a04      	ldr	r2, [pc, #16]	; (20001010 <RCC_ClearFlag+0x18>)
20001000:	6a52      	ldr	r2, [r2, #36]	; 0x24
20001002:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
20001006:	625a      	str	r2, [r3, #36]	; 0x24
}
20001008:	46bd      	mov	sp, r7
2000100a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000100e:	4770      	bx	lr
20001010:	40021000 	.word	0x40021000

20001014 <RCC_GetITStatus>:
  *     @arg RCC_IT_CSS: Clock Security System interrupt
  *   
  * @retval The new state of RCC_IT (SET or RESET).
  */
ITStatus RCC_GetITStatus(uint8_t RCC_IT)
{
20001014:	b480      	push	{r7}
20001016:	b085      	sub	sp, #20
20001018:	af00      	add	r7, sp, #0
2000101a:	4603      	mov	r3, r0
2000101c:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
2000101e:	2300      	movs	r3, #0
20001020:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
20001022:	4b09      	ldr	r3, [pc, #36]	; (20001048 <RCC_GetITStatus+0x34>)
20001024:	689a      	ldr	r2, [r3, #8]
20001026:	79fb      	ldrb	r3, [r7, #7]
20001028:	4013      	ands	r3, r2
2000102a:	2b00      	cmp	r3, #0
2000102c:	d002      	beq.n	20001034 <RCC_GetITStatus+0x20>
  {
    bitstatus = SET;
2000102e:	2301      	movs	r3, #1
20001030:	73fb      	strb	r3, [r7, #15]
20001032:	e001      	b.n	20001038 <RCC_GetITStatus+0x24>
  }
  else
  {
    bitstatus = RESET;
20001034:	2300      	movs	r3, #0
20001036:	73fb      	strb	r3, [r7, #15]
  }

  /* Return the RCC_IT status */
  return  bitstatus;
20001038:	7bfb      	ldrb	r3, [r7, #15]
}
2000103a:	4618      	mov	r0, r3
2000103c:	3714      	adds	r7, #20
2000103e:	46bd      	mov	sp, r7
20001040:	f85d 7b04 	ldr.w	r7, [sp], #4
20001044:	4770      	bx	lr
20001046:	bf00      	nop
20001048:	40021000 	.word	0x40021000

2000104c <RCC_ClearITPendingBit>:
  *   
  *     @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval None
  */
void RCC_ClearITPendingBit(uint8_t RCC_IT)
{
2000104c:	b480      	push	{r7}
2000104e:	b083      	sub	sp, #12
20001050:	af00      	add	r7, sp, #0
20001052:	4603      	mov	r3, r0
20001054:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
20001056:	4b04      	ldr	r3, [pc, #16]	; (20001068 <RCC_ClearITPendingBit+0x1c>)
20001058:	79fa      	ldrb	r2, [r7, #7]
2000105a:	701a      	strb	r2, [r3, #0]
}
2000105c:	370c      	adds	r7, #12
2000105e:	46bd      	mov	sp, r7
20001060:	f85d 7b04 	ldr.w	r7, [sp], #4
20001064:	4770      	bx	lr
20001066:	bf00      	nop
20001068:	4002100a 	.word	0x4002100a

2000106c <TIM_DeInit>:
  * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
  * @retval None
  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
2000106c:	b580      	push	{r7, lr}
2000106e:	b082      	sub	sp, #8
20001070:	af00      	add	r7, sp, #0
20001072:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
20001074:	687a      	ldr	r2, [r7, #4]
20001076:	4b78      	ldr	r3, [pc, #480]	; (20001258 <TIM_DeInit+0x1ec>)
20001078:	429a      	cmp	r2, r3
2000107a:	d10a      	bne.n	20001092 <TIM_DeInit+0x26>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
2000107c:	f44f 6000 	mov.w	r0, #2048	; 0x800
20001080:	2101      	movs	r1, #1
20001082:	f7ff ff13 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
20001086:	f44f 6000 	mov.w	r0, #2048	; 0x800
2000108a:	2100      	movs	r1, #0
2000108c:	f7ff ff0e 	bl	20000eac <RCC_APB2PeriphResetCmd>
20001090:	e0de      	b.n	20001250 <TIM_DeInit+0x1e4>
  }     
  else if (TIMx == TIM2)
20001092:	687b      	ldr	r3, [r7, #4]
20001094:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20001098:	d108      	bne.n	200010ac <TIM_DeInit+0x40>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
2000109a:	2001      	movs	r0, #1
2000109c:	2101      	movs	r1, #1
2000109e:	f7ff ff23 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
200010a2:	2001      	movs	r0, #1
200010a4:	2100      	movs	r1, #0
200010a6:	f7ff ff1f 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
200010aa:	e0d1      	b.n	20001250 <TIM_DeInit+0x1e4>
  }
  else if (TIMx == TIM3)
200010ac:	687a      	ldr	r2, [r7, #4]
200010ae:	4b6b      	ldr	r3, [pc, #428]	; (2000125c <TIM_DeInit+0x1f0>)
200010b0:	429a      	cmp	r2, r3
200010b2:	d108      	bne.n	200010c6 <TIM_DeInit+0x5a>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
200010b4:	2002      	movs	r0, #2
200010b6:	2101      	movs	r1, #1
200010b8:	f7ff ff16 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
200010bc:	2002      	movs	r0, #2
200010be:	2100      	movs	r1, #0
200010c0:	f7ff ff12 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
200010c4:	e0c4      	b.n	20001250 <TIM_DeInit+0x1e4>
  }
  else if (TIMx == TIM4)
200010c6:	687a      	ldr	r2, [r7, #4]
200010c8:	4b65      	ldr	r3, [pc, #404]	; (20001260 <TIM_DeInit+0x1f4>)
200010ca:	429a      	cmp	r2, r3
200010cc:	d108      	bne.n	200010e0 <TIM_DeInit+0x74>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
200010ce:	2004      	movs	r0, #4
200010d0:	2101      	movs	r1, #1
200010d2:	f7ff ff09 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
200010d6:	2004      	movs	r0, #4
200010d8:	2100      	movs	r1, #0
200010da:	f7ff ff05 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
200010de:	e0b7      	b.n	20001250 <TIM_DeInit+0x1e4>
  } 
  else if (TIMx == TIM5)
200010e0:	687a      	ldr	r2, [r7, #4]
200010e2:	4b60      	ldr	r3, [pc, #384]	; (20001264 <TIM_DeInit+0x1f8>)
200010e4:	429a      	cmp	r2, r3
200010e6:	d108      	bne.n	200010fa <TIM_DeInit+0x8e>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
200010e8:	2008      	movs	r0, #8
200010ea:	2101      	movs	r1, #1
200010ec:	f7ff fefc 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
200010f0:	2008      	movs	r0, #8
200010f2:	2100      	movs	r1, #0
200010f4:	f7ff fef8 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
200010f8:	e0aa      	b.n	20001250 <TIM_DeInit+0x1e4>
  } 
  else if (TIMx == TIM6)
200010fa:	687a      	ldr	r2, [r7, #4]
200010fc:	4b5a      	ldr	r3, [pc, #360]	; (20001268 <TIM_DeInit+0x1fc>)
200010fe:	429a      	cmp	r2, r3
20001100:	d108      	bne.n	20001114 <TIM_DeInit+0xa8>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
20001102:	2010      	movs	r0, #16
20001104:	2101      	movs	r1, #1
20001106:	f7ff feef 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
2000110a:	2010      	movs	r0, #16
2000110c:	2100      	movs	r1, #0
2000110e:	f7ff feeb 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
20001112:	e09d      	b.n	20001250 <TIM_DeInit+0x1e4>
  } 
  else if (TIMx == TIM7)
20001114:	687a      	ldr	r2, [r7, #4]
20001116:	4b55      	ldr	r3, [pc, #340]	; (2000126c <TIM_DeInit+0x200>)
20001118:	429a      	cmp	r2, r3
2000111a:	d108      	bne.n	2000112e <TIM_DeInit+0xc2>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
2000111c:	2020      	movs	r0, #32
2000111e:	2101      	movs	r1, #1
20001120:	f7ff fee2 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
20001124:	2020      	movs	r0, #32
20001126:	2100      	movs	r1, #0
20001128:	f7ff fede 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
2000112c:	e090      	b.n	20001250 <TIM_DeInit+0x1e4>
  } 
  else if (TIMx == TIM8)
2000112e:	687a      	ldr	r2, [r7, #4]
20001130:	4b4f      	ldr	r3, [pc, #316]	; (20001270 <TIM_DeInit+0x204>)
20001132:	429a      	cmp	r2, r3
20001134:	d10a      	bne.n	2000114c <TIM_DeInit+0xe0>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
20001136:	f44f 5000 	mov.w	r0, #8192	; 0x2000
2000113a:	2101      	movs	r1, #1
2000113c:	f7ff feb6 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
20001140:	f44f 5000 	mov.w	r0, #8192	; 0x2000
20001144:	2100      	movs	r1, #0
20001146:	f7ff feb1 	bl	20000eac <RCC_APB2PeriphResetCmd>
2000114a:	e081      	b.n	20001250 <TIM_DeInit+0x1e4>
  }
  else if (TIMx == TIM9)
2000114c:	687a      	ldr	r2, [r7, #4]
2000114e:	4b49      	ldr	r3, [pc, #292]	; (20001274 <TIM_DeInit+0x208>)
20001150:	429a      	cmp	r2, r3
20001152:	d10a      	bne.n	2000116a <TIM_DeInit+0xfe>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
20001154:	f44f 2000 	mov.w	r0, #524288	; 0x80000
20001158:	2101      	movs	r1, #1
2000115a:	f7ff fea7 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
2000115e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
20001162:	2100      	movs	r1, #0
20001164:	f7ff fea2 	bl	20000eac <RCC_APB2PeriphResetCmd>
20001168:	e072      	b.n	20001250 <TIM_DeInit+0x1e4>
   }  
  else if (TIMx == TIM10)
2000116a:	687a      	ldr	r2, [r7, #4]
2000116c:	4b42      	ldr	r3, [pc, #264]	; (20001278 <TIM_DeInit+0x20c>)
2000116e:	429a      	cmp	r2, r3
20001170:	d10a      	bne.n	20001188 <TIM_DeInit+0x11c>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
20001172:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
20001176:	2101      	movs	r1, #1
20001178:	f7ff fe98 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
2000117c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
20001180:	2100      	movs	r1, #0
20001182:	f7ff fe93 	bl	20000eac <RCC_APB2PeriphResetCmd>
20001186:	e063      	b.n	20001250 <TIM_DeInit+0x1e4>
  }  
  else if (TIMx == TIM11) 
20001188:	687a      	ldr	r2, [r7, #4]
2000118a:	4b3c      	ldr	r3, [pc, #240]	; (2000127c <TIM_DeInit+0x210>)
2000118c:	429a      	cmp	r2, r3
2000118e:	d10a      	bne.n	200011a6 <TIM_DeInit+0x13a>
  {     
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
20001190:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
20001194:	2101      	movs	r1, #1
20001196:	f7ff fe89 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
2000119a:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
2000119e:	2100      	movs	r1, #0
200011a0:	f7ff fe84 	bl	20000eac <RCC_APB2PeriphResetCmd>
200011a4:	e054      	b.n	20001250 <TIM_DeInit+0x1e4>
  }  
  else if (TIMx == TIM12)
200011a6:	687a      	ldr	r2, [r7, #4]
200011a8:	4b35      	ldr	r3, [pc, #212]	; (20001280 <TIM_DeInit+0x214>)
200011aa:	429a      	cmp	r2, r3
200011ac:	d108      	bne.n	200011c0 <TIM_DeInit+0x154>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
200011ae:	2040      	movs	r0, #64	; 0x40
200011b0:	2101      	movs	r1, #1
200011b2:	f7ff fe99 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
200011b6:	2040      	movs	r0, #64	; 0x40
200011b8:	2100      	movs	r1, #0
200011ba:	f7ff fe95 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
200011be:	e047      	b.n	20001250 <TIM_DeInit+0x1e4>
  }  
  else if (TIMx == TIM13) 
200011c0:	687a      	ldr	r2, [r7, #4]
200011c2:	4b30      	ldr	r3, [pc, #192]	; (20001284 <TIM_DeInit+0x218>)
200011c4:	429a      	cmp	r2, r3
200011c6:	d108      	bne.n	200011da <TIM_DeInit+0x16e>
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
200011c8:	2080      	movs	r0, #128	; 0x80
200011ca:	2101      	movs	r1, #1
200011cc:	f7ff fe8c 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
200011d0:	2080      	movs	r0, #128	; 0x80
200011d2:	2100      	movs	r1, #0
200011d4:	f7ff fe88 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
200011d8:	e03a      	b.n	20001250 <TIM_DeInit+0x1e4>
  }
  else if (TIMx == TIM14) 
200011da:	687a      	ldr	r2, [r7, #4]
200011dc:	4b2a      	ldr	r3, [pc, #168]	; (20001288 <TIM_DeInit+0x21c>)
200011de:	429a      	cmp	r2, r3
200011e0:	d10a      	bne.n	200011f8 <TIM_DeInit+0x18c>
  {       
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
200011e2:	f44f 7080 	mov.w	r0, #256	; 0x100
200011e6:	2101      	movs	r1, #1
200011e8:	f7ff fe7e 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
200011ec:	f44f 7080 	mov.w	r0, #256	; 0x100
200011f0:	2100      	movs	r1, #0
200011f2:	f7ff fe79 	bl	20000ee8 <RCC_APB1PeriphResetCmd>
200011f6:	e02b      	b.n	20001250 <TIM_DeInit+0x1e4>
  }        
  else if (TIMx == TIM15)
200011f8:	687a      	ldr	r2, [r7, #4]
200011fa:	4b24      	ldr	r3, [pc, #144]	; (2000128c <TIM_DeInit+0x220>)
200011fc:	429a      	cmp	r2, r3
200011fe:	d10a      	bne.n	20001216 <TIM_DeInit+0x1aa>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
20001200:	f44f 3080 	mov.w	r0, #65536	; 0x10000
20001204:	2101      	movs	r1, #1
20001206:	f7ff fe51 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
2000120a:	f44f 3080 	mov.w	r0, #65536	; 0x10000
2000120e:	2100      	movs	r1, #0
20001210:	f7ff fe4c 	bl	20000eac <RCC_APB2PeriphResetCmd>
20001214:	e01c      	b.n	20001250 <TIM_DeInit+0x1e4>
  } 
  else if (TIMx == TIM16)
20001216:	687a      	ldr	r2, [r7, #4]
20001218:	4b1d      	ldr	r3, [pc, #116]	; (20001290 <TIM_DeInit+0x224>)
2000121a:	429a      	cmp	r2, r3
2000121c:	d10a      	bne.n	20001234 <TIM_DeInit+0x1c8>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
2000121e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
20001222:	2101      	movs	r1, #1
20001224:	f7ff fe42 	bl	20000eac <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
20001228:	f44f 3000 	mov.w	r0, #131072	; 0x20000
2000122c:	2100      	movs	r1, #0
2000122e:	f7ff fe3d 	bl	20000eac <RCC_APB2PeriphResetCmd>
20001232:	e00d      	b.n	20001250 <TIM_DeInit+0x1e4>
  } 
  else
  {
    if (TIMx == TIM17)
20001234:	687a      	ldr	r2, [r7, #4]
20001236:	4b17      	ldr	r3, [pc, #92]	; (20001294 <TIM_DeInit+0x228>)
20001238:	429a      	cmp	r2, r3
2000123a:	d109      	bne.n	20001250 <TIM_DeInit+0x1e4>
    {
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
2000123c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
20001240:	2101      	movs	r1, #1
20001242:	f7ff fe33 	bl	20000eac <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
20001246:	f44f 2080 	mov.w	r0, #262144	; 0x40000
2000124a:	2100      	movs	r1, #0
2000124c:	f7ff fe2e 	bl	20000eac <RCC_APB2PeriphResetCmd>
    }  
  }
}
20001250:	3708      	adds	r7, #8
20001252:	46bd      	mov	sp, r7
20001254:	bd80      	pop	{r7, pc}
20001256:	bf00      	nop
20001258:	40012c00 	.word	0x40012c00
2000125c:	40000400 	.word	0x40000400
20001260:	40000800 	.word	0x40000800
20001264:	40000c00 	.word	0x40000c00
20001268:	40001000 	.word	0x40001000
2000126c:	40001400 	.word	0x40001400
20001270:	40013400 	.word	0x40013400
20001274:	40014c00 	.word	0x40014c00
20001278:	40015000 	.word	0x40015000
2000127c:	40015400 	.word	0x40015400
20001280:	40001800 	.word	0x40001800
20001284:	40001c00 	.word	0x40001c00
20001288:	40002000 	.word	0x40002000
2000128c:	40014000 	.word	0x40014000
20001290:	40014400 	.word	0x40014400
20001294:	40014800 	.word	0x40014800

20001298 <TIM_TimeBaseInit>:
  *         structure that contains the configuration information for the 
  *         specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
20001298:	b480      	push	{r7}
2000129a:	b085      	sub	sp, #20
2000129c:	af00      	add	r7, sp, #0
2000129e:	6078      	str	r0, [r7, #4]
200012a0:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
200012a2:	2300      	movs	r3, #0
200012a4:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
200012a6:	687b      	ldr	r3, [r7, #4]
200012a8:	881b      	ldrh	r3, [r3, #0]
200012aa:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
200012ac:	687a      	ldr	r2, [r7, #4]
200012ae:	4b2e      	ldr	r3, [pc, #184]	; (20001368 <TIM_TimeBaseInit+0xd0>)
200012b0:	429a      	cmp	r2, r3
200012b2:	d013      	beq.n	200012dc <TIM_TimeBaseInit+0x44>
200012b4:	687a      	ldr	r2, [r7, #4]
200012b6:	4b2d      	ldr	r3, [pc, #180]	; (2000136c <TIM_TimeBaseInit+0xd4>)
200012b8:	429a      	cmp	r2, r3
200012ba:	d00f      	beq.n	200012dc <TIM_TimeBaseInit+0x44>
200012bc:	687b      	ldr	r3, [r7, #4]
200012be:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
200012c2:	d00b      	beq.n	200012dc <TIM_TimeBaseInit+0x44>
200012c4:	687a      	ldr	r2, [r7, #4]
200012c6:	4b2a      	ldr	r3, [pc, #168]	; (20001370 <TIM_TimeBaseInit+0xd8>)
200012c8:	429a      	cmp	r2, r3
200012ca:	d007      	beq.n	200012dc <TIM_TimeBaseInit+0x44>
200012cc:	687a      	ldr	r2, [r7, #4]
200012ce:	4b29      	ldr	r3, [pc, #164]	; (20001374 <TIM_TimeBaseInit+0xdc>)
200012d0:	429a      	cmp	r2, r3
200012d2:	d003      	beq.n	200012dc <TIM_TimeBaseInit+0x44>
     (TIMx == TIM4) || (TIMx == TIM5)) 
200012d4:	687a      	ldr	r2, [r7, #4]
200012d6:	4b28      	ldr	r3, [pc, #160]	; (20001378 <TIM_TimeBaseInit+0xe0>)
200012d8:	429a      	cmp	r2, r3
200012da:	d108      	bne.n	200012ee <TIM_TimeBaseInit+0x56>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
200012dc:	89fb      	ldrh	r3, [r7, #14]
200012de:	f023 0370 	bic.w	r3, r3, #112	; 0x70
200012e2:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
200012e4:	683b      	ldr	r3, [r7, #0]
200012e6:	885a      	ldrh	r2, [r3, #2]
200012e8:	89fb      	ldrh	r3, [r7, #14]
200012ea:	4313      	orrs	r3, r2
200012ec:	81fb      	strh	r3, [r7, #14]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
200012ee:	687a      	ldr	r2, [r7, #4]
200012f0:	4b22      	ldr	r3, [pc, #136]	; (2000137c <TIM_TimeBaseInit+0xe4>)
200012f2:	429a      	cmp	r2, r3
200012f4:	d00c      	beq.n	20001310 <TIM_TimeBaseInit+0x78>
200012f6:	687a      	ldr	r2, [r7, #4]
200012f8:	4b21      	ldr	r3, [pc, #132]	; (20001380 <TIM_TimeBaseInit+0xe8>)
200012fa:	429a      	cmp	r2, r3
200012fc:	d008      	beq.n	20001310 <TIM_TimeBaseInit+0x78>
  {
    /* Set the clock division */
    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
200012fe:	89fb      	ldrh	r3, [r7, #14]
20001300:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20001304:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
20001306:	683b      	ldr	r3, [r7, #0]
20001308:	88da      	ldrh	r2, [r3, #6]
2000130a:	89fb      	ldrh	r3, [r7, #14]
2000130c:	4313      	orrs	r3, r2
2000130e:	81fb      	strh	r3, [r7, #14]
  }

  TIMx->CR1 = tmpcr1;
20001310:	687b      	ldr	r3, [r7, #4]
20001312:	89fa      	ldrh	r2, [r7, #14]
20001314:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
20001316:	683b      	ldr	r3, [r7, #0]
20001318:	889a      	ldrh	r2, [r3, #4]
2000131a:	687b      	ldr	r3, [r7, #4]
2000131c:	859a      	strh	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
2000131e:	683b      	ldr	r3, [r7, #0]
20001320:	881a      	ldrh	r2, [r3, #0]
20001322:	687b      	ldr	r3, [r7, #4]
20001324:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
20001326:	687a      	ldr	r2, [r7, #4]
20001328:	4b0f      	ldr	r3, [pc, #60]	; (20001368 <TIM_TimeBaseInit+0xd0>)
2000132a:	429a      	cmp	r2, r3
2000132c:	d00f      	beq.n	2000134e <TIM_TimeBaseInit+0xb6>
2000132e:	687a      	ldr	r2, [r7, #4]
20001330:	4b0e      	ldr	r3, [pc, #56]	; (2000136c <TIM_TimeBaseInit+0xd4>)
20001332:	429a      	cmp	r2, r3
20001334:	d00b      	beq.n	2000134e <TIM_TimeBaseInit+0xb6>
20001336:	687a      	ldr	r2, [r7, #4]
20001338:	4b12      	ldr	r3, [pc, #72]	; (20001384 <TIM_TimeBaseInit+0xec>)
2000133a:	429a      	cmp	r2, r3
2000133c:	d007      	beq.n	2000134e <TIM_TimeBaseInit+0xb6>
2000133e:	687a      	ldr	r2, [r7, #4]
20001340:	4b11      	ldr	r3, [pc, #68]	; (20001388 <TIM_TimeBaseInit+0xf0>)
20001342:	429a      	cmp	r2, r3
20001344:	d003      	beq.n	2000134e <TIM_TimeBaseInit+0xb6>
20001346:	687a      	ldr	r2, [r7, #4]
20001348:	4b10      	ldr	r3, [pc, #64]	; (2000138c <TIM_TimeBaseInit+0xf4>)
2000134a:	429a      	cmp	r2, r3
2000134c:	d104      	bne.n	20001358 <TIM_TimeBaseInit+0xc0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
2000134e:	683b      	ldr	r3, [r7, #0]
20001350:	7a1b      	ldrb	r3, [r3, #8]
20001352:	461a      	mov	r2, r3
20001354:	687b      	ldr	r3, [r7, #4]
20001356:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler and the Repetition counter
     values immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
20001358:	687b      	ldr	r3, [r7, #4]
2000135a:	2201      	movs	r2, #1
2000135c:	829a      	strh	r2, [r3, #20]
}
2000135e:	3714      	adds	r7, #20
20001360:	46bd      	mov	sp, r7
20001362:	f85d 7b04 	ldr.w	r7, [sp], #4
20001366:	4770      	bx	lr
20001368:	40012c00 	.word	0x40012c00
2000136c:	40013400 	.word	0x40013400
20001370:	40000400 	.word	0x40000400
20001374:	40000800 	.word	0x40000800
20001378:	40000c00 	.word	0x40000c00
2000137c:	40001000 	.word	0x40001000
20001380:	40001400 	.word	0x40001400
20001384:	40014000 	.word	0x40014000
20001388:	40014400 	.word	0x40014400
2000138c:	40014800 	.word	0x40014800

20001390 <TIM_OC1Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
20001390:	b480      	push	{r7}
20001392:	b085      	sub	sp, #20
20001394:	af00      	add	r7, sp, #0
20001396:	6078      	str	r0, [r7, #4]
20001398:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
2000139a:	2300      	movs	r3, #0
2000139c:	817b      	strh	r3, [r7, #10]
2000139e:	2300      	movs	r3, #0
200013a0:	81fb      	strh	r3, [r7, #14]
200013a2:	2300      	movs	r3, #0
200013a4:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
 /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
200013a6:	687b      	ldr	r3, [r7, #4]
200013a8:	8c1b      	ldrh	r3, [r3, #32]
200013aa:	b29b      	uxth	r3, r3
200013ac:	f023 0301 	bic.w	r3, r3, #1
200013b0:	b29a      	uxth	r2, r3
200013b2:	687b      	ldr	r3, [r7, #4]
200013b4:	841a      	strh	r2, [r3, #32]
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
200013b6:	687b      	ldr	r3, [r7, #4]
200013b8:	8c1b      	ldrh	r3, [r3, #32]
200013ba:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
200013bc:	687b      	ldr	r3, [r7, #4]
200013be:	889b      	ldrh	r3, [r3, #4]
200013c0:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
200013c2:	687b      	ldr	r3, [r7, #4]
200013c4:	8b1b      	ldrh	r3, [r3, #24]
200013c6:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
200013c8:	897b      	ldrh	r3, [r7, #10]
200013ca:	f023 0370 	bic.w	r3, r3, #112	; 0x70
200013ce:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
200013d0:	897b      	ldrh	r3, [r7, #10]
200013d2:	f023 0303 	bic.w	r3, r3, #3
200013d6:	817b      	strh	r3, [r7, #10]

  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
200013d8:	683b      	ldr	r3, [r7, #0]
200013da:	881a      	ldrh	r2, [r3, #0]
200013dc:	897b      	ldrh	r3, [r7, #10]
200013de:	4313      	orrs	r3, r2
200013e0:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
200013e2:	89fb      	ldrh	r3, [r7, #14]
200013e4:	f023 0302 	bic.w	r3, r3, #2
200013e8:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
200013ea:	683b      	ldr	r3, [r7, #0]
200013ec:	891a      	ldrh	r2, [r3, #8]
200013ee:	89fb      	ldrh	r3, [r7, #14]
200013f0:	4313      	orrs	r3, r2
200013f2:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
200013f4:	683b      	ldr	r3, [r7, #0]
200013f6:	885a      	ldrh	r2, [r3, #2]
200013f8:	89fb      	ldrh	r3, [r7, #14]
200013fa:	4313      	orrs	r3, r2
200013fc:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
200013fe:	687a      	ldr	r2, [r7, #4]
20001400:	4b24      	ldr	r3, [pc, #144]	; (20001494 <TIM_OC1Init+0x104>)
20001402:	429a      	cmp	r2, r3
20001404:	d00f      	beq.n	20001426 <TIM_OC1Init+0x96>
20001406:	687a      	ldr	r2, [r7, #4]
20001408:	4b23      	ldr	r3, [pc, #140]	; (20001498 <TIM_OC1Init+0x108>)
2000140a:	429a      	cmp	r2, r3
2000140c:	d00b      	beq.n	20001426 <TIM_OC1Init+0x96>
2000140e:	687a      	ldr	r2, [r7, #4]
20001410:	4b22      	ldr	r3, [pc, #136]	; (2000149c <TIM_OC1Init+0x10c>)
20001412:	429a      	cmp	r2, r3
20001414:	d007      	beq.n	20001426 <TIM_OC1Init+0x96>
20001416:	687a      	ldr	r2, [r7, #4]
20001418:	4b21      	ldr	r3, [pc, #132]	; (200014a0 <TIM_OC1Init+0x110>)
2000141a:	429a      	cmp	r2, r3
2000141c:	d003      	beq.n	20001426 <TIM_OC1Init+0x96>
     (TIMx == TIM16)|| (TIMx == TIM17))
2000141e:	687a      	ldr	r2, [r7, #4]
20001420:	4b20      	ldr	r3, [pc, #128]	; (200014a4 <TIM_OC1Init+0x114>)
20001422:	429a      	cmp	r2, r3
20001424:	d123      	bne.n	2000146e <TIM_OC1Init+0xde>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
20001426:	89fb      	ldrh	r3, [r7, #14]
20001428:	f023 0308 	bic.w	r3, r3, #8
2000142c:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
2000142e:	683b      	ldr	r3, [r7, #0]
20001430:	895a      	ldrh	r2, [r3, #10]
20001432:	89fb      	ldrh	r3, [r7, #14]
20001434:	4313      	orrs	r3, r2
20001436:	81fb      	strh	r3, [r7, #14]
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
20001438:	89fb      	ldrh	r3, [r7, #14]
2000143a:	f023 0304 	bic.w	r3, r3, #4
2000143e:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
20001440:	683b      	ldr	r3, [r7, #0]
20001442:	889a      	ldrh	r2, [r3, #4]
20001444:	89fb      	ldrh	r3, [r7, #14]
20001446:	4313      	orrs	r3, r2
20001448:	81fb      	strh	r3, [r7, #14]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
2000144a:	89bb      	ldrh	r3, [r7, #12]
2000144c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20001450:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
20001452:	89bb      	ldrh	r3, [r7, #12]
20001454:	f423 7300 	bic.w	r3, r3, #512	; 0x200
20001458:	81bb      	strh	r3, [r7, #12]
    
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
2000145a:	683b      	ldr	r3, [r7, #0]
2000145c:	899a      	ldrh	r2, [r3, #12]
2000145e:	89bb      	ldrh	r3, [r7, #12]
20001460:	4313      	orrs	r3, r2
20001462:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
20001464:	683b      	ldr	r3, [r7, #0]
20001466:	89da      	ldrh	r2, [r3, #14]
20001468:	89bb      	ldrh	r3, [r7, #12]
2000146a:	4313      	orrs	r3, r2
2000146c:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2000146e:	687b      	ldr	r3, [r7, #4]
20001470:	89ba      	ldrh	r2, [r7, #12]
20001472:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
20001474:	687b      	ldr	r3, [r7, #4]
20001476:	897a      	ldrh	r2, [r7, #10]
20001478:	831a      	strh	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
2000147a:	683b      	ldr	r3, [r7, #0]
2000147c:	88da      	ldrh	r2, [r3, #6]
2000147e:	687b      	ldr	r3, [r7, #4]
20001480:	869a      	strh	r2, [r3, #52]	; 0x34
 
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
20001482:	687b      	ldr	r3, [r7, #4]
20001484:	89fa      	ldrh	r2, [r7, #14]
20001486:	841a      	strh	r2, [r3, #32]
}
20001488:	3714      	adds	r7, #20
2000148a:	46bd      	mov	sp, r7
2000148c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001490:	4770      	bx	lr
20001492:	bf00      	nop
20001494:	40012c00 	.word	0x40012c00
20001498:	40013400 	.word	0x40013400
2000149c:	40014000 	.word	0x40014000
200014a0:	40014400 	.word	0x40014400
200014a4:	40014800 	.word	0x40014800

200014a8 <TIM_OC2Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
200014a8:	b480      	push	{r7}
200014aa:	b085      	sub	sp, #20
200014ac:	af00      	add	r7, sp, #0
200014ae:	6078      	str	r0, [r7, #4]
200014b0:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
200014b2:	2300      	movs	r3, #0
200014b4:	817b      	strh	r3, [r7, #10]
200014b6:	2300      	movs	r3, #0
200014b8:	81fb      	strh	r3, [r7, #14]
200014ba:	2300      	movs	r3, #0
200014bc:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
   /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
200014be:	687b      	ldr	r3, [r7, #4]
200014c0:	8c1b      	ldrh	r3, [r3, #32]
200014c2:	b29b      	uxth	r3, r3
200014c4:	f023 0310 	bic.w	r3, r3, #16
200014c8:	b29a      	uxth	r2, r3
200014ca:	687b      	ldr	r3, [r7, #4]
200014cc:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
200014ce:	687b      	ldr	r3, [r7, #4]
200014d0:	8c1b      	ldrh	r3, [r3, #32]
200014d2:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
200014d4:	687b      	ldr	r3, [r7, #4]
200014d6:	889b      	ldrh	r3, [r3, #4]
200014d8:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
200014da:	687b      	ldr	r3, [r7, #4]
200014dc:	8b1b      	ldrh	r3, [r3, #24]
200014de:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
200014e0:	897b      	ldrh	r3, [r7, #10]
200014e2:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
200014e6:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
200014e8:	897b      	ldrh	r3, [r7, #10]
200014ea:	f423 7340 	bic.w	r3, r3, #768	; 0x300
200014ee:	817b      	strh	r3, [r7, #10]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
200014f0:	683b      	ldr	r3, [r7, #0]
200014f2:	881b      	ldrh	r3, [r3, #0]
200014f4:	021b      	lsls	r3, r3, #8
200014f6:	b29a      	uxth	r2, r3
200014f8:	897b      	ldrh	r3, [r7, #10]
200014fa:	4313      	orrs	r3, r2
200014fc:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
200014fe:	89fb      	ldrh	r3, [r7, #14]
20001500:	f023 0320 	bic.w	r3, r3, #32
20001504:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
20001506:	683b      	ldr	r3, [r7, #0]
20001508:	891b      	ldrh	r3, [r3, #8]
2000150a:	011b      	lsls	r3, r3, #4
2000150c:	b29a      	uxth	r2, r3
2000150e:	89fb      	ldrh	r3, [r7, #14]
20001510:	4313      	orrs	r3, r2
20001512:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
20001514:	683b      	ldr	r3, [r7, #0]
20001516:	885b      	ldrh	r3, [r3, #2]
20001518:	011b      	lsls	r3, r3, #4
2000151a:	b29a      	uxth	r2, r3
2000151c:	89fb      	ldrh	r3, [r7, #14]
2000151e:	4313      	orrs	r3, r2
20001520:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
20001522:	687a      	ldr	r2, [r7, #4]
20001524:	4b22      	ldr	r3, [pc, #136]	; (200015b0 <TIM_OC2Init+0x108>)
20001526:	429a      	cmp	r2, r3
20001528:	d003      	beq.n	20001532 <TIM_OC2Init+0x8a>
2000152a:	687a      	ldr	r2, [r7, #4]
2000152c:	4b21      	ldr	r3, [pc, #132]	; (200015b4 <TIM_OC2Init+0x10c>)
2000152e:	429a      	cmp	r2, r3
20001530:	d12b      	bne.n	2000158a <TIM_OC2Init+0xe2>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
20001532:	89fb      	ldrh	r3, [r7, #14]
20001534:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20001538:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
2000153a:	683b      	ldr	r3, [r7, #0]
2000153c:	895b      	ldrh	r3, [r3, #10]
2000153e:	011b      	lsls	r3, r3, #4
20001540:	b29a      	uxth	r2, r3
20001542:	89fb      	ldrh	r3, [r7, #14]
20001544:	4313      	orrs	r3, r2
20001546:	81fb      	strh	r3, [r7, #14]
    
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
20001548:	89fb      	ldrh	r3, [r7, #14]
2000154a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
2000154e:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
20001550:	683b      	ldr	r3, [r7, #0]
20001552:	889b      	ldrh	r3, [r3, #4]
20001554:	011b      	lsls	r3, r3, #4
20001556:	b29a      	uxth	r2, r3
20001558:	89fb      	ldrh	r3, [r7, #14]
2000155a:	4313      	orrs	r3, r2
2000155c:	81fb      	strh	r3, [r7, #14]
    
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
2000155e:	89bb      	ldrh	r3, [r7, #12]
20001560:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
20001564:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
20001566:	89bb      	ldrh	r3, [r7, #12]
20001568:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
2000156c:	81bb      	strh	r3, [r7, #12]
    
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
2000156e:	683b      	ldr	r3, [r7, #0]
20001570:	899b      	ldrh	r3, [r3, #12]
20001572:	009b      	lsls	r3, r3, #2
20001574:	b29a      	uxth	r2, r3
20001576:	89bb      	ldrh	r3, [r7, #12]
20001578:	4313      	orrs	r3, r2
2000157a:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
2000157c:	683b      	ldr	r3, [r7, #0]
2000157e:	89db      	ldrh	r3, [r3, #14]
20001580:	009b      	lsls	r3, r3, #2
20001582:	b29a      	uxth	r2, r3
20001584:	89bb      	ldrh	r3, [r7, #12]
20001586:	4313      	orrs	r3, r2
20001588:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
2000158a:	687b      	ldr	r3, [r7, #4]
2000158c:	89ba      	ldrh	r2, [r7, #12]
2000158e:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
20001590:	687b      	ldr	r3, [r7, #4]
20001592:	897a      	ldrh	r2, [r7, #10]
20001594:	831a      	strh	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
20001596:	683b      	ldr	r3, [r7, #0]
20001598:	88da      	ldrh	r2, [r3, #6]
2000159a:	687b      	ldr	r3, [r7, #4]
2000159c:	871a      	strh	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2000159e:	687b      	ldr	r3, [r7, #4]
200015a0:	89fa      	ldrh	r2, [r7, #14]
200015a2:	841a      	strh	r2, [r3, #32]
}
200015a4:	3714      	adds	r7, #20
200015a6:	46bd      	mov	sp, r7
200015a8:	f85d 7b04 	ldr.w	r7, [sp], #4
200015ac:	4770      	bx	lr
200015ae:	bf00      	nop
200015b0:	40012c00 	.word	0x40012c00
200015b4:	40013400 	.word	0x40013400

200015b8 <TIM_OC3Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
200015b8:	b480      	push	{r7}
200015ba:	b085      	sub	sp, #20
200015bc:	af00      	add	r7, sp, #0
200015be:	6078      	str	r0, [r7, #4]
200015c0:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
200015c2:	2300      	movs	r3, #0
200015c4:	817b      	strh	r3, [r7, #10]
200015c6:	2300      	movs	r3, #0
200015c8:	81fb      	strh	r3, [r7, #14]
200015ca:	2300      	movs	r3, #0
200015cc:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
200015ce:	687b      	ldr	r3, [r7, #4]
200015d0:	8c1b      	ldrh	r3, [r3, #32]
200015d2:	b29b      	uxth	r3, r3
200015d4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
200015d8:	b29a      	uxth	r2, r3
200015da:	687b      	ldr	r3, [r7, #4]
200015dc:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
200015de:	687b      	ldr	r3, [r7, #4]
200015e0:	8c1b      	ldrh	r3, [r3, #32]
200015e2:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
200015e4:	687b      	ldr	r3, [r7, #4]
200015e6:	889b      	ldrh	r3, [r3, #4]
200015e8:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
200015ea:	687b      	ldr	r3, [r7, #4]
200015ec:	8b9b      	ldrh	r3, [r3, #28]
200015ee:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
200015f0:	897b      	ldrh	r3, [r7, #10]
200015f2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
200015f6:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
200015f8:	897b      	ldrh	r3, [r7, #10]
200015fa:	f023 0303 	bic.w	r3, r3, #3
200015fe:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
20001600:	683b      	ldr	r3, [r7, #0]
20001602:	881a      	ldrh	r2, [r3, #0]
20001604:	897b      	ldrh	r3, [r7, #10]
20001606:	4313      	orrs	r3, r2
20001608:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
2000160a:	89fb      	ldrh	r3, [r7, #14]
2000160c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
20001610:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
20001612:	683b      	ldr	r3, [r7, #0]
20001614:	891b      	ldrh	r3, [r3, #8]
20001616:	021b      	lsls	r3, r3, #8
20001618:	b29a      	uxth	r2, r3
2000161a:	89fb      	ldrh	r3, [r7, #14]
2000161c:	4313      	orrs	r3, r2
2000161e:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
20001620:	683b      	ldr	r3, [r7, #0]
20001622:	885b      	ldrh	r3, [r3, #2]
20001624:	021b      	lsls	r3, r3, #8
20001626:	b29a      	uxth	r2, r3
20001628:	89fb      	ldrh	r3, [r7, #14]
2000162a:	4313      	orrs	r3, r2
2000162c:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
2000162e:	687a      	ldr	r2, [r7, #4]
20001630:	4b22      	ldr	r3, [pc, #136]	; (200016bc <TIM_OC3Init+0x104>)
20001632:	429a      	cmp	r2, r3
20001634:	d003      	beq.n	2000163e <TIM_OC3Init+0x86>
20001636:	687a      	ldr	r2, [r7, #4]
20001638:	4b21      	ldr	r3, [pc, #132]	; (200016c0 <TIM_OC3Init+0x108>)
2000163a:	429a      	cmp	r2, r3
2000163c:	d12b      	bne.n	20001696 <TIM_OC3Init+0xde>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
2000163e:	89fb      	ldrh	r3, [r7, #14]
20001640:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
20001644:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
20001646:	683b      	ldr	r3, [r7, #0]
20001648:	895b      	ldrh	r3, [r3, #10]
2000164a:	021b      	lsls	r3, r3, #8
2000164c:	b29a      	uxth	r2, r3
2000164e:	89fb      	ldrh	r3, [r7, #14]
20001650:	4313      	orrs	r3, r2
20001652:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
20001654:	89fb      	ldrh	r3, [r7, #14]
20001656:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
2000165a:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
2000165c:	683b      	ldr	r3, [r7, #0]
2000165e:	889b      	ldrh	r3, [r3, #4]
20001660:	021b      	lsls	r3, r3, #8
20001662:	b29a      	uxth	r2, r3
20001664:	89fb      	ldrh	r3, [r7, #14]
20001666:	4313      	orrs	r3, r2
20001668:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
2000166a:	89bb      	ldrh	r3, [r7, #12]
2000166c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
20001670:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
20001672:	89bb      	ldrh	r3, [r7, #12]
20001674:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
20001678:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
2000167a:	683b      	ldr	r3, [r7, #0]
2000167c:	899b      	ldrh	r3, [r3, #12]
2000167e:	011b      	lsls	r3, r3, #4
20001680:	b29a      	uxth	r2, r3
20001682:	89bb      	ldrh	r3, [r7, #12]
20001684:	4313      	orrs	r3, r2
20001686:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
20001688:	683b      	ldr	r3, [r7, #0]
2000168a:	89db      	ldrh	r3, [r3, #14]
2000168c:	011b      	lsls	r3, r3, #4
2000168e:	b29a      	uxth	r2, r3
20001690:	89bb      	ldrh	r3, [r7, #12]
20001692:	4313      	orrs	r3, r2
20001694:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
20001696:	687b      	ldr	r3, [r7, #4]
20001698:	89ba      	ldrh	r2, [r7, #12]
2000169a:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
2000169c:	687b      	ldr	r3, [r7, #4]
2000169e:	897a      	ldrh	r2, [r7, #10]
200016a0:	839a      	strh	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
200016a2:	683b      	ldr	r3, [r7, #0]
200016a4:	88da      	ldrh	r2, [r3, #6]
200016a6:	687b      	ldr	r3, [r7, #4]
200016a8:	879a      	strh	r2, [r3, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
200016aa:	687b      	ldr	r3, [r7, #4]
200016ac:	89fa      	ldrh	r2, [r7, #14]
200016ae:	841a      	strh	r2, [r3, #32]
}
200016b0:	3714      	adds	r7, #20
200016b2:	46bd      	mov	sp, r7
200016b4:	f85d 7b04 	ldr.w	r7, [sp], #4
200016b8:	4770      	bx	lr
200016ba:	bf00      	nop
200016bc:	40012c00 	.word	0x40012c00
200016c0:	40013400 	.word	0x40013400

200016c4 <TIM_OC4Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
200016c4:	b480      	push	{r7}
200016c6:	b085      	sub	sp, #20
200016c8:	af00      	add	r7, sp, #0
200016ca:	6078      	str	r0, [r7, #4]
200016cc:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
200016ce:	2300      	movs	r3, #0
200016d0:	81bb      	strh	r3, [r7, #12]
200016d2:	2300      	movs	r3, #0
200016d4:	817b      	strh	r3, [r7, #10]
200016d6:	2300      	movs	r3, #0
200016d8:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
  /* Disable the Channel 2: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
200016da:	687b      	ldr	r3, [r7, #4]
200016dc:	8c1b      	ldrh	r3, [r3, #32]
200016de:	b29b      	uxth	r3, r3
200016e0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
200016e4:	b29a      	uxth	r2, r3
200016e6:	687b      	ldr	r3, [r7, #4]
200016e8:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
200016ea:	687b      	ldr	r3, [r7, #4]
200016ec:	8c1b      	ldrh	r3, [r3, #32]
200016ee:	817b      	strh	r3, [r7, #10]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
200016f0:	687b      	ldr	r3, [r7, #4]
200016f2:	889b      	ldrh	r3, [r3, #4]
200016f4:	81fb      	strh	r3, [r7, #14]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
200016f6:	687b      	ldr	r3, [r7, #4]
200016f8:	8b9b      	ldrh	r3, [r3, #28]
200016fa:	81bb      	strh	r3, [r7, #12]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
200016fc:	89bb      	ldrh	r3, [r7, #12]
200016fe:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
20001702:	81bb      	strh	r3, [r7, #12]
  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
20001704:	89bb      	ldrh	r3, [r7, #12]
20001706:	f423 7340 	bic.w	r3, r3, #768	; 0x300
2000170a:	81bb      	strh	r3, [r7, #12]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
2000170c:	683b      	ldr	r3, [r7, #0]
2000170e:	881b      	ldrh	r3, [r3, #0]
20001710:	021b      	lsls	r3, r3, #8
20001712:	b29a      	uxth	r2, r3
20001714:	89bb      	ldrh	r3, [r7, #12]
20001716:	4313      	orrs	r3, r2
20001718:	81bb      	strh	r3, [r7, #12]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
2000171a:	897b      	ldrh	r3, [r7, #10]
2000171c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
20001720:	817b      	strh	r3, [r7, #10]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
20001722:	683b      	ldr	r3, [r7, #0]
20001724:	891b      	ldrh	r3, [r3, #8]
20001726:	031b      	lsls	r3, r3, #12
20001728:	b29a      	uxth	r2, r3
2000172a:	897b      	ldrh	r3, [r7, #10]
2000172c:	4313      	orrs	r3, r2
2000172e:	817b      	strh	r3, [r7, #10]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
20001730:	683b      	ldr	r3, [r7, #0]
20001732:	885b      	ldrh	r3, [r3, #2]
20001734:	031b      	lsls	r3, r3, #12
20001736:	b29a      	uxth	r2, r3
20001738:	897b      	ldrh	r3, [r7, #10]
2000173a:	4313      	orrs	r3, r2
2000173c:	817b      	strh	r3, [r7, #10]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
2000173e:	687a      	ldr	r2, [r7, #4]
20001740:	4b12      	ldr	r3, [pc, #72]	; (2000178c <TIM_OC4Init+0xc8>)
20001742:	429a      	cmp	r2, r3
20001744:	d003      	beq.n	2000174e <TIM_OC4Init+0x8a>
20001746:	687a      	ldr	r2, [r7, #4]
20001748:	4b11      	ldr	r3, [pc, #68]	; (20001790 <TIM_OC4Init+0xcc>)
2000174a:	429a      	cmp	r2, r3
2000174c:	d10a      	bne.n	20001764 <TIM_OC4Init+0xa0>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
2000174e:	89fb      	ldrh	r3, [r7, #14]
20001750:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
20001754:	81fb      	strh	r3, [r7, #14]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
20001756:	683b      	ldr	r3, [r7, #0]
20001758:	899b      	ldrh	r3, [r3, #12]
2000175a:	019b      	lsls	r3, r3, #6
2000175c:	b29a      	uxth	r2, r3
2000175e:	89fb      	ldrh	r3, [r7, #14]
20001760:	4313      	orrs	r3, r2
20001762:	81fb      	strh	r3, [r7, #14]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
20001764:	687b      	ldr	r3, [r7, #4]
20001766:	89fa      	ldrh	r2, [r7, #14]
20001768:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
2000176a:	687b      	ldr	r3, [r7, #4]
2000176c:	89ba      	ldrh	r2, [r7, #12]
2000176e:	839a      	strh	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
20001770:	683b      	ldr	r3, [r7, #0]
20001772:	88da      	ldrh	r2, [r3, #6]
20001774:	687b      	ldr	r3, [r7, #4]
20001776:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
2000177a:	687b      	ldr	r3, [r7, #4]
2000177c:	897a      	ldrh	r2, [r7, #10]
2000177e:	841a      	strh	r2, [r3, #32]
}
20001780:	3714      	adds	r7, #20
20001782:	46bd      	mov	sp, r7
20001784:	f85d 7b04 	ldr.w	r7, [sp], #4
20001788:	4770      	bx	lr
2000178a:	bf00      	nop
2000178c:	40012c00 	.word	0x40012c00
20001790:	40013400 	.word	0x40013400

20001794 <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
20001794:	b580      	push	{r7, lr}
20001796:	b082      	sub	sp, #8
20001798:	af00      	add	r7, sp, #0
2000179a:	6078      	str	r0, [r7, #4]
2000179c:	6039      	str	r1, [r7, #0]
  }
  else
  {
    assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
2000179e:	683b      	ldr	r3, [r7, #0]
200017a0:	881b      	ldrh	r3, [r3, #0]
200017a2:	2b00      	cmp	r3, #0
200017a4:	d10f      	bne.n	200017c6 <TIM_ICInit+0x32>
  {
    assert_param(IS_TIM_LIST8_PERIPH(TIMx));
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
200017a6:	683b      	ldr	r3, [r7, #0]
200017a8:	8859      	ldrh	r1, [r3, #2]
200017aa:	683b      	ldr	r3, [r7, #0]
200017ac:	889a      	ldrh	r2, [r3, #4]
200017ae:	683b      	ldr	r3, [r7, #0]
200017b0:	891b      	ldrh	r3, [r3, #8]
200017b2:	6878      	ldr	r0, [r7, #4]
200017b4:	f001 f966 	bl	20002a84 <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
200017b8:	683b      	ldr	r3, [r7, #0]
200017ba:	88db      	ldrh	r3, [r3, #6]
200017bc:	6878      	ldr	r0, [r7, #4]
200017be:	4619      	mov	r1, r3
200017c0:	f001 f816 	bl	200027f0 <TIM_SetIC1Prescaler>
200017c4:	e036      	b.n	20001834 <TIM_ICInit+0xa0>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
200017c6:	683b      	ldr	r3, [r7, #0]
200017c8:	881b      	ldrh	r3, [r3, #0]
200017ca:	2b04      	cmp	r3, #4
200017cc:	d10f      	bne.n	200017ee <TIM_ICInit+0x5a>
  {
    assert_param(IS_TIM_LIST6_PERIPH(TIMx));
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
200017ce:	683b      	ldr	r3, [r7, #0]
200017d0:	8859      	ldrh	r1, [r3, #2]
200017d2:	683b      	ldr	r3, [r7, #0]
200017d4:	889a      	ldrh	r2, [r3, #4]
200017d6:	683b      	ldr	r3, [r7, #0]
200017d8:	891b      	ldrh	r3, [r3, #8]
200017da:	6878      	ldr	r0, [r7, #4]
200017dc:	f001 f9bc 	bl	20002b58 <TI2_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
200017e0:	683b      	ldr	r3, [r7, #0]
200017e2:	88db      	ldrh	r3, [r3, #6]
200017e4:	6878      	ldr	r0, [r7, #4]
200017e6:	4619      	mov	r1, r3
200017e8:	f001 f81e 	bl	20002828 <TIM_SetIC2Prescaler>
200017ec:	e022      	b.n	20001834 <TIM_ICInit+0xa0>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
200017ee:	683b      	ldr	r3, [r7, #0]
200017f0:	881b      	ldrh	r3, [r3, #0]
200017f2:	2b08      	cmp	r3, #8
200017f4:	d10f      	bne.n	20001816 <TIM_ICInit+0x82>
  {
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
200017f6:	683b      	ldr	r3, [r7, #0]
200017f8:	8859      	ldrh	r1, [r3, #2]
200017fa:	683b      	ldr	r3, [r7, #0]
200017fc:	889a      	ldrh	r2, [r3, #4]
200017fe:	683b      	ldr	r3, [r7, #0]
20001800:	891b      	ldrh	r3, [r3, #8]
20001802:	6878      	ldr	r0, [r7, #4]
20001804:	f001 fa1c 	bl	20002c40 <TI3_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
20001808:	683b      	ldr	r3, [r7, #0]
2000180a:	88db      	ldrh	r3, [r3, #6]
2000180c:	6878      	ldr	r0, [r7, #4]
2000180e:	4619      	mov	r1, r3
20001810:	f001 f828 	bl	20002864 <TIM_SetIC3Prescaler>
20001814:	e00e      	b.n	20001834 <TIM_ICInit+0xa0>
  }
  else
  {
    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
20001816:	683b      	ldr	r3, [r7, #0]
20001818:	8859      	ldrh	r1, [r3, #2]
2000181a:	683b      	ldr	r3, [r7, #0]
2000181c:	889a      	ldrh	r2, [r3, #4]
2000181e:	683b      	ldr	r3, [r7, #0]
20001820:	891b      	ldrh	r3, [r3, #8]
20001822:	6878      	ldr	r0, [r7, #4]
20001824:	f001 fa7c 	bl	20002d20 <TI4_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
20001828:	683b      	ldr	r3, [r7, #0]
2000182a:	88db      	ldrh	r3, [r3, #6]
2000182c:	6878      	ldr	r0, [r7, #4]
2000182e:	4619      	mov	r1, r3
20001830:	f001 f834 	bl	2000289c <TIM_SetIC4Prescaler>
  }
}
20001834:	3708      	adds	r7, #8
20001836:	46bd      	mov	sp, r7
20001838:	bd80      	pop	{r7, pc}
2000183a:	bf00      	nop

2000183c <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
2000183c:	b580      	push	{r7, lr}
2000183e:	b084      	sub	sp, #16
20001840:	af00      	add	r7, sp, #0
20001842:	6078      	str	r0, [r7, #4]
20001844:	6039      	str	r1, [r7, #0]
  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
20001846:	2300      	movs	r3, #0
20001848:	81fb      	strh	r3, [r7, #14]
  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
2000184a:	2301      	movs	r3, #1
2000184c:	81bb      	strh	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
2000184e:	683b      	ldr	r3, [r7, #0]
20001850:	885b      	ldrh	r3, [r3, #2]
20001852:	2b00      	cmp	r3, #0
20001854:	d102      	bne.n	2000185c <TIM_PWMIConfig+0x20>
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
20001856:	2302      	movs	r3, #2
20001858:	81fb      	strh	r3, [r7, #14]
2000185a:	e001      	b.n	20001860 <TIM_PWMIConfig+0x24>
  }
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
2000185c:	2300      	movs	r3, #0
2000185e:	81fb      	strh	r3, [r7, #14]
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
20001860:	683b      	ldr	r3, [r7, #0]
20001862:	889b      	ldrh	r3, [r3, #4]
20001864:	2b01      	cmp	r3, #1
20001866:	d102      	bne.n	2000186e <TIM_PWMIConfig+0x32>
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
20001868:	2302      	movs	r3, #2
2000186a:	81bb      	strh	r3, [r7, #12]
2000186c:	e001      	b.n	20001872 <TIM_PWMIConfig+0x36>
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
2000186e:	2301      	movs	r3, #1
20001870:	81bb      	strh	r3, [r7, #12]
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
20001872:	683b      	ldr	r3, [r7, #0]
20001874:	881b      	ldrh	r3, [r3, #0]
20001876:	2b00      	cmp	r3, #0
20001878:	d11c      	bne.n	200018b4 <TIM_PWMIConfig+0x78>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
2000187a:	683b      	ldr	r3, [r7, #0]
2000187c:	8859      	ldrh	r1, [r3, #2]
2000187e:	683b      	ldr	r3, [r7, #0]
20001880:	889a      	ldrh	r2, [r3, #4]
20001882:	683b      	ldr	r3, [r7, #0]
20001884:	891b      	ldrh	r3, [r3, #8]
20001886:	6878      	ldr	r0, [r7, #4]
20001888:	f001 f8fc 	bl	20002a84 <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
2000188c:	683b      	ldr	r3, [r7, #0]
2000188e:	88db      	ldrh	r3, [r3, #6]
20001890:	6878      	ldr	r0, [r7, #4]
20001892:	4619      	mov	r1, r3
20001894:	f000 ffac 	bl	200027f0 <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
20001898:	683b      	ldr	r3, [r7, #0]
2000189a:	891b      	ldrh	r3, [r3, #8]
2000189c:	89f9      	ldrh	r1, [r7, #14]
2000189e:	89ba      	ldrh	r2, [r7, #12]
200018a0:	6878      	ldr	r0, [r7, #4]
200018a2:	f001 f959 	bl	20002b58 <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
200018a6:	683b      	ldr	r3, [r7, #0]
200018a8:	88db      	ldrh	r3, [r3, #6]
200018aa:	6878      	ldr	r0, [r7, #4]
200018ac:	4619      	mov	r1, r3
200018ae:	f000 ffbb 	bl	20002828 <TIM_SetIC2Prescaler>
200018b2:	e01b      	b.n	200018ec <TIM_PWMIConfig+0xb0>
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
200018b4:	683b      	ldr	r3, [r7, #0]
200018b6:	8859      	ldrh	r1, [r3, #2]
200018b8:	683b      	ldr	r3, [r7, #0]
200018ba:	889a      	ldrh	r2, [r3, #4]
200018bc:	683b      	ldr	r3, [r7, #0]
200018be:	891b      	ldrh	r3, [r3, #8]
200018c0:	6878      	ldr	r0, [r7, #4]
200018c2:	f001 f949 	bl	20002b58 <TI2_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
200018c6:	683b      	ldr	r3, [r7, #0]
200018c8:	88db      	ldrh	r3, [r3, #6]
200018ca:	6878      	ldr	r0, [r7, #4]
200018cc:	4619      	mov	r1, r3
200018ce:	f000 ffab 	bl	20002828 <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
200018d2:	683b      	ldr	r3, [r7, #0]
200018d4:	891b      	ldrh	r3, [r3, #8]
200018d6:	89f9      	ldrh	r1, [r7, #14]
200018d8:	89ba      	ldrh	r2, [r7, #12]
200018da:	6878      	ldr	r0, [r7, #4]
200018dc:	f001 f8d2 	bl	20002a84 <TI1_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
200018e0:	683b      	ldr	r3, [r7, #0]
200018e2:	88db      	ldrh	r3, [r3, #6]
200018e4:	6878      	ldr	r0, [r7, #4]
200018e6:	4619      	mov	r1, r3
200018e8:	f000 ff82 	bl	200027f0 <TIM_SetIC1Prescaler>
  }
}
200018ec:	3710      	adds	r7, #16
200018ee:	46bd      	mov	sp, r7
200018f0:	bd80      	pop	{r7, pc}
200018f2:	bf00      	nop

200018f4 <TIM_BDTRConfig>:
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval None
  */
void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
{
200018f4:	b480      	push	{r7}
200018f6:	b083      	sub	sp, #12
200018f8:	af00      	add	r7, sp, #0
200018fa:	6078      	str	r0, [r7, #4]
200018fc:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
200018fe:	683b      	ldr	r3, [r7, #0]
20001900:	881a      	ldrh	r2, [r3, #0]
20001902:	683b      	ldr	r3, [r7, #0]
20001904:	885b      	ldrh	r3, [r3, #2]
20001906:	4313      	orrs	r3, r2
20001908:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
2000190a:	683b      	ldr	r3, [r7, #0]
2000190c:	889b      	ldrh	r3, [r3, #4]
  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
2000190e:	4313      	orrs	r3, r2
20001910:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
20001912:	683b      	ldr	r3, [r7, #0]
20001914:	88db      	ldrh	r3, [r3, #6]
  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
20001916:	4313      	orrs	r3, r2
20001918:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
2000191a:	683b      	ldr	r3, [r7, #0]
2000191c:	891b      	ldrh	r3, [r3, #8]
  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
2000191e:	4313      	orrs	r3, r2
20001920:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
20001922:	683b      	ldr	r3, [r7, #0]
20001924:	895b      	ldrh	r3, [r3, #10]
  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
20001926:	4313      	orrs	r3, r2
20001928:	b29a      	uxth	r2, r3
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
2000192a:	683b      	ldr	r3, [r7, #0]
2000192c:	899b      	ldrh	r3, [r3, #12]
  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
2000192e:	4313      	orrs	r3, r2
20001930:	b29a      	uxth	r2, r3
20001932:	687b      	ldr	r3, [r7, #4]
20001934:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
}
20001938:	370c      	adds	r7, #12
2000193a:	46bd      	mov	sp, r7
2000193c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001940:	4770      	bx	lr
20001942:	bf00      	nop

20001944 <TIM_TimeBaseStructInit>:
  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
  *         structure which will be initialized.
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
20001944:	b480      	push	{r7}
20001946:	b083      	sub	sp, #12
20001948:	af00      	add	r7, sp, #0
2000194a:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
2000194c:	687b      	ldr	r3, [r7, #4]
2000194e:	f64f 72ff 	movw	r2, #65535	; 0xffff
20001952:	809a      	strh	r2, [r3, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
20001954:	687b      	ldr	r3, [r7, #4]
20001956:	2200      	movs	r2, #0
20001958:	801a      	strh	r2, [r3, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
2000195a:	687b      	ldr	r3, [r7, #4]
2000195c:	2200      	movs	r2, #0
2000195e:	80da      	strh	r2, [r3, #6]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
20001960:	687b      	ldr	r3, [r7, #4]
20001962:	2200      	movs	r2, #0
20001964:	805a      	strh	r2, [r3, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
20001966:	687b      	ldr	r3, [r7, #4]
20001968:	2200      	movs	r2, #0
2000196a:	721a      	strb	r2, [r3, #8]
}
2000196c:	370c      	adds	r7, #12
2000196e:	46bd      	mov	sp, r7
20001970:	f85d 7b04 	ldr.w	r7, [sp], #4
20001974:	4770      	bx	lr
20001976:	bf00      	nop

20001978 <TIM_OCStructInit>:
  * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
20001978:	b480      	push	{r7}
2000197a:	b083      	sub	sp, #12
2000197c:	af00      	add	r7, sp, #0
2000197e:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
20001980:	687b      	ldr	r3, [r7, #4]
20001982:	2200      	movs	r2, #0
20001984:	801a      	strh	r2, [r3, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
20001986:	687b      	ldr	r3, [r7, #4]
20001988:	2200      	movs	r2, #0
2000198a:	805a      	strh	r2, [r3, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
2000198c:	687b      	ldr	r3, [r7, #4]
2000198e:	2200      	movs	r2, #0
20001990:	809a      	strh	r2, [r3, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x0000;
20001992:	687b      	ldr	r3, [r7, #4]
20001994:	2200      	movs	r2, #0
20001996:	80da      	strh	r2, [r3, #6]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
20001998:	687b      	ldr	r3, [r7, #4]
2000199a:	2200      	movs	r2, #0
2000199c:	811a      	strh	r2, [r3, #8]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
2000199e:	687b      	ldr	r3, [r7, #4]
200019a0:	2200      	movs	r2, #0
200019a2:	815a      	strh	r2, [r3, #10]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
200019a4:	687b      	ldr	r3, [r7, #4]
200019a6:	2200      	movs	r2, #0
200019a8:	819a      	strh	r2, [r3, #12]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
200019aa:	687b      	ldr	r3, [r7, #4]
200019ac:	2200      	movs	r2, #0
200019ae:	81da      	strh	r2, [r3, #14]
}
200019b0:	370c      	adds	r7, #12
200019b2:	46bd      	mov	sp, r7
200019b4:	f85d 7b04 	ldr.w	r7, [sp], #4
200019b8:	4770      	bx	lr
200019ba:	bf00      	nop

200019bc <TIM_ICStructInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
  *         be initialized.
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
200019bc:	b480      	push	{r7}
200019be:	b083      	sub	sp, #12
200019c0:	af00      	add	r7, sp, #0
200019c2:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
200019c4:	687b      	ldr	r3, [r7, #4]
200019c6:	2200      	movs	r2, #0
200019c8:	801a      	strh	r2, [r3, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
200019ca:	687b      	ldr	r3, [r7, #4]
200019cc:	2200      	movs	r2, #0
200019ce:	805a      	strh	r2, [r3, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
200019d0:	687b      	ldr	r3, [r7, #4]
200019d2:	2201      	movs	r2, #1
200019d4:	809a      	strh	r2, [r3, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
200019d6:	687b      	ldr	r3, [r7, #4]
200019d8:	2200      	movs	r2, #0
200019da:	80da      	strh	r2, [r3, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
200019dc:	687b      	ldr	r3, [r7, #4]
200019de:	2200      	movs	r2, #0
200019e0:	811a      	strh	r2, [r3, #8]
}
200019e2:	370c      	adds	r7, #12
200019e4:	46bd      	mov	sp, r7
200019e6:	f85d 7b04 	ldr.w	r7, [sp], #4
200019ea:	4770      	bx	lr

200019ec <TIM_BDTRStructInit>:
  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
200019ec:	b480      	push	{r7}
200019ee:	b083      	sub	sp, #12
200019f0:	af00      	add	r7, sp, #0
200019f2:	6078      	str	r0, [r7, #4]
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
200019f4:	687b      	ldr	r3, [r7, #4]
200019f6:	2200      	movs	r2, #0
200019f8:	801a      	strh	r2, [r3, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
200019fa:	687b      	ldr	r3, [r7, #4]
200019fc:	2200      	movs	r2, #0
200019fe:	805a      	strh	r2, [r3, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
20001a00:	687b      	ldr	r3, [r7, #4]
20001a02:	2200      	movs	r2, #0
20001a04:	809a      	strh	r2, [r3, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
20001a06:	687b      	ldr	r3, [r7, #4]
20001a08:	2200      	movs	r2, #0
20001a0a:	80da      	strh	r2, [r3, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
20001a0c:	687b      	ldr	r3, [r7, #4]
20001a0e:	2200      	movs	r2, #0
20001a10:	811a      	strh	r2, [r3, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
20001a12:	687b      	ldr	r3, [r7, #4]
20001a14:	2200      	movs	r2, #0
20001a16:	815a      	strh	r2, [r3, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
20001a18:	687b      	ldr	r3, [r7, #4]
20001a1a:	2200      	movs	r2, #0
20001a1c:	819a      	strh	r2, [r3, #12]
}
20001a1e:	370c      	adds	r7, #12
20001a20:	46bd      	mov	sp, r7
20001a22:	f85d 7b04 	ldr.w	r7, [sp], #4
20001a26:	4770      	bx	lr

20001a28 <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
20001a28:	b480      	push	{r7}
20001a2a:	b083      	sub	sp, #12
20001a2c:	af00      	add	r7, sp, #0
20001a2e:	6078      	str	r0, [r7, #4]
20001a30:	460b      	mov	r3, r1
20001a32:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
20001a34:	78fb      	ldrb	r3, [r7, #3]
20001a36:	2b00      	cmp	r3, #0
20001a38:	d008      	beq.n	20001a4c <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
20001a3a:	687b      	ldr	r3, [r7, #4]
20001a3c:	881b      	ldrh	r3, [r3, #0]
20001a3e:	b29b      	uxth	r3, r3
20001a40:	f043 0301 	orr.w	r3, r3, #1
20001a44:	b29a      	uxth	r2, r3
20001a46:	687b      	ldr	r3, [r7, #4]
20001a48:	801a      	strh	r2, [r3, #0]
20001a4a:	e007      	b.n	20001a5c <TIM_Cmd+0x34>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
20001a4c:	687b      	ldr	r3, [r7, #4]
20001a4e:	881b      	ldrh	r3, [r3, #0]
20001a50:	b29b      	uxth	r3, r3
20001a52:	f023 0301 	bic.w	r3, r3, #1
20001a56:	b29a      	uxth	r2, r3
20001a58:	687b      	ldr	r3, [r7, #4]
20001a5a:	801a      	strh	r2, [r3, #0]
  }
}
20001a5c:	370c      	adds	r7, #12
20001a5e:	46bd      	mov	sp, r7
20001a60:	f85d 7b04 	ldr.w	r7, [sp], #4
20001a64:	4770      	bx	lr
20001a66:	bf00      	nop

20001a68 <TIM_CtrlPWMOutputs>:
  * @param  NewState: new state of the TIM peripheral Main Outputs.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
20001a68:	b480      	push	{r7}
20001a6a:	b083      	sub	sp, #12
20001a6c:	af00      	add	r7, sp, #0
20001a6e:	6078      	str	r0, [r7, #4]
20001a70:	460b      	mov	r3, r1
20001a72:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20001a74:	78fb      	ldrb	r3, [r7, #3]
20001a76:	2b00      	cmp	r3, #0
20001a78:	d00c      	beq.n	20001a94 <TIM_CtrlPWMOutputs+0x2c>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
20001a7a:	687b      	ldr	r3, [r7, #4]
20001a7c:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
20001a80:	b29b      	uxth	r3, r3
20001a82:	ea6f 4343 	mvn.w	r3, r3, lsl #17
20001a86:	ea6f 4353 	mvn.w	r3, r3, lsr #17
20001a8a:	b29a      	uxth	r2, r3
20001a8c:	687b      	ldr	r3, [r7, #4]
20001a8e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
20001a92:	e009      	b.n	20001aa8 <TIM_CtrlPWMOutputs+0x40>
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
20001a94:	687b      	ldr	r3, [r7, #4]
20001a96:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
20001a9a:	b29b      	uxth	r3, r3
20001a9c:	f3c3 030e 	ubfx	r3, r3, #0, #15
20001aa0:	b29a      	uxth	r2, r3
20001aa2:	687b      	ldr	r3, [r7, #4]
20001aa4:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  }  
}
20001aa8:	370c      	adds	r7, #12
20001aaa:	46bd      	mov	sp, r7
20001aac:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ab0:	4770      	bx	lr
20001ab2:	bf00      	nop

20001ab4 <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
20001ab4:	b480      	push	{r7}
20001ab6:	b083      	sub	sp, #12
20001ab8:	af00      	add	r7, sp, #0
20001aba:	6078      	str	r0, [r7, #4]
20001abc:	4613      	mov	r3, r2
20001abe:	460a      	mov	r2, r1
20001ac0:	807a      	strh	r2, [r7, #2]
20001ac2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
20001ac4:	787b      	ldrb	r3, [r7, #1]
20001ac6:	2b00      	cmp	r3, #0
20001ac8:	d008      	beq.n	20001adc <TIM_ITConfig+0x28>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
20001aca:	687b      	ldr	r3, [r7, #4]
20001acc:	899b      	ldrh	r3, [r3, #12]
20001ace:	b29a      	uxth	r2, r3
20001ad0:	887b      	ldrh	r3, [r7, #2]
20001ad2:	4313      	orrs	r3, r2
20001ad4:	b29a      	uxth	r2, r3
20001ad6:	687b      	ldr	r3, [r7, #4]
20001ad8:	819a      	strh	r2, [r3, #12]
20001ada:	e009      	b.n	20001af0 <TIM_ITConfig+0x3c>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
20001adc:	687b      	ldr	r3, [r7, #4]
20001ade:	899b      	ldrh	r3, [r3, #12]
20001ae0:	b29a      	uxth	r2, r3
20001ae2:	887b      	ldrh	r3, [r7, #2]
20001ae4:	43db      	mvns	r3, r3
20001ae6:	b29b      	uxth	r3, r3
20001ae8:	4013      	ands	r3, r2
20001aea:	b29a      	uxth	r2, r3
20001aec:	687b      	ldr	r3, [r7, #4]
20001aee:	819a      	strh	r2, [r3, #12]
  }
}
20001af0:	370c      	adds	r7, #12
20001af2:	46bd      	mov	sp, r7
20001af4:	f85d 7b04 	ldr.w	r7, [sp], #4
20001af8:	4770      	bx	lr
20001afa:	bf00      	nop

20001afc <TIM_GenerateEvent>:
  *   - TIM6 and TIM7 can only generate an update event. 
  *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.      
  * @retval None
  */
void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
{ 
20001afc:	b480      	push	{r7}
20001afe:	b083      	sub	sp, #12
20001b00:	af00      	add	r7, sp, #0
20001b02:	6078      	str	r0, [r7, #4]
20001b04:	460b      	mov	r3, r1
20001b06:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
  
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
20001b08:	687b      	ldr	r3, [r7, #4]
20001b0a:	887a      	ldrh	r2, [r7, #2]
20001b0c:	829a      	strh	r2, [r3, #20]
}
20001b0e:	370c      	adds	r7, #12
20001b10:	46bd      	mov	sp, r7
20001b12:	f85d 7b04 	ldr.w	r7, [sp], #4
20001b16:	4770      	bx	lr

20001b18 <TIM_DMAConfig>:
  *   This parameter can be one value between:
  *   TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
  * @retval None
  */
void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
{
20001b18:	b480      	push	{r7}
20001b1a:	b083      	sub	sp, #12
20001b1c:	af00      	add	r7, sp, #0
20001b1e:	6078      	str	r0, [r7, #4]
20001b20:	4613      	mov	r3, r2
20001b22:	460a      	mov	r2, r1
20001b24:	807a      	strh	r2, [r7, #2]
20001b26:	803b      	strh	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
20001b28:	887a      	ldrh	r2, [r7, #2]
20001b2a:	883b      	ldrh	r3, [r7, #0]
20001b2c:	4313      	orrs	r3, r2
20001b2e:	b29a      	uxth	r2, r3
20001b30:	687b      	ldr	r3, [r7, #4]
20001b32:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
}
20001b36:	370c      	adds	r7, #12
20001b38:	46bd      	mov	sp, r7
20001b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
20001b3e:	4770      	bx	lr

20001b40 <TIM_DMACmd>:
  * @param  NewState: new state of the DMA Request sources.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
{ 
20001b40:	b480      	push	{r7}
20001b42:	b083      	sub	sp, #12
20001b44:	af00      	add	r7, sp, #0
20001b46:	6078      	str	r0, [r7, #4]
20001b48:	4613      	mov	r3, r2
20001b4a:	460a      	mov	r2, r1
20001b4c:	807a      	strh	r2, [r7, #2]
20001b4e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_LIST9_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
20001b50:	787b      	ldrb	r3, [r7, #1]
20001b52:	2b00      	cmp	r3, #0
20001b54:	d008      	beq.n	20001b68 <TIM_DMACmd+0x28>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
20001b56:	687b      	ldr	r3, [r7, #4]
20001b58:	899b      	ldrh	r3, [r3, #12]
20001b5a:	b29a      	uxth	r2, r3
20001b5c:	887b      	ldrh	r3, [r7, #2]
20001b5e:	4313      	orrs	r3, r2
20001b60:	b29a      	uxth	r2, r3
20001b62:	687b      	ldr	r3, [r7, #4]
20001b64:	819a      	strh	r2, [r3, #12]
20001b66:	e009      	b.n	20001b7c <TIM_DMACmd+0x3c>
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
20001b68:	687b      	ldr	r3, [r7, #4]
20001b6a:	899b      	ldrh	r3, [r3, #12]
20001b6c:	b29a      	uxth	r2, r3
20001b6e:	887b      	ldrh	r3, [r7, #2]
20001b70:	43db      	mvns	r3, r3
20001b72:	b29b      	uxth	r3, r3
20001b74:	4013      	ands	r3, r2
20001b76:	b29a      	uxth	r2, r3
20001b78:	687b      	ldr	r3, [r7, #4]
20001b7a:	819a      	strh	r2, [r3, #12]
  }
}
20001b7c:	370c      	adds	r7, #12
20001b7e:	46bd      	mov	sp, r7
20001b80:	f85d 7b04 	ldr.w	r7, [sp], #4
20001b84:	4770      	bx	lr
20001b86:	bf00      	nop

20001b88 <TIM_InternalClockConfig>:
  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15
  *         to select the TIM peripheral.
  * @retval None
  */
void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
{
20001b88:	b480      	push	{r7}
20001b8a:	b083      	sub	sp, #12
20001b8c:	af00      	add	r7, sp, #0
20001b8e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
20001b90:	687b      	ldr	r3, [r7, #4]
20001b92:	891b      	ldrh	r3, [r3, #8]
20001b94:	b29b      	uxth	r3, r3
20001b96:	f023 0307 	bic.w	r3, r3, #7
20001b9a:	b29a      	uxth	r2, r3
20001b9c:	687b      	ldr	r3, [r7, #4]
20001b9e:	811a      	strh	r2, [r3, #8]
}
20001ba0:	370c      	adds	r7, #12
20001ba2:	46bd      	mov	sp, r7
20001ba4:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ba8:	4770      	bx	lr
20001baa:	bf00      	nop

20001bac <TIM_ITRxExternalClockConfig>:
  * @param  TIM_TS_ITR2: Internal Trigger 2
  * @param  TIM_TS_ITR3: Internal Trigger 3
  * @retval None
  */
void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
{
20001bac:	b580      	push	{r7, lr}
20001bae:	b082      	sub	sp, #8
20001bb0:	af00      	add	r7, sp, #0
20001bb2:	6078      	str	r0, [r7, #4]
20001bb4:	460b      	mov	r3, r1
20001bb6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
20001bb8:	887b      	ldrh	r3, [r7, #2]
20001bba:	6878      	ldr	r0, [r7, #4]
20001bbc:	4619      	mov	r1, r3
20001bbe:	f000 f8c9 	bl	20001d54 <TIM_SelectInputTrigger>
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
20001bc2:	687b      	ldr	r3, [r7, #4]
20001bc4:	891b      	ldrh	r3, [r3, #8]
20001bc6:	b29b      	uxth	r3, r3
20001bc8:	f043 0307 	orr.w	r3, r3, #7
20001bcc:	b29a      	uxth	r2, r3
20001bce:	687b      	ldr	r3, [r7, #4]
20001bd0:	811a      	strh	r2, [r3, #8]
}
20001bd2:	3708      	adds	r7, #8
20001bd4:	46bd      	mov	sp, r7
20001bd6:	bd80      	pop	{r7, pc}

20001bd8 <TIM_TIxExternalClockConfig>:
  *   This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
20001bd8:	b580      	push	{r7, lr}
20001bda:	b084      	sub	sp, #16
20001bdc:	af00      	add	r7, sp, #0
20001bde:	60f8      	str	r0, [r7, #12]
20001be0:	8179      	strh	r1, [r7, #10]
20001be2:	813a      	strh	r2, [r7, #8]
20001be4:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));
  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
20001be6:	897b      	ldrh	r3, [r7, #10]
20001be8:	2b60      	cmp	r3, #96	; 0x60
20001bea:	d107      	bne.n	20001bfc <TIM_TIxExternalClockConfig+0x24>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
20001bec:	893a      	ldrh	r2, [r7, #8]
20001bee:	88fb      	ldrh	r3, [r7, #6]
20001bf0:	68f8      	ldr	r0, [r7, #12]
20001bf2:	4611      	mov	r1, r2
20001bf4:	2201      	movs	r2, #1
20001bf6:	f000 ffaf 	bl	20002b58 <TI2_Config>
20001bfa:	e006      	b.n	20001c0a <TIM_TIxExternalClockConfig+0x32>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
20001bfc:	893a      	ldrh	r2, [r7, #8]
20001bfe:	88fb      	ldrh	r3, [r7, #6]
20001c00:	68f8      	ldr	r0, [r7, #12]
20001c02:	4611      	mov	r1, r2
20001c04:	2201      	movs	r2, #1
20001c06:	f000 ff3d 	bl	20002a84 <TI1_Config>
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
20001c0a:	897b      	ldrh	r3, [r7, #10]
20001c0c:	68f8      	ldr	r0, [r7, #12]
20001c0e:	4619      	mov	r1, r3
20001c10:	f000 f8a0 	bl	20001d54 <TIM_SelectInputTrigger>
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
20001c14:	68fb      	ldr	r3, [r7, #12]
20001c16:	891b      	ldrh	r3, [r3, #8]
20001c18:	b29b      	uxth	r3, r3
20001c1a:	f043 0307 	orr.w	r3, r3, #7
20001c1e:	b29a      	uxth	r2, r3
20001c20:	68fb      	ldr	r3, [r7, #12]
20001c22:	811a      	strh	r2, [r3, #8]
}
20001c24:	3710      	adds	r7, #16
20001c26:	46bd      	mov	sp, r7
20001c28:	bd80      	pop	{r7, pc}
20001c2a:	bf00      	nop

20001c2c <TIM_ETRClockMode1Config>:
  *   This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
                             uint16_t ExtTRGFilter)
{
20001c2c:	b580      	push	{r7, lr}
20001c2e:	b086      	sub	sp, #24
20001c30:	af00      	add	r7, sp, #0
20001c32:	60f8      	str	r0, [r7, #12]
20001c34:	8179      	strh	r1, [r7, #10]
20001c36:	813a      	strh	r2, [r7, #8]
20001c38:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
20001c3a:	2300      	movs	r3, #0
20001c3c:	82fb      	strh	r3, [r7, #22]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
20001c3e:	8979      	ldrh	r1, [r7, #10]
20001c40:	893a      	ldrh	r2, [r7, #8]
20001c42:	88fb      	ldrh	r3, [r7, #6]
20001c44:	68f8      	ldr	r0, [r7, #12]
20001c46:	f000 f831 	bl	20001cac <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
20001c4a:	68fb      	ldr	r3, [r7, #12]
20001c4c:	891b      	ldrh	r3, [r3, #8]
20001c4e:	82fb      	strh	r3, [r7, #22]
  /* Reset the SMS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
20001c50:	8afb      	ldrh	r3, [r7, #22]
20001c52:	f023 0307 	bic.w	r3, r3, #7
20001c56:	82fb      	strh	r3, [r7, #22]
  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;
20001c58:	8afb      	ldrh	r3, [r7, #22]
20001c5a:	f043 0307 	orr.w	r3, r3, #7
20001c5e:	82fb      	strh	r3, [r7, #22]
  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
20001c60:	8afb      	ldrh	r3, [r7, #22]
20001c62:	f023 0370 	bic.w	r3, r3, #112	; 0x70
20001c66:	82fb      	strh	r3, [r7, #22]
  tmpsmcr |= TIM_TS_ETRF;
20001c68:	8afb      	ldrh	r3, [r7, #22]
20001c6a:	f043 0370 	orr.w	r3, r3, #112	; 0x70
20001c6e:	82fb      	strh	r3, [r7, #22]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
20001c70:	68fb      	ldr	r3, [r7, #12]
20001c72:	8afa      	ldrh	r2, [r7, #22]
20001c74:	811a      	strh	r2, [r3, #8]
}
20001c76:	3718      	adds	r7, #24
20001c78:	46bd      	mov	sp, r7
20001c7a:	bd80      	pop	{r7, pc}

20001c7c <TIM_ETRClockMode2Config>:
  *   This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
20001c7c:	b580      	push	{r7, lr}
20001c7e:	b084      	sub	sp, #16
20001c80:	af00      	add	r7, sp, #0
20001c82:	60f8      	str	r0, [r7, #12]
20001c84:	8179      	strh	r1, [r7, #10]
20001c86:	813a      	strh	r2, [r7, #8]
20001c88:	80fb      	strh	r3, [r7, #6]
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
20001c8a:	8979      	ldrh	r1, [r7, #10]
20001c8c:	893a      	ldrh	r2, [r7, #8]
20001c8e:	88fb      	ldrh	r3, [r7, #6]
20001c90:	68f8      	ldr	r0, [r7, #12]
20001c92:	f000 f80b 	bl	20001cac <TIM_ETRConfig>
  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
20001c96:	68fb      	ldr	r3, [r7, #12]
20001c98:	891b      	ldrh	r3, [r3, #8]
20001c9a:	b29b      	uxth	r3, r3
20001c9c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
20001ca0:	b29a      	uxth	r2, r3
20001ca2:	68fb      	ldr	r3, [r7, #12]
20001ca4:	811a      	strh	r2, [r3, #8]
}
20001ca6:	3710      	adds	r7, #16
20001ca8:	46bd      	mov	sp, r7
20001caa:	bd80      	pop	{r7, pc}

20001cac <TIM_ETRConfig>:
  *   This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
                   uint16_t ExtTRGFilter)
{
20001cac:	b480      	push	{r7}
20001cae:	b087      	sub	sp, #28
20001cb0:	af00      	add	r7, sp, #0
20001cb2:	60f8      	str	r0, [r7, #12]
20001cb4:	8179      	strh	r1, [r7, #10]
20001cb6:	813a      	strh	r2, [r7, #8]
20001cb8:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
20001cba:	2300      	movs	r3, #0
20001cbc:	82fb      	strh	r3, [r7, #22]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  tmpsmcr = TIMx->SMCR;
20001cbe:	68fb      	ldr	r3, [r7, #12]
20001cc0:	891b      	ldrh	r3, [r3, #8]
20001cc2:	82fb      	strh	r3, [r7, #22]
  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_Mask;
20001cc4:	8afb      	ldrh	r3, [r7, #22]
20001cc6:	b2db      	uxtb	r3, r3
20001cc8:	82fb      	strh	r3, [r7, #22]
  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
20001cca:	88fb      	ldrh	r3, [r7, #6]
20001ccc:	021b      	lsls	r3, r3, #8
20001cce:	b29a      	uxth	r2, r3
20001cd0:	893b      	ldrh	r3, [r7, #8]
20001cd2:	4313      	orrs	r3, r2
20001cd4:	b29a      	uxth	r2, r3
20001cd6:	897b      	ldrh	r3, [r7, #10]
20001cd8:	4313      	orrs	r3, r2
20001cda:	b29a      	uxth	r2, r3
20001cdc:	8afb      	ldrh	r3, [r7, #22]
20001cde:	4313      	orrs	r3, r2
20001ce0:	82fb      	strh	r3, [r7, #22]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
20001ce2:	68fb      	ldr	r3, [r7, #12]
20001ce4:	8afa      	ldrh	r2, [r7, #22]
20001ce6:	811a      	strh	r2, [r3, #8]
}
20001ce8:	371c      	adds	r7, #28
20001cea:	46bd      	mov	sp, r7
20001cec:	f85d 7b04 	ldr.w	r7, [sp], #4
20001cf0:	4770      	bx	lr
20001cf2:	bf00      	nop

20001cf4 <TIM_PrescalerConfig>:
  *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
  *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately.
  * @retval None
  */
void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
{
20001cf4:	b480      	push	{r7}
20001cf6:	b083      	sub	sp, #12
20001cf8:	af00      	add	r7, sp, #0
20001cfa:	6078      	str	r0, [r7, #4]
20001cfc:	4613      	mov	r3, r2
20001cfe:	460a      	mov	r2, r1
20001d00:	807a      	strh	r2, [r7, #2]
20001d02:	803b      	strh	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
20001d04:	687b      	ldr	r3, [r7, #4]
20001d06:	887a      	ldrh	r2, [r7, #2]
20001d08:	851a      	strh	r2, [r3, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
20001d0a:	687b      	ldr	r3, [r7, #4]
20001d0c:	883a      	ldrh	r2, [r7, #0]
20001d0e:	829a      	strh	r2, [r3, #20]
}
20001d10:	370c      	adds	r7, #12
20001d12:	46bd      	mov	sp, r7
20001d14:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d18:	4770      	bx	lr
20001d1a:	bf00      	nop

20001d1c <TIM_CounterModeConfig>:
  *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
  *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
  * @retval None
  */
void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
{
20001d1c:	b480      	push	{r7}
20001d1e:	b085      	sub	sp, #20
20001d20:	af00      	add	r7, sp, #0
20001d22:	6078      	str	r0, [r7, #4]
20001d24:	460b      	mov	r3, r1
20001d26:	807b      	strh	r3, [r7, #2]
  uint16_t tmpcr1 = 0;
20001d28:	2300      	movs	r3, #0
20001d2a:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
  tmpcr1 = TIMx->CR1;
20001d2c:	687b      	ldr	r3, [r7, #4]
20001d2e:	881b      	ldrh	r3, [r3, #0]
20001d30:	81fb      	strh	r3, [r7, #14]
  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
20001d32:	89fb      	ldrh	r3, [r7, #14]
20001d34:	f023 0370 	bic.w	r3, r3, #112	; 0x70
20001d38:	81fb      	strh	r3, [r7, #14]
  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
20001d3a:	89fa      	ldrh	r2, [r7, #14]
20001d3c:	887b      	ldrh	r3, [r7, #2]
20001d3e:	4313      	orrs	r3, r2
20001d40:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
20001d42:	687b      	ldr	r3, [r7, #4]
20001d44:	89fa      	ldrh	r2, [r7, #14]
20001d46:	801a      	strh	r2, [r3, #0]
}
20001d48:	3714      	adds	r7, #20
20001d4a:	46bd      	mov	sp, r7
20001d4c:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d50:	4770      	bx	lr
20001d52:	bf00      	nop

20001d54 <TIM_SelectInputTrigger>:
  *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *     @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
{
20001d54:	b480      	push	{r7}
20001d56:	b085      	sub	sp, #20
20001d58:	af00      	add	r7, sp, #0
20001d5a:	6078      	str	r0, [r7, #4]
20001d5c:	460b      	mov	r3, r1
20001d5e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpsmcr = 0;
20001d60:	2300      	movs	r3, #0
20001d62:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
20001d64:	687b      	ldr	r3, [r7, #4]
20001d66:	891b      	ldrh	r3, [r3, #8]
20001d68:	81fb      	strh	r3, [r7, #14]
  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
20001d6a:	89fb      	ldrh	r3, [r7, #14]
20001d6c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
20001d70:	81fb      	strh	r3, [r7, #14]
  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;
20001d72:	89fa      	ldrh	r2, [r7, #14]
20001d74:	887b      	ldrh	r3, [r7, #2]
20001d76:	4313      	orrs	r3, r2
20001d78:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
20001d7a:	687b      	ldr	r3, [r7, #4]
20001d7c:	89fa      	ldrh	r2, [r7, #14]
20001d7e:	811a      	strh	r2, [r3, #8]
}
20001d80:	3714      	adds	r7, #20
20001d82:	46bd      	mov	sp, r7
20001d84:	f85d 7b04 	ldr.w	r7, [sp], #4
20001d88:	4770      	bx	lr
20001d8a:	bf00      	nop

20001d8c <TIM_EncoderInterfaceConfig>:
  *     @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
20001d8c:	b480      	push	{r7}
20001d8e:	b087      	sub	sp, #28
20001d90:	af00      	add	r7, sp, #0
20001d92:	60f8      	str	r0, [r7, #12]
20001d94:	8179      	strh	r1, [r7, #10]
20001d96:	813a      	strh	r2, [r7, #8]
20001d98:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpsmcr = 0;
20001d9a:	2300      	movs	r3, #0
20001d9c:	82fb      	strh	r3, [r7, #22]
  uint16_t tmpccmr1 = 0;
20001d9e:	2300      	movs	r3, #0
20001da0:	82bb      	strh	r3, [r7, #20]
  uint16_t tmpccer = 0;
20001da2:	2300      	movs	r3, #0
20001da4:	827b      	strh	r3, [r7, #18]
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
20001da6:	68fb      	ldr	r3, [r7, #12]
20001da8:	891b      	ldrh	r3, [r3, #8]
20001daa:	82fb      	strh	r3, [r7, #22]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
20001dac:	68fb      	ldr	r3, [r7, #12]
20001dae:	8b1b      	ldrh	r3, [r3, #24]
20001db0:	82bb      	strh	r3, [r7, #20]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
20001db2:	68fb      	ldr	r3, [r7, #12]
20001db4:	8c1b      	ldrh	r3, [r3, #32]
20001db6:	827b      	strh	r3, [r7, #18]
  
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
20001db8:	8afb      	ldrh	r3, [r7, #22]
20001dba:	f023 0307 	bic.w	r3, r3, #7
20001dbe:	82fb      	strh	r3, [r7, #22]
  tmpsmcr |= TIM_EncoderMode;
20001dc0:	8afa      	ldrh	r2, [r7, #22]
20001dc2:	897b      	ldrh	r3, [r7, #10]
20001dc4:	4313      	orrs	r3, r2
20001dc6:	82fb      	strh	r3, [r7, #22]
  
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
20001dc8:	8abb      	ldrh	r3, [r7, #20]
20001dca:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20001dce:	f023 0303 	bic.w	r3, r3, #3
20001dd2:	82bb      	strh	r3, [r7, #20]
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
20001dd4:	8abb      	ldrh	r3, [r7, #20]
20001dd6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20001dda:	f043 0301 	orr.w	r3, r3, #1
20001dde:	82bb      	strh	r3, [r7, #20]
  
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
20001de0:	8a7b      	ldrh	r3, [r7, #18]
20001de2:	f023 0322 	bic.w	r3, r3, #34	; 0x22
20001de6:	827b      	strh	r3, [r7, #18]
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
20001de8:	88fb      	ldrh	r3, [r7, #6]
20001dea:	011b      	lsls	r3, r3, #4
20001dec:	b29a      	uxth	r2, r3
20001dee:	893b      	ldrh	r3, [r7, #8]
20001df0:	4313      	orrs	r3, r2
20001df2:	b29a      	uxth	r2, r3
20001df4:	8a7b      	ldrh	r3, [r7, #18]
20001df6:	4313      	orrs	r3, r2
20001df8:	827b      	strh	r3, [r7, #18]
  
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
20001dfa:	68fb      	ldr	r3, [r7, #12]
20001dfc:	8afa      	ldrh	r2, [r7, #22]
20001dfe:	811a      	strh	r2, [r3, #8]
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
20001e00:	68fb      	ldr	r3, [r7, #12]
20001e02:	8aba      	ldrh	r2, [r7, #20]
20001e04:	831a      	strh	r2, [r3, #24]
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
20001e06:	68fb      	ldr	r3, [r7, #12]
20001e08:	8a7a      	ldrh	r2, [r7, #18]
20001e0a:	841a      	strh	r2, [r3, #32]
}
20001e0c:	371c      	adds	r7, #28
20001e0e:	46bd      	mov	sp, r7
20001e10:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e14:	4770      	bx	lr
20001e16:	bf00      	nop

20001e18 <TIM_ForcedOC1Config>:
  *     @arg TIM_ForcedAction_Active: Force active level on OC1REF
  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
  * @retval None
  */
void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
20001e18:	b480      	push	{r7}
20001e1a:	b085      	sub	sp, #20
20001e1c:	af00      	add	r7, sp, #0
20001e1e:	6078      	str	r0, [r7, #4]
20001e20:	460b      	mov	r3, r1
20001e22:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
20001e24:	2300      	movs	r3, #0
20001e26:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
20001e28:	687b      	ldr	r3, [r7, #4]
20001e2a:	8b1b      	ldrh	r3, [r3, #24]
20001e2c:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
20001e2e:	89fb      	ldrh	r3, [r7, #14]
20001e30:	f023 0370 	bic.w	r3, r3, #112	; 0x70
20001e34:	81fb      	strh	r3, [r7, #14]
  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
20001e36:	89fa      	ldrh	r2, [r7, #14]
20001e38:	887b      	ldrh	r3, [r7, #2]
20001e3a:	4313      	orrs	r3, r2
20001e3c:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
20001e3e:	687b      	ldr	r3, [r7, #4]
20001e40:	89fa      	ldrh	r2, [r7, #14]
20001e42:	831a      	strh	r2, [r3, #24]
}
20001e44:	3714      	adds	r7, #20
20001e46:	46bd      	mov	sp, r7
20001e48:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e4c:	4770      	bx	lr
20001e4e:	bf00      	nop

20001e50 <TIM_ForcedOC2Config>:
  *     @arg TIM_ForcedAction_Active: Force active level on OC2REF
  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
  * @retval None
  */
void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
20001e50:	b480      	push	{r7}
20001e52:	b085      	sub	sp, #20
20001e54:	af00      	add	r7, sp, #0
20001e56:	6078      	str	r0, [r7, #4]
20001e58:	460b      	mov	r3, r1
20001e5a:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
20001e5c:	2300      	movs	r3, #0
20001e5e:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
20001e60:	687b      	ldr	r3, [r7, #4]
20001e62:	8b1b      	ldrh	r3, [r3, #24]
20001e64:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
20001e66:	89fb      	ldrh	r3, [r7, #14]
20001e68:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
20001e6c:	81fb      	strh	r3, [r7, #14]
  /* Configure The Forced output Mode */
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
20001e6e:	887b      	ldrh	r3, [r7, #2]
20001e70:	021b      	lsls	r3, r3, #8
20001e72:	b29a      	uxth	r2, r3
20001e74:	89fb      	ldrh	r3, [r7, #14]
20001e76:	4313      	orrs	r3, r2
20001e78:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
20001e7a:	687b      	ldr	r3, [r7, #4]
20001e7c:	89fa      	ldrh	r2, [r7, #14]
20001e7e:	831a      	strh	r2, [r3, #24]
}
20001e80:	3714      	adds	r7, #20
20001e82:	46bd      	mov	sp, r7
20001e84:	f85d 7b04 	ldr.w	r7, [sp], #4
20001e88:	4770      	bx	lr
20001e8a:	bf00      	nop

20001e8c <TIM_ForcedOC3Config>:
  *     @arg TIM_ForcedAction_Active: Force active level on OC3REF
  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
  * @retval None
  */
void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
20001e8c:	b480      	push	{r7}
20001e8e:	b085      	sub	sp, #20
20001e90:	af00      	add	r7, sp, #0
20001e92:	6078      	str	r0, [r7, #4]
20001e94:	460b      	mov	r3, r1
20001e96:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
20001e98:	2300      	movs	r3, #0
20001e9a:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
20001e9c:	687b      	ldr	r3, [r7, #4]
20001e9e:	8b9b      	ldrh	r3, [r3, #28]
20001ea0:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
20001ea2:	89fb      	ldrh	r3, [r7, #14]
20001ea4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
20001ea8:	81fb      	strh	r3, [r7, #14]
  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
20001eaa:	89fa      	ldrh	r2, [r7, #14]
20001eac:	887b      	ldrh	r3, [r7, #2]
20001eae:	4313      	orrs	r3, r2
20001eb0:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
20001eb2:	687b      	ldr	r3, [r7, #4]
20001eb4:	89fa      	ldrh	r2, [r7, #14]
20001eb6:	839a      	strh	r2, [r3, #28]
}
20001eb8:	3714      	adds	r7, #20
20001eba:	46bd      	mov	sp, r7
20001ebc:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ec0:	4770      	bx	lr
20001ec2:	bf00      	nop

20001ec4 <TIM_ForcedOC4Config>:
  *     @arg TIM_ForcedAction_Active: Force active level on OC4REF
  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
  * @retval None
  */
void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
{
20001ec4:	b480      	push	{r7}
20001ec6:	b085      	sub	sp, #20
20001ec8:	af00      	add	r7, sp, #0
20001eca:	6078      	str	r0, [r7, #4]
20001ecc:	460b      	mov	r3, r1
20001ece:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
20001ed0:	2300      	movs	r3, #0
20001ed2:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
20001ed4:	687b      	ldr	r3, [r7, #4]
20001ed6:	8b9b      	ldrh	r3, [r3, #28]
20001ed8:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
20001eda:	89fb      	ldrh	r3, [r7, #14]
20001edc:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
20001ee0:	81fb      	strh	r3, [r7, #14]
  /* Configure The Forced output Mode */
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
20001ee2:	887b      	ldrh	r3, [r7, #2]
20001ee4:	021b      	lsls	r3, r3, #8
20001ee6:	b29a      	uxth	r2, r3
20001ee8:	89fb      	ldrh	r3, [r7, #14]
20001eea:	4313      	orrs	r3, r2
20001eec:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
20001eee:	687b      	ldr	r3, [r7, #4]
20001ef0:	89fa      	ldrh	r2, [r7, #14]
20001ef2:	839a      	strh	r2, [r3, #28]
}
20001ef4:	3714      	adds	r7, #20
20001ef6:	46bd      	mov	sp, r7
20001ef8:	f85d 7b04 	ldr.w	r7, [sp], #4
20001efc:	4770      	bx	lr
20001efe:	bf00      	nop

20001f00 <TIM_ARRPreloadConfig>:
  * @param  NewState: new state of the TIMx peripheral Preload register
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
20001f00:	b480      	push	{r7}
20001f02:	b083      	sub	sp, #12
20001f04:	af00      	add	r7, sp, #0
20001f06:	6078      	str	r0, [r7, #4]
20001f08:	460b      	mov	r3, r1
20001f0a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20001f0c:	78fb      	ldrb	r3, [r7, #3]
20001f0e:	2b00      	cmp	r3, #0
20001f10:	d008      	beq.n	20001f24 <TIM_ARRPreloadConfig+0x24>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
20001f12:	687b      	ldr	r3, [r7, #4]
20001f14:	881b      	ldrh	r3, [r3, #0]
20001f16:	b29b      	uxth	r3, r3
20001f18:	f043 0380 	orr.w	r3, r3, #128	; 0x80
20001f1c:	b29a      	uxth	r2, r3
20001f1e:	687b      	ldr	r3, [r7, #4]
20001f20:	801a      	strh	r2, [r3, #0]
20001f22:	e007      	b.n	20001f34 <TIM_ARRPreloadConfig+0x34>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
20001f24:	687b      	ldr	r3, [r7, #4]
20001f26:	881b      	ldrh	r3, [r3, #0]
20001f28:	b29b      	uxth	r3, r3
20001f2a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20001f2e:	b29a      	uxth	r2, r3
20001f30:	687b      	ldr	r3, [r7, #4]
20001f32:	801a      	strh	r2, [r3, #0]
  }
}
20001f34:	370c      	adds	r7, #12
20001f36:	46bd      	mov	sp, r7
20001f38:	f85d 7b04 	ldr.w	r7, [sp], #4
20001f3c:	4770      	bx	lr
20001f3e:	bf00      	nop

20001f40 <TIM_SelectCOM>:
  * @param  NewState: new state of the Commutation event.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
{
20001f40:	b480      	push	{r7}
20001f42:	b083      	sub	sp, #12
20001f44:	af00      	add	r7, sp, #0
20001f46:	6078      	str	r0, [r7, #4]
20001f48:	460b      	mov	r3, r1
20001f4a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20001f4c:	78fb      	ldrb	r3, [r7, #3]
20001f4e:	2b00      	cmp	r3, #0
20001f50:	d008      	beq.n	20001f64 <TIM_SelectCOM+0x24>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
20001f52:	687b      	ldr	r3, [r7, #4]
20001f54:	889b      	ldrh	r3, [r3, #4]
20001f56:	b29b      	uxth	r3, r3
20001f58:	f043 0304 	orr.w	r3, r3, #4
20001f5c:	b29a      	uxth	r2, r3
20001f5e:	687b      	ldr	r3, [r7, #4]
20001f60:	809a      	strh	r2, [r3, #4]
20001f62:	e007      	b.n	20001f74 <TIM_SelectCOM+0x34>
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
20001f64:	687b      	ldr	r3, [r7, #4]
20001f66:	889b      	ldrh	r3, [r3, #4]
20001f68:	b29b      	uxth	r3, r3
20001f6a:	f023 0304 	bic.w	r3, r3, #4
20001f6e:	b29a      	uxth	r2, r3
20001f70:	687b      	ldr	r3, [r7, #4]
20001f72:	809a      	strh	r2, [r3, #4]
  }
}
20001f74:	370c      	adds	r7, #12
20001f76:	46bd      	mov	sp, r7
20001f78:	f85d 7b04 	ldr.w	r7, [sp], #4
20001f7c:	4770      	bx	lr
20001f7e:	bf00      	nop

20001f80 <TIM_SelectCCDMA>:
  * @param  NewState: new state of the Capture Compare DMA source
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
{
20001f80:	b480      	push	{r7}
20001f82:	b083      	sub	sp, #12
20001f84:	af00      	add	r7, sp, #0
20001f86:	6078      	str	r0, [r7, #4]
20001f88:	460b      	mov	r3, r1
20001f8a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20001f8c:	78fb      	ldrb	r3, [r7, #3]
20001f8e:	2b00      	cmp	r3, #0
20001f90:	d008      	beq.n	20001fa4 <TIM_SelectCCDMA+0x24>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
20001f92:	687b      	ldr	r3, [r7, #4]
20001f94:	889b      	ldrh	r3, [r3, #4]
20001f96:	b29b      	uxth	r3, r3
20001f98:	f043 0308 	orr.w	r3, r3, #8
20001f9c:	b29a      	uxth	r2, r3
20001f9e:	687b      	ldr	r3, [r7, #4]
20001fa0:	809a      	strh	r2, [r3, #4]
20001fa2:	e007      	b.n	20001fb4 <TIM_SelectCCDMA+0x34>
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
20001fa4:	687b      	ldr	r3, [r7, #4]
20001fa6:	889b      	ldrh	r3, [r3, #4]
20001fa8:	b29b      	uxth	r3, r3
20001faa:	f023 0308 	bic.w	r3, r3, #8
20001fae:	b29a      	uxth	r2, r3
20001fb0:	687b      	ldr	r3, [r7, #4]
20001fb2:	809a      	strh	r2, [r3, #4]
  }
}
20001fb4:	370c      	adds	r7, #12
20001fb6:	46bd      	mov	sp, r7
20001fb8:	f85d 7b04 	ldr.w	r7, [sp], #4
20001fbc:	4770      	bx	lr
20001fbe:	bf00      	nop

20001fc0 <TIM_CCPreloadControl>:
  * @param  NewState: new state of the Capture Compare Preload Control bit
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
20001fc0:	b480      	push	{r7}
20001fc2:	b083      	sub	sp, #12
20001fc4:	af00      	add	r7, sp, #0
20001fc6:	6078      	str	r0, [r7, #4]
20001fc8:	460b      	mov	r3, r1
20001fca:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20001fcc:	78fb      	ldrb	r3, [r7, #3]
20001fce:	2b00      	cmp	r3, #0
20001fd0:	d008      	beq.n	20001fe4 <TIM_CCPreloadControl+0x24>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
20001fd2:	687b      	ldr	r3, [r7, #4]
20001fd4:	889b      	ldrh	r3, [r3, #4]
20001fd6:	b29b      	uxth	r3, r3
20001fd8:	f043 0301 	orr.w	r3, r3, #1
20001fdc:	b29a      	uxth	r2, r3
20001fde:	687b      	ldr	r3, [r7, #4]
20001fe0:	809a      	strh	r2, [r3, #4]
20001fe2:	e007      	b.n	20001ff4 <TIM_CCPreloadControl+0x34>
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
20001fe4:	687b      	ldr	r3, [r7, #4]
20001fe6:	889b      	ldrh	r3, [r3, #4]
20001fe8:	b29b      	uxth	r3, r3
20001fea:	f023 0301 	bic.w	r3, r3, #1
20001fee:	b29a      	uxth	r2, r3
20001ff0:	687b      	ldr	r3, [r7, #4]
20001ff2:	809a      	strh	r2, [r3, #4]
  }
}
20001ff4:	370c      	adds	r7, #12
20001ff6:	46bd      	mov	sp, r7
20001ff8:	f85d 7b04 	ldr.w	r7, [sp], #4
20001ffc:	4770      	bx	lr
20001ffe:	bf00      	nop

20002000 <TIM_OC1PreloadConfig>:
  *     @arg TIM_OCPreload_Enable
  *     @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
20002000:	b480      	push	{r7}
20002002:	b085      	sub	sp, #20
20002004:	af00      	add	r7, sp, #0
20002006:	6078      	str	r0, [r7, #4]
20002008:	460b      	mov	r3, r1
2000200a:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
2000200c:	2300      	movs	r3, #0
2000200e:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  tmpccmr1 = TIMx->CCMR1;
20002010:	687b      	ldr	r3, [r7, #4]
20002012:	8b1b      	ldrh	r3, [r3, #24]
20002014:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
20002016:	89fb      	ldrh	r3, [r7, #14]
20002018:	f023 0308 	bic.w	r3, r3, #8
2000201c:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
2000201e:	89fa      	ldrh	r2, [r7, #14]
20002020:	887b      	ldrh	r3, [r7, #2]
20002022:	4313      	orrs	r3, r2
20002024:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
20002026:	687b      	ldr	r3, [r7, #4]
20002028:	89fa      	ldrh	r2, [r7, #14]
2000202a:	831a      	strh	r2, [r3, #24]
}
2000202c:	3714      	adds	r7, #20
2000202e:	46bd      	mov	sp, r7
20002030:	f85d 7b04 	ldr.w	r7, [sp], #4
20002034:	4770      	bx	lr
20002036:	bf00      	nop

20002038 <TIM_OC2PreloadConfig>:
  *     @arg TIM_OCPreload_Enable
  *     @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
20002038:	b480      	push	{r7}
2000203a:	b085      	sub	sp, #20
2000203c:	af00      	add	r7, sp, #0
2000203e:	6078      	str	r0, [r7, #4]
20002040:	460b      	mov	r3, r1
20002042:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
20002044:	2300      	movs	r3, #0
20002046:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  tmpccmr1 = TIMx->CCMR1;
20002048:	687b      	ldr	r3, [r7, #4]
2000204a:	8b1b      	ldrh	r3, [r3, #24]
2000204c:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
2000204e:	89fb      	ldrh	r3, [r7, #14]
20002050:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
20002054:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
20002056:	887b      	ldrh	r3, [r7, #2]
20002058:	021b      	lsls	r3, r3, #8
2000205a:	b29a      	uxth	r2, r3
2000205c:	89fb      	ldrh	r3, [r7, #14]
2000205e:	4313      	orrs	r3, r2
20002060:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
20002062:	687b      	ldr	r3, [r7, #4]
20002064:	89fa      	ldrh	r2, [r7, #14]
20002066:	831a      	strh	r2, [r3, #24]
}
20002068:	3714      	adds	r7, #20
2000206a:	46bd      	mov	sp, r7
2000206c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002070:	4770      	bx	lr
20002072:	bf00      	nop

20002074 <TIM_OC3PreloadConfig>:
  *     @arg TIM_OCPreload_Enable
  *     @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
20002074:	b480      	push	{r7}
20002076:	b085      	sub	sp, #20
20002078:	af00      	add	r7, sp, #0
2000207a:	6078      	str	r0, [r7, #4]
2000207c:	460b      	mov	r3, r1
2000207e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
20002080:	2300      	movs	r3, #0
20002082:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  tmpccmr2 = TIMx->CCMR2;
20002084:	687b      	ldr	r3, [r7, #4]
20002086:	8b9b      	ldrh	r3, [r3, #28]
20002088:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
2000208a:	89fb      	ldrh	r3, [r7, #14]
2000208c:	f023 0308 	bic.w	r3, r3, #8
20002090:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
20002092:	89fa      	ldrh	r2, [r7, #14]
20002094:	887b      	ldrh	r3, [r7, #2]
20002096:	4313      	orrs	r3, r2
20002098:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
2000209a:	687b      	ldr	r3, [r7, #4]
2000209c:	89fa      	ldrh	r2, [r7, #14]
2000209e:	839a      	strh	r2, [r3, #28]
}
200020a0:	3714      	adds	r7, #20
200020a2:	46bd      	mov	sp, r7
200020a4:	f85d 7b04 	ldr.w	r7, [sp], #4
200020a8:	4770      	bx	lr
200020aa:	bf00      	nop

200020ac <TIM_OC4PreloadConfig>:
  *     @arg TIM_OCPreload_Enable
  *     @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
200020ac:	b480      	push	{r7}
200020ae:	b085      	sub	sp, #20
200020b0:	af00      	add	r7, sp, #0
200020b2:	6078      	str	r0, [r7, #4]
200020b4:	460b      	mov	r3, r1
200020b6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
200020b8:	2300      	movs	r3, #0
200020ba:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
  tmpccmr2 = TIMx->CCMR2;
200020bc:	687b      	ldr	r3, [r7, #4]
200020be:	8b9b      	ldrh	r3, [r3, #28]
200020c0:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
200020c2:	89fb      	ldrh	r3, [r7, #14]
200020c4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
200020c8:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
200020ca:	887b      	ldrh	r3, [r7, #2]
200020cc:	021b      	lsls	r3, r3, #8
200020ce:	b29a      	uxth	r2, r3
200020d0:	89fb      	ldrh	r3, [r7, #14]
200020d2:	4313      	orrs	r3, r2
200020d4:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
200020d6:	687b      	ldr	r3, [r7, #4]
200020d8:	89fa      	ldrh	r2, [r7, #14]
200020da:	839a      	strh	r2, [r3, #28]
}
200020dc:	3714      	adds	r7, #20
200020de:	46bd      	mov	sp, r7
200020e0:	f85d 7b04 	ldr.w	r7, [sp], #4
200020e4:	4770      	bx	lr
200020e6:	bf00      	nop

200020e8 <TIM_OC1FastConfig>:
  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
200020e8:	b480      	push	{r7}
200020ea:	b085      	sub	sp, #20
200020ec:	af00      	add	r7, sp, #0
200020ee:	6078      	str	r0, [r7, #4]
200020f0:	460b      	mov	r3, r1
200020f2:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
200020f4:	2300      	movs	r3, #0
200020f6:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
200020f8:	687b      	ldr	r3, [r7, #4]
200020fa:	8b1b      	ldrh	r3, [r3, #24]
200020fc:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
200020fe:	89fb      	ldrh	r3, [r7, #14]
20002100:	f023 0304 	bic.w	r3, r3, #4
20002104:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
20002106:	89fa      	ldrh	r2, [r7, #14]
20002108:	887b      	ldrh	r3, [r7, #2]
2000210a:	4313      	orrs	r3, r2
2000210c:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
2000210e:	687b      	ldr	r3, [r7, #4]
20002110:	89fa      	ldrh	r2, [r7, #14]
20002112:	831a      	strh	r2, [r3, #24]
}
20002114:	3714      	adds	r7, #20
20002116:	46bd      	mov	sp, r7
20002118:	f85d 7b04 	ldr.w	r7, [sp], #4
2000211c:	4770      	bx	lr
2000211e:	bf00      	nop

20002120 <TIM_OC2FastConfig>:
  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
20002120:	b480      	push	{r7}
20002122:	b085      	sub	sp, #20
20002124:	af00      	add	r7, sp, #0
20002126:	6078      	str	r0, [r7, #4]
20002128:	460b      	mov	r3, r1
2000212a:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
2000212c:	2300      	movs	r3, #0
2000212e:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
20002130:	687b      	ldr	r3, [r7, #4]
20002132:	8b1b      	ldrh	r3, [r3, #24]
20002134:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
20002136:	89fb      	ldrh	r3, [r7, #14]
20002138:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
2000213c:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
2000213e:	887b      	ldrh	r3, [r7, #2]
20002140:	021b      	lsls	r3, r3, #8
20002142:	b29a      	uxth	r2, r3
20002144:	89fb      	ldrh	r3, [r7, #14]
20002146:	4313      	orrs	r3, r2
20002148:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
2000214a:	687b      	ldr	r3, [r7, #4]
2000214c:	89fa      	ldrh	r2, [r7, #14]
2000214e:	831a      	strh	r2, [r3, #24]
}
20002150:	3714      	adds	r7, #20
20002152:	46bd      	mov	sp, r7
20002154:	f85d 7b04 	ldr.w	r7, [sp], #4
20002158:	4770      	bx	lr
2000215a:	bf00      	nop

2000215c <TIM_OC3FastConfig>:
  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
2000215c:	b480      	push	{r7}
2000215e:	b085      	sub	sp, #20
20002160:	af00      	add	r7, sp, #0
20002162:	6078      	str	r0, [r7, #4]
20002164:	460b      	mov	r3, r1
20002166:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
20002168:	2300      	movs	r3, #0
2000216a:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
2000216c:	687b      	ldr	r3, [r7, #4]
2000216e:	8b9b      	ldrh	r3, [r3, #28]
20002170:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
20002172:	89fb      	ldrh	r3, [r7, #14]
20002174:	f023 0304 	bic.w	r3, r3, #4
20002178:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
2000217a:	89fa      	ldrh	r2, [r7, #14]
2000217c:	887b      	ldrh	r3, [r7, #2]
2000217e:	4313      	orrs	r3, r2
20002180:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
20002182:	687b      	ldr	r3, [r7, #4]
20002184:	89fa      	ldrh	r2, [r7, #14]
20002186:	839a      	strh	r2, [r3, #28]
}
20002188:	3714      	adds	r7, #20
2000218a:	46bd      	mov	sp, r7
2000218c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002190:	4770      	bx	lr
20002192:	bf00      	nop

20002194 <TIM_OC4FastConfig>:
  *     @arg TIM_OCFast_Enable: TIM output compare fast enable
  *     @arg TIM_OCFast_Disable: TIM output compare fast disable
  * @retval None
  */
void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
{
20002194:	b480      	push	{r7}
20002196:	b085      	sub	sp, #20
20002198:	af00      	add	r7, sp, #0
2000219a:	6078      	str	r0, [r7, #4]
2000219c:	460b      	mov	r3, r1
2000219e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
200021a0:	2300      	movs	r3, #0
200021a2:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
200021a4:	687b      	ldr	r3, [r7, #4]
200021a6:	8b9b      	ldrh	r3, [r3, #28]
200021a8:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
200021aa:	89fb      	ldrh	r3, [r7, #14]
200021ac:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
200021b0:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
200021b2:	887b      	ldrh	r3, [r7, #2]
200021b4:	021b      	lsls	r3, r3, #8
200021b6:	b29a      	uxth	r2, r3
200021b8:	89fb      	ldrh	r3, [r7, #14]
200021ba:	4313      	orrs	r3, r2
200021bc:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
200021be:	687b      	ldr	r3, [r7, #4]
200021c0:	89fa      	ldrh	r2, [r7, #14]
200021c2:	839a      	strh	r2, [r3, #28]
}
200021c4:	3714      	adds	r7, #20
200021c6:	46bd      	mov	sp, r7
200021c8:	f85d 7b04 	ldr.w	r7, [sp], #4
200021cc:	4770      	bx	lr
200021ce:	bf00      	nop

200021d0 <TIM_ClearOC1Ref>:
  *     @arg TIM_OCClear_Enable: TIM Output clear enable
  *     @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
200021d0:	b480      	push	{r7}
200021d2:	b085      	sub	sp, #20
200021d4:	af00      	add	r7, sp, #0
200021d6:	6078      	str	r0, [r7, #4]
200021d8:	460b      	mov	r3, r1
200021da:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
200021dc:	2300      	movs	r3, #0
200021de:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
200021e0:	687b      	ldr	r3, [r7, #4]
200021e2:	8b1b      	ldrh	r3, [r3, #24]
200021e4:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
200021e6:	89fb      	ldrh	r3, [r7, #14]
200021e8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
200021ec:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
200021ee:	89fa      	ldrh	r2, [r7, #14]
200021f0:	887b      	ldrh	r3, [r7, #2]
200021f2:	4313      	orrs	r3, r2
200021f4:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
200021f6:	687b      	ldr	r3, [r7, #4]
200021f8:	89fa      	ldrh	r2, [r7, #14]
200021fa:	831a      	strh	r2, [r3, #24]
}
200021fc:	3714      	adds	r7, #20
200021fe:	46bd      	mov	sp, r7
20002200:	f85d 7b04 	ldr.w	r7, [sp], #4
20002204:	4770      	bx	lr
20002206:	bf00      	nop

20002208 <TIM_ClearOC2Ref>:
  *     @arg TIM_OCClear_Enable: TIM Output clear enable
  *     @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
20002208:	b480      	push	{r7}
2000220a:	b085      	sub	sp, #20
2000220c:	af00      	add	r7, sp, #0
2000220e:	6078      	str	r0, [r7, #4]
20002210:	460b      	mov	r3, r1
20002212:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
20002214:	2300      	movs	r3, #0
20002216:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  tmpccmr1 = TIMx->CCMR1;
20002218:	687b      	ldr	r3, [r7, #4]
2000221a:	8b1b      	ldrh	r3, [r3, #24]
2000221c:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
2000221e:	89fb      	ldrh	r3, [r7, #14]
20002220:	f3c3 030e 	ubfx	r3, r3, #0, #15
20002224:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
20002226:	887b      	ldrh	r3, [r7, #2]
20002228:	021b      	lsls	r3, r3, #8
2000222a:	b29a      	uxth	r2, r3
2000222c:	89fb      	ldrh	r3, [r7, #14]
2000222e:	4313      	orrs	r3, r2
20002230:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
20002232:	687b      	ldr	r3, [r7, #4]
20002234:	89fa      	ldrh	r2, [r7, #14]
20002236:	831a      	strh	r2, [r3, #24]
}
20002238:	3714      	adds	r7, #20
2000223a:	46bd      	mov	sp, r7
2000223c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002240:	4770      	bx	lr
20002242:	bf00      	nop

20002244 <TIM_ClearOC3Ref>:
  *     @arg TIM_OCClear_Enable: TIM Output clear enable
  *     @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
20002244:	b480      	push	{r7}
20002246:	b085      	sub	sp, #20
20002248:	af00      	add	r7, sp, #0
2000224a:	6078      	str	r0, [r7, #4]
2000224c:	460b      	mov	r3, r1
2000224e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
20002250:	2300      	movs	r3, #0
20002252:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  tmpccmr2 = TIMx->CCMR2;
20002254:	687b      	ldr	r3, [r7, #4]
20002256:	8b9b      	ldrh	r3, [r3, #28]
20002258:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
2000225a:	89fb      	ldrh	r3, [r7, #14]
2000225c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20002260:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
20002262:	89fa      	ldrh	r2, [r7, #14]
20002264:	887b      	ldrh	r3, [r7, #2]
20002266:	4313      	orrs	r3, r2
20002268:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
2000226a:	687b      	ldr	r3, [r7, #4]
2000226c:	89fa      	ldrh	r2, [r7, #14]
2000226e:	839a      	strh	r2, [r3, #28]
}
20002270:	3714      	adds	r7, #20
20002272:	46bd      	mov	sp, r7
20002274:	f85d 7b04 	ldr.w	r7, [sp], #4
20002278:	4770      	bx	lr
2000227a:	bf00      	nop

2000227c <TIM_ClearOC4Ref>:
  *     @arg TIM_OCClear_Enable: TIM Output clear enable
  *     @arg TIM_OCClear_Disable: TIM Output clear disable
  * @retval None
  */
void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
{
2000227c:	b480      	push	{r7}
2000227e:	b085      	sub	sp, #20
20002280:	af00      	add	r7, sp, #0
20002282:	6078      	str	r0, [r7, #4]
20002284:	460b      	mov	r3, r1
20002286:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr2 = 0;
20002288:	2300      	movs	r3, #0
2000228a:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
  tmpccmr2 = TIMx->CCMR2;
2000228c:	687b      	ldr	r3, [r7, #4]
2000228e:	8b9b      	ldrh	r3, [r3, #28]
20002290:	81fb      	strh	r3, [r7, #14]
  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
20002292:	89fb      	ldrh	r3, [r7, #14]
20002294:	f3c3 030e 	ubfx	r3, r3, #0, #15
20002298:	81fb      	strh	r3, [r7, #14]
  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
2000229a:	887b      	ldrh	r3, [r7, #2]
2000229c:	021b      	lsls	r3, r3, #8
2000229e:	b29a      	uxth	r2, r3
200022a0:	89fb      	ldrh	r3, [r7, #14]
200022a2:	4313      	orrs	r3, r2
200022a4:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
200022a6:	687b      	ldr	r3, [r7, #4]
200022a8:	89fa      	ldrh	r2, [r7, #14]
200022aa:	839a      	strh	r2, [r3, #28]
}
200022ac:	3714      	adds	r7, #20
200022ae:	46bd      	mov	sp, r7
200022b0:	f85d 7b04 	ldr.w	r7, [sp], #4
200022b4:	4770      	bx	lr
200022b6:	bf00      	nop

200022b8 <TIM_OC1PolarityConfig>:
  *     @arg TIM_OCPolarity_High: Output Compare active high
  *     @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
200022b8:	b480      	push	{r7}
200022ba:	b085      	sub	sp, #20
200022bc:	af00      	add	r7, sp, #0
200022be:	6078      	str	r0, [r7, #4]
200022c0:	460b      	mov	r3, r1
200022c2:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
200022c4:	2300      	movs	r3, #0
200022c6:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  tmpccer = TIMx->CCER;
200022c8:	687b      	ldr	r3, [r7, #4]
200022ca:	8c1b      	ldrh	r3, [r3, #32]
200022cc:	81fb      	strh	r3, [r7, #14]
  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
200022ce:	89fb      	ldrh	r3, [r7, #14]
200022d0:	f023 0302 	bic.w	r3, r3, #2
200022d4:	81fb      	strh	r3, [r7, #14]
  tmpccer |= TIM_OCPolarity;
200022d6:	89fa      	ldrh	r2, [r7, #14]
200022d8:	887b      	ldrh	r3, [r7, #2]
200022da:	4313      	orrs	r3, r2
200022dc:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
200022de:	687b      	ldr	r3, [r7, #4]
200022e0:	89fa      	ldrh	r2, [r7, #14]
200022e2:	841a      	strh	r2, [r3, #32]
}
200022e4:	3714      	adds	r7, #20
200022e6:	46bd      	mov	sp, r7
200022e8:	f85d 7b04 	ldr.w	r7, [sp], #4
200022ec:	4770      	bx	lr
200022ee:	bf00      	nop

200022f0 <TIM_OC1NPolarityConfig>:
  *     @arg TIM_OCNPolarity_High: Output Compare active high
  *     @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
200022f0:	b480      	push	{r7}
200022f2:	b085      	sub	sp, #20
200022f4:	af00      	add	r7, sp, #0
200022f6:	6078      	str	r0, [r7, #4]
200022f8:	460b      	mov	r3, r1
200022fa:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
200022fc:	2300      	movs	r3, #0
200022fe:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
20002300:	687b      	ldr	r3, [r7, #4]
20002302:	8c1b      	ldrh	r3, [r3, #32]
20002304:	81fb      	strh	r3, [r7, #14]
  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
20002306:	89fb      	ldrh	r3, [r7, #14]
20002308:	f023 0308 	bic.w	r3, r3, #8
2000230c:	81fb      	strh	r3, [r7, #14]
  tmpccer |= TIM_OCNPolarity;
2000230e:	89fa      	ldrh	r2, [r7, #14]
20002310:	887b      	ldrh	r3, [r7, #2]
20002312:	4313      	orrs	r3, r2
20002314:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
20002316:	687b      	ldr	r3, [r7, #4]
20002318:	89fa      	ldrh	r2, [r7, #14]
2000231a:	841a      	strh	r2, [r3, #32]
}
2000231c:	3714      	adds	r7, #20
2000231e:	46bd      	mov	sp, r7
20002320:	f85d 7b04 	ldr.w	r7, [sp], #4
20002324:	4770      	bx	lr
20002326:	bf00      	nop

20002328 <TIM_OC2PolarityConfig>:
  *     @arg TIM_OCPolarity_High: Output Compare active high
  *     @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
20002328:	b480      	push	{r7}
2000232a:	b085      	sub	sp, #20
2000232c:	af00      	add	r7, sp, #0
2000232e:	6078      	str	r0, [r7, #4]
20002330:	460b      	mov	r3, r1
20002332:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
20002334:	2300      	movs	r3, #0
20002336:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  tmpccer = TIMx->CCER;
20002338:	687b      	ldr	r3, [r7, #4]
2000233a:	8c1b      	ldrh	r3, [r3, #32]
2000233c:	81fb      	strh	r3, [r7, #14]
  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
2000233e:	89fb      	ldrh	r3, [r7, #14]
20002340:	f023 0320 	bic.w	r3, r3, #32
20002344:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
20002346:	887b      	ldrh	r3, [r7, #2]
20002348:	011b      	lsls	r3, r3, #4
2000234a:	b29a      	uxth	r2, r3
2000234c:	89fb      	ldrh	r3, [r7, #14]
2000234e:	4313      	orrs	r3, r2
20002350:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
20002352:	687b      	ldr	r3, [r7, #4]
20002354:	89fa      	ldrh	r2, [r7, #14]
20002356:	841a      	strh	r2, [r3, #32]
}
20002358:	3714      	adds	r7, #20
2000235a:	46bd      	mov	sp, r7
2000235c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002360:	4770      	bx	lr
20002362:	bf00      	nop

20002364 <TIM_OC2NPolarityConfig>:
  *     @arg TIM_OCNPolarity_High: Output Compare active high
  *     @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
20002364:	b480      	push	{r7}
20002366:	b085      	sub	sp, #20
20002368:	af00      	add	r7, sp, #0
2000236a:	6078      	str	r0, [r7, #4]
2000236c:	460b      	mov	r3, r1
2000236e:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
20002370:	2300      	movs	r3, #0
20002372:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
20002374:	687b      	ldr	r3, [r7, #4]
20002376:	8c1b      	ldrh	r3, [r3, #32]
20002378:	81fb      	strh	r3, [r7, #14]
  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
2000237a:	89fb      	ldrh	r3, [r7, #14]
2000237c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20002380:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
20002382:	887b      	ldrh	r3, [r7, #2]
20002384:	011b      	lsls	r3, r3, #4
20002386:	b29a      	uxth	r2, r3
20002388:	89fb      	ldrh	r3, [r7, #14]
2000238a:	4313      	orrs	r3, r2
2000238c:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
2000238e:	687b      	ldr	r3, [r7, #4]
20002390:	89fa      	ldrh	r2, [r7, #14]
20002392:	841a      	strh	r2, [r3, #32]
}
20002394:	3714      	adds	r7, #20
20002396:	46bd      	mov	sp, r7
20002398:	f85d 7b04 	ldr.w	r7, [sp], #4
2000239c:	4770      	bx	lr
2000239e:	bf00      	nop

200023a0 <TIM_OC3PolarityConfig>:
  *     @arg TIM_OCPolarity_High: Output Compare active high
  *     @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
200023a0:	b480      	push	{r7}
200023a2:	b085      	sub	sp, #20
200023a4:	af00      	add	r7, sp, #0
200023a6:	6078      	str	r0, [r7, #4]
200023a8:	460b      	mov	r3, r1
200023aa:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
200023ac:	2300      	movs	r3, #0
200023ae:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  tmpccer = TIMx->CCER;
200023b0:	687b      	ldr	r3, [r7, #4]
200023b2:	8c1b      	ldrh	r3, [r3, #32]
200023b4:	81fb      	strh	r3, [r7, #14]
  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
200023b6:	89fb      	ldrh	r3, [r7, #14]
200023b8:	f423 7300 	bic.w	r3, r3, #512	; 0x200
200023bc:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
200023be:	887b      	ldrh	r3, [r7, #2]
200023c0:	021b      	lsls	r3, r3, #8
200023c2:	b29a      	uxth	r2, r3
200023c4:	89fb      	ldrh	r3, [r7, #14]
200023c6:	4313      	orrs	r3, r2
200023c8:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
200023ca:	687b      	ldr	r3, [r7, #4]
200023cc:	89fa      	ldrh	r2, [r7, #14]
200023ce:	841a      	strh	r2, [r3, #32]
}
200023d0:	3714      	adds	r7, #20
200023d2:	46bd      	mov	sp, r7
200023d4:	f85d 7b04 	ldr.w	r7, [sp], #4
200023d8:	4770      	bx	lr
200023da:	bf00      	nop

200023dc <TIM_OC3NPolarityConfig>:
  *     @arg TIM_OCNPolarity_High: Output Compare active high
  *     @arg TIM_OCNPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
{
200023dc:	b480      	push	{r7}
200023de:	b085      	sub	sp, #20
200023e0:	af00      	add	r7, sp, #0
200023e2:	6078      	str	r0, [r7, #4]
200023e4:	460b      	mov	r3, r1
200023e6:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
200023e8:	2300      	movs	r3, #0
200023ea:	81fb      	strh	r3, [r7, #14]
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
200023ec:	687b      	ldr	r3, [r7, #4]
200023ee:	8c1b      	ldrh	r3, [r3, #32]
200023f0:	81fb      	strh	r3, [r7, #14]
  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
200023f2:	89fb      	ldrh	r3, [r7, #14]
200023f4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
200023f8:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
200023fa:	887b      	ldrh	r3, [r7, #2]
200023fc:	021b      	lsls	r3, r3, #8
200023fe:	b29a      	uxth	r2, r3
20002400:	89fb      	ldrh	r3, [r7, #14]
20002402:	4313      	orrs	r3, r2
20002404:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
20002406:	687b      	ldr	r3, [r7, #4]
20002408:	89fa      	ldrh	r2, [r7, #14]
2000240a:	841a      	strh	r2, [r3, #32]
}
2000240c:	3714      	adds	r7, #20
2000240e:	46bd      	mov	sp, r7
20002410:	f85d 7b04 	ldr.w	r7, [sp], #4
20002414:	4770      	bx	lr
20002416:	bf00      	nop

20002418 <TIM_OC4PolarityConfig>:
  *     @arg TIM_OCPolarity_High: Output Compare active high
  *     @arg TIM_OCPolarity_Low: Output Compare active low
  * @retval None
  */
void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
{
20002418:	b480      	push	{r7}
2000241a:	b085      	sub	sp, #20
2000241c:	af00      	add	r7, sp, #0
2000241e:	6078      	str	r0, [r7, #4]
20002420:	460b      	mov	r3, r1
20002422:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccer = 0;
20002424:	2300      	movs	r3, #0
20002426:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
  tmpccer = TIMx->CCER;
20002428:	687b      	ldr	r3, [r7, #4]
2000242a:	8c1b      	ldrh	r3, [r3, #32]
2000242c:	81fb      	strh	r3, [r7, #14]
  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
2000242e:	89fb      	ldrh	r3, [r7, #14]
20002430:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
20002434:	81fb      	strh	r3, [r7, #14]
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
20002436:	887b      	ldrh	r3, [r7, #2]
20002438:	031b      	lsls	r3, r3, #12
2000243a:	b29a      	uxth	r2, r3
2000243c:	89fb      	ldrh	r3, [r7, #14]
2000243e:	4313      	orrs	r3, r2
20002440:	81fb      	strh	r3, [r7, #14]
  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
20002442:	687b      	ldr	r3, [r7, #4]
20002444:	89fa      	ldrh	r2, [r7, #14]
20002446:	841a      	strh	r2, [r3, #32]
}
20002448:	3714      	adds	r7, #20
2000244a:	46bd      	mov	sp, r7
2000244c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002450:	4770      	bx	lr
20002452:	bf00      	nop

20002454 <TIM_CCxCmd>:
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
20002454:	b480      	push	{r7}
20002456:	b085      	sub	sp, #20
20002458:	af00      	add	r7, sp, #0
2000245a:	6078      	str	r0, [r7, #4]
2000245c:	4613      	mov	r3, r2
2000245e:	460a      	mov	r2, r1
20002460:	807a      	strh	r2, [r7, #2]
20002462:	803b      	strh	r3, [r7, #0]
  uint16_t tmp = 0;
20002464:	2300      	movs	r3, #0
20002466:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = CCER_CCE_Set << TIM_Channel;
20002468:	887b      	ldrh	r3, [r7, #2]
2000246a:	2201      	movs	r2, #1
2000246c:	fa02 f303 	lsl.w	r3, r2, r3
20002470:	81fb      	strh	r3, [r7, #14]

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t)~ tmp;
20002472:	687b      	ldr	r3, [r7, #4]
20002474:	8c1b      	ldrh	r3, [r3, #32]
20002476:	b29a      	uxth	r2, r3
20002478:	89fb      	ldrh	r3, [r7, #14]
2000247a:	43db      	mvns	r3, r3
2000247c:	b29b      	uxth	r3, r3
2000247e:	4013      	ands	r3, r2
20002480:	b29a      	uxth	r2, r3
20002482:	687b      	ldr	r3, [r7, #4]
20002484:	841a      	strh	r2, [r3, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
20002486:	687b      	ldr	r3, [r7, #4]
20002488:	8c1b      	ldrh	r3, [r3, #32]
2000248a:	b29a      	uxth	r2, r3
2000248c:	8839      	ldrh	r1, [r7, #0]
2000248e:	887b      	ldrh	r3, [r7, #2]
20002490:	fa01 f303 	lsl.w	r3, r1, r3
20002494:	b29b      	uxth	r3, r3
20002496:	4313      	orrs	r3, r2
20002498:	b29a      	uxth	r2, r3
2000249a:	687b      	ldr	r3, [r7, #4]
2000249c:	841a      	strh	r2, [r3, #32]
}
2000249e:	3714      	adds	r7, #20
200024a0:	46bd      	mov	sp, r7
200024a2:	f85d 7b04 	ldr.w	r7, [sp], #4
200024a6:	4770      	bx	lr

200024a8 <TIM_CCxNCmd>:
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
200024a8:	b480      	push	{r7}
200024aa:	b085      	sub	sp, #20
200024ac:	af00      	add	r7, sp, #0
200024ae:	6078      	str	r0, [r7, #4]
200024b0:	4613      	mov	r3, r2
200024b2:	460a      	mov	r2, r1
200024b4:	807a      	strh	r2, [r7, #2]
200024b6:	803b      	strh	r3, [r7, #0]
  uint16_t tmp = 0;
200024b8:	2300      	movs	r3, #0
200024ba:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = CCER_CCNE_Set << TIM_Channel;
200024bc:	887b      	ldrh	r3, [r7, #2]
200024be:	2204      	movs	r2, #4
200024c0:	fa02 f303 	lsl.w	r3, r2, r3
200024c4:	81fb      	strh	r3, [r7, #14]

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint16_t) ~tmp;
200024c6:	687b      	ldr	r3, [r7, #4]
200024c8:	8c1b      	ldrh	r3, [r3, #32]
200024ca:	b29a      	uxth	r2, r3
200024cc:	89fb      	ldrh	r3, [r7, #14]
200024ce:	43db      	mvns	r3, r3
200024d0:	b29b      	uxth	r3, r3
200024d2:	4013      	ands	r3, r2
200024d4:	b29a      	uxth	r2, r3
200024d6:	687b      	ldr	r3, [r7, #4]
200024d8:	841a      	strh	r2, [r3, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
200024da:	687b      	ldr	r3, [r7, #4]
200024dc:	8c1b      	ldrh	r3, [r3, #32]
200024de:	b29a      	uxth	r2, r3
200024e0:	8839      	ldrh	r1, [r7, #0]
200024e2:	887b      	ldrh	r3, [r7, #2]
200024e4:	fa01 f303 	lsl.w	r3, r1, r3
200024e8:	b29b      	uxth	r3, r3
200024ea:	4313      	orrs	r3, r2
200024ec:	b29a      	uxth	r2, r3
200024ee:	687b      	ldr	r3, [r7, #4]
200024f0:	841a      	strh	r2, [r3, #32]
}
200024f2:	3714      	adds	r7, #20
200024f4:	46bd      	mov	sp, r7
200024f6:	f85d 7b04 	ldr.w	r7, [sp], #4
200024fa:	4770      	bx	lr

200024fc <TIM_SelectOCxM>:
  *     @arg TIM_ForcedAction_Active
  *     @arg TIM_ForcedAction_InActive
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
{
200024fc:	b480      	push	{r7}
200024fe:	b085      	sub	sp, #20
20002500:	af00      	add	r7, sp, #0
20002502:	6078      	str	r0, [r7, #4]
20002504:	4613      	mov	r3, r2
20002506:	460a      	mov	r2, r1
20002508:	807a      	strh	r2, [r7, #2]
2000250a:	803b      	strh	r3, [r7, #0]
  uint32_t tmp = 0;
2000250c:	2300      	movs	r3, #0
2000250e:	60fb      	str	r3, [r7, #12]
  uint16_t tmp1 = 0;
20002510:	2300      	movs	r3, #0
20002512:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
20002514:	687b      	ldr	r3, [r7, #4]
20002516:	60fb      	str	r3, [r7, #12]
  tmp += CCMR_Offset;
20002518:	68fb      	ldr	r3, [r7, #12]
2000251a:	3318      	adds	r3, #24
2000251c:	60fb      	str	r3, [r7, #12]

  tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
2000251e:	887b      	ldrh	r3, [r7, #2]
20002520:	2201      	movs	r2, #1
20002522:	fa02 f303 	lsl.w	r3, r2, r3
20002526:	817b      	strh	r3, [r7, #10]

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
20002528:	687b      	ldr	r3, [r7, #4]
2000252a:	8c1b      	ldrh	r3, [r3, #32]
2000252c:	b29a      	uxth	r2, r3
2000252e:	897b      	ldrh	r3, [r7, #10]
20002530:	43db      	mvns	r3, r3
20002532:	b29b      	uxth	r3, r3
20002534:	4013      	ands	r3, r2
20002536:	b29a      	uxth	r2, r3
20002538:	687b      	ldr	r3, [r7, #4]
2000253a:	841a      	strh	r2, [r3, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
2000253c:	887b      	ldrh	r3, [r7, #2]
2000253e:	2b00      	cmp	r3, #0
20002540:	d002      	beq.n	20002548 <TIM_SelectOCxM+0x4c>
20002542:	887b      	ldrh	r3, [r7, #2]
20002544:	2b08      	cmp	r3, #8
20002546:	d112      	bne.n	2000256e <TIM_SelectOCxM+0x72>
  {
    tmp += (TIM_Channel>>1);
20002548:	887b      	ldrh	r3, [r7, #2]
2000254a:	085b      	lsrs	r3, r3, #1
2000254c:	b29b      	uxth	r3, r3
2000254e:	68fa      	ldr	r2, [r7, #12]
20002550:	4413      	add	r3, r2
20002552:	60fb      	str	r3, [r7, #12]

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
20002554:	68fb      	ldr	r3, [r7, #12]
20002556:	68fa      	ldr	r2, [r7, #12]
20002558:	6812      	ldr	r2, [r2, #0]
2000255a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
2000255e:	601a      	str	r2, [r3, #0]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
20002560:	68fb      	ldr	r3, [r7, #12]
20002562:	68fa      	ldr	r2, [r7, #12]
20002564:	6811      	ldr	r1, [r2, #0]
20002566:	883a      	ldrh	r2, [r7, #0]
20002568:	430a      	orrs	r2, r1
2000256a:	601a      	str	r2, [r3, #0]
2000256c:	e015      	b.n	2000259a <TIM_SelectOCxM+0x9e>
  }
  else
  {
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
2000256e:	887b      	ldrh	r3, [r7, #2]
20002570:	3b04      	subs	r3, #4
20002572:	b29b      	uxth	r3, r3
20002574:	085b      	lsrs	r3, r3, #1
20002576:	b29b      	uxth	r3, r3
20002578:	68fa      	ldr	r2, [r7, #12]
2000257a:	4413      	add	r3, r2
2000257c:	60fb      	str	r3, [r7, #12]

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
2000257e:	68fb      	ldr	r3, [r7, #12]
20002580:	68fa      	ldr	r2, [r7, #12]
20002582:	6812      	ldr	r2, [r2, #0]
20002584:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
20002588:	601a      	str	r2, [r3, #0]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
2000258a:	68fb      	ldr	r3, [r7, #12]
2000258c:	68fa      	ldr	r2, [r7, #12]
2000258e:	6811      	ldr	r1, [r2, #0]
20002590:	883a      	ldrh	r2, [r7, #0]
20002592:	0212      	lsls	r2, r2, #8
20002594:	b292      	uxth	r2, r2
20002596:	430a      	orrs	r2, r1
20002598:	601a      	str	r2, [r3, #0]
  }
}
2000259a:	3714      	adds	r7, #20
2000259c:	46bd      	mov	sp, r7
2000259e:	f85d 7b04 	ldr.w	r7, [sp], #4
200025a2:	4770      	bx	lr

200025a4 <TIM_UpdateDisableConfig>:
  * @param  NewState: new state of the TIMx UDIS bit
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
200025a4:	b480      	push	{r7}
200025a6:	b083      	sub	sp, #12
200025a8:	af00      	add	r7, sp, #0
200025aa:	6078      	str	r0, [r7, #4]
200025ac:	460b      	mov	r3, r1
200025ae:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
200025b0:	78fb      	ldrb	r3, [r7, #3]
200025b2:	2b00      	cmp	r3, #0
200025b4:	d008      	beq.n	200025c8 <TIM_UpdateDisableConfig+0x24>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
200025b6:	687b      	ldr	r3, [r7, #4]
200025b8:	881b      	ldrh	r3, [r3, #0]
200025ba:	b29b      	uxth	r3, r3
200025bc:	f043 0302 	orr.w	r3, r3, #2
200025c0:	b29a      	uxth	r2, r3
200025c2:	687b      	ldr	r3, [r7, #4]
200025c4:	801a      	strh	r2, [r3, #0]
200025c6:	e007      	b.n	200025d8 <TIM_UpdateDisableConfig+0x34>
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
200025c8:	687b      	ldr	r3, [r7, #4]
200025ca:	881b      	ldrh	r3, [r3, #0]
200025cc:	b29b      	uxth	r3, r3
200025ce:	f023 0302 	bic.w	r3, r3, #2
200025d2:	b29a      	uxth	r2, r3
200025d4:	687b      	ldr	r3, [r7, #4]
200025d6:	801a      	strh	r2, [r3, #0]
  }
}
200025d8:	370c      	adds	r7, #12
200025da:	46bd      	mov	sp, r7
200025dc:	f85d 7b04 	ldr.w	r7, [sp], #4
200025e0:	4770      	bx	lr
200025e2:	bf00      	nop

200025e4 <TIM_UpdateRequestConfig>:
                                       through the slave mode controller.
  *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
  * @retval None
  */
void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
{
200025e4:	b480      	push	{r7}
200025e6:	b083      	sub	sp, #12
200025e8:	af00      	add	r7, sp, #0
200025ea:	6078      	str	r0, [r7, #4]
200025ec:	460b      	mov	r3, r1
200025ee:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
  if (TIM_UpdateSource != TIM_UpdateSource_Global)
200025f0:	887b      	ldrh	r3, [r7, #2]
200025f2:	2b00      	cmp	r3, #0
200025f4:	d008      	beq.n	20002608 <TIM_UpdateRequestConfig+0x24>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
200025f6:	687b      	ldr	r3, [r7, #4]
200025f8:	881b      	ldrh	r3, [r3, #0]
200025fa:	b29b      	uxth	r3, r3
200025fc:	f043 0304 	orr.w	r3, r3, #4
20002600:	b29a      	uxth	r2, r3
20002602:	687b      	ldr	r3, [r7, #4]
20002604:	801a      	strh	r2, [r3, #0]
20002606:	e007      	b.n	20002618 <TIM_UpdateRequestConfig+0x34>
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
20002608:	687b      	ldr	r3, [r7, #4]
2000260a:	881b      	ldrh	r3, [r3, #0]
2000260c:	b29b      	uxth	r3, r3
2000260e:	f023 0304 	bic.w	r3, r3, #4
20002612:	b29a      	uxth	r2, r3
20002614:	687b      	ldr	r3, [r7, #4]
20002616:	801a      	strh	r2, [r3, #0]
  }
}
20002618:	370c      	adds	r7, #12
2000261a:	46bd      	mov	sp, r7
2000261c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002620:	4770      	bx	lr
20002622:	bf00      	nop

20002624 <TIM_SelectHallSensor>:
  * @param  NewState: new state of the TIMx Hall sensor interface.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
{
20002624:	b480      	push	{r7}
20002626:	b083      	sub	sp, #12
20002628:	af00      	add	r7, sp, #0
2000262a:	6078      	str	r0, [r7, #4]
2000262c:	460b      	mov	r3, r1
2000262e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
20002630:	78fb      	ldrb	r3, [r7, #3]
20002632:	2b00      	cmp	r3, #0
20002634:	d008      	beq.n	20002648 <TIM_SelectHallSensor+0x24>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
20002636:	687b      	ldr	r3, [r7, #4]
20002638:	889b      	ldrh	r3, [r3, #4]
2000263a:	b29b      	uxth	r3, r3
2000263c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
20002640:	b29a      	uxth	r2, r3
20002642:	687b      	ldr	r3, [r7, #4]
20002644:	809a      	strh	r2, [r3, #4]
20002646:	e007      	b.n	20002658 <TIM_SelectHallSensor+0x34>
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
20002648:	687b      	ldr	r3, [r7, #4]
2000264a:	889b      	ldrh	r3, [r3, #4]
2000264c:	b29b      	uxth	r3, r3
2000264e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20002652:	b29a      	uxth	r2, r3
20002654:	687b      	ldr	r3, [r7, #4]
20002656:	809a      	strh	r2, [r3, #4]
  }
}
20002658:	370c      	adds	r7, #12
2000265a:	46bd      	mov	sp, r7
2000265c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002660:	4770      	bx	lr
20002662:	bf00      	nop

20002664 <TIM_SelectOnePulseMode>:
  *     @arg TIM_OPMode_Single
  *     @arg TIM_OPMode_Repetitive
  * @retval None
  */
void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
{
20002664:	b480      	push	{r7}
20002666:	b083      	sub	sp, #12
20002668:	af00      	add	r7, sp, #0
2000266a:	6078      	str	r0, [r7, #4]
2000266c:	460b      	mov	r3, r1
2000266e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
20002670:	687b      	ldr	r3, [r7, #4]
20002672:	881b      	ldrh	r3, [r3, #0]
20002674:	b29b      	uxth	r3, r3
20002676:	f023 0308 	bic.w	r3, r3, #8
2000267a:	b29a      	uxth	r2, r3
2000267c:	687b      	ldr	r3, [r7, #4]
2000267e:	801a      	strh	r2, [r3, #0]
  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
20002680:	687b      	ldr	r3, [r7, #4]
20002682:	881b      	ldrh	r3, [r3, #0]
20002684:	b29a      	uxth	r2, r3
20002686:	887b      	ldrh	r3, [r7, #2]
20002688:	4313      	orrs	r3, r2
2000268a:	b29a      	uxth	r2, r3
2000268c:	687b      	ldr	r3, [r7, #4]
2000268e:	801a      	strh	r2, [r3, #0]
}
20002690:	370c      	adds	r7, #12
20002692:	46bd      	mov	sp, r7
20002694:	f85d 7b04 	ldr.w	r7, [sp], #4
20002698:	4770      	bx	lr
2000269a:	bf00      	nop

2000269c <TIM_SelectOutputTrigger>:
  *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
  *
  * @retval None
  */
void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
{
2000269c:	b480      	push	{r7}
2000269e:	b083      	sub	sp, #12
200026a0:	af00      	add	r7, sp, #0
200026a2:	6078      	str	r0, [r7, #4]
200026a4:	460b      	mov	r3, r1
200026a6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST7_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
200026a8:	687b      	ldr	r3, [r7, #4]
200026aa:	889b      	ldrh	r3, [r3, #4]
200026ac:	b29b      	uxth	r3, r3
200026ae:	f023 0370 	bic.w	r3, r3, #112	; 0x70
200026b2:	b29a      	uxth	r2, r3
200026b4:	687b      	ldr	r3, [r7, #4]
200026b6:	809a      	strh	r2, [r3, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
200026b8:	687b      	ldr	r3, [r7, #4]
200026ba:	889b      	ldrh	r3, [r3, #4]
200026bc:	b29a      	uxth	r2, r3
200026be:	887b      	ldrh	r3, [r7, #2]
200026c0:	4313      	orrs	r3, r2
200026c2:	b29a      	uxth	r2, r3
200026c4:	687b      	ldr	r3, [r7, #4]
200026c6:	809a      	strh	r2, [r3, #4]
}
200026c8:	370c      	adds	r7, #12
200026ca:	46bd      	mov	sp, r7
200026cc:	f85d 7b04 	ldr.w	r7, [sp], #4
200026d0:	4770      	bx	lr
200026d2:	bf00      	nop

200026d4 <TIM_SelectSlaveMode>:
  *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
  *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
  * @retval None
  */
void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
{
200026d4:	b480      	push	{r7}
200026d6:	b083      	sub	sp, #12
200026d8:	af00      	add	r7, sp, #0
200026da:	6078      	str	r0, [r7, #4]
200026dc:	460b      	mov	r3, r1
200026de:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
 /* Reset the SMS Bits */
  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
200026e0:	687b      	ldr	r3, [r7, #4]
200026e2:	891b      	ldrh	r3, [r3, #8]
200026e4:	b29b      	uxth	r3, r3
200026e6:	f023 0307 	bic.w	r3, r3, #7
200026ea:	b29a      	uxth	r2, r3
200026ec:	687b      	ldr	r3, [r7, #4]
200026ee:	811a      	strh	r2, [r3, #8]
  /* Select the Slave Mode */
  TIMx->SMCR |= TIM_SlaveMode;
200026f0:	687b      	ldr	r3, [r7, #4]
200026f2:	891b      	ldrh	r3, [r3, #8]
200026f4:	b29a      	uxth	r2, r3
200026f6:	887b      	ldrh	r3, [r7, #2]
200026f8:	4313      	orrs	r3, r2
200026fa:	b29a      	uxth	r2, r3
200026fc:	687b      	ldr	r3, [r7, #4]
200026fe:	811a      	strh	r2, [r3, #8]
}
20002700:	370c      	adds	r7, #12
20002702:	46bd      	mov	sp, r7
20002704:	f85d 7b04 	ldr.w	r7, [sp], #4
20002708:	4770      	bx	lr
2000270a:	bf00      	nop

2000270c <TIM_SelectMasterSlaveMode>:
  *                                      and its slaves (through TRGO).
  *     @arg TIM_MasterSlaveMode_Disable: No action
  * @retval None
  */
void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
{
2000270c:	b480      	push	{r7}
2000270e:	b083      	sub	sp, #12
20002710:	af00      	add	r7, sp, #0
20002712:	6078      	str	r0, [r7, #4]
20002714:	460b      	mov	r3, r1
20002716:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
20002718:	687b      	ldr	r3, [r7, #4]
2000271a:	891b      	ldrh	r3, [r3, #8]
2000271c:	b29b      	uxth	r3, r3
2000271e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
20002722:	b29a      	uxth	r2, r3
20002724:	687b      	ldr	r3, [r7, #4]
20002726:	811a      	strh	r2, [r3, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
20002728:	687b      	ldr	r3, [r7, #4]
2000272a:	891b      	ldrh	r3, [r3, #8]
2000272c:	b29a      	uxth	r2, r3
2000272e:	887b      	ldrh	r3, [r7, #2]
20002730:	4313      	orrs	r3, r2
20002732:	b29a      	uxth	r2, r3
20002734:	687b      	ldr	r3, [r7, #4]
20002736:	811a      	strh	r2, [r3, #8]
}
20002738:	370c      	adds	r7, #12
2000273a:	46bd      	mov	sp, r7
2000273c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002740:	4770      	bx	lr
20002742:	bf00      	nop

20002744 <TIM_SetCounter>:
  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
  * @param  Counter: specifies the Counter register new value.
  * @retval None
  */
void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
{
20002744:	b480      	push	{r7}
20002746:	b083      	sub	sp, #12
20002748:	af00      	add	r7, sp, #0
2000274a:	6078      	str	r0, [r7, #4]
2000274c:	460b      	mov	r3, r1
2000274e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Set the Counter Register value */
  TIMx->CNT = Counter;
20002750:	687b      	ldr	r3, [r7, #4]
20002752:	887a      	ldrh	r2, [r7, #2]
20002754:	849a      	strh	r2, [r3, #36]	; 0x24
}
20002756:	370c      	adds	r7, #12
20002758:	46bd      	mov	sp, r7
2000275a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000275e:	4770      	bx	lr

20002760 <TIM_SetAutoreload>:
  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
  * @param  Autoreload: specifies the Autoreload register new value.
  * @retval None
  */
void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
{
20002760:	b480      	push	{r7}
20002762:	b083      	sub	sp, #12
20002764:	af00      	add	r7, sp, #0
20002766:	6078      	str	r0, [r7, #4]
20002768:	460b      	mov	r3, r1
2000276a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
2000276c:	687b      	ldr	r3, [r7, #4]
2000276e:	887a      	ldrh	r2, [r7, #2]
20002770:	859a      	strh	r2, [r3, #44]	; 0x2c
}
20002772:	370c      	adds	r7, #12
20002774:	46bd      	mov	sp, r7
20002776:	f85d 7b04 	ldr.w	r7, [sp], #4
2000277a:	4770      	bx	lr

2000277c <TIM_SetCompare1>:
  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
  * @param  Compare1: specifies the Capture Compare1 register new value.
  * @retval None
  */
void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
{
2000277c:	b480      	push	{r7}
2000277e:	b083      	sub	sp, #12
20002780:	af00      	add	r7, sp, #0
20002782:	6078      	str	r0, [r7, #4]
20002784:	460b      	mov	r3, r1
20002786:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
20002788:	687b      	ldr	r3, [r7, #4]
2000278a:	887a      	ldrh	r2, [r7, #2]
2000278c:	869a      	strh	r2, [r3, #52]	; 0x34
}
2000278e:	370c      	adds	r7, #12
20002790:	46bd      	mov	sp, r7
20002792:	f85d 7b04 	ldr.w	r7, [sp], #4
20002796:	4770      	bx	lr

20002798 <TIM_SetCompare2>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
  * @param  Compare2: specifies the Capture Compare2 register new value.
  * @retval None
  */
void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
{
20002798:	b480      	push	{r7}
2000279a:	b083      	sub	sp, #12
2000279c:	af00      	add	r7, sp, #0
2000279e:	6078      	str	r0, [r7, #4]
200027a0:	460b      	mov	r3, r1
200027a2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
200027a4:	687b      	ldr	r3, [r7, #4]
200027a6:	887a      	ldrh	r2, [r7, #2]
200027a8:	871a      	strh	r2, [r3, #56]	; 0x38
}
200027aa:	370c      	adds	r7, #12
200027ac:	46bd      	mov	sp, r7
200027ae:	f85d 7b04 	ldr.w	r7, [sp], #4
200027b2:	4770      	bx	lr

200027b4 <TIM_SetCompare3>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare3: specifies the Capture Compare3 register new value.
  * @retval None
  */
void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
{
200027b4:	b480      	push	{r7}
200027b6:	b083      	sub	sp, #12
200027b8:	af00      	add	r7, sp, #0
200027ba:	6078      	str	r0, [r7, #4]
200027bc:	460b      	mov	r3, r1
200027be:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
200027c0:	687b      	ldr	r3, [r7, #4]
200027c2:	887a      	ldrh	r2, [r7, #2]
200027c4:	879a      	strh	r2, [r3, #60]	; 0x3c
}
200027c6:	370c      	adds	r7, #12
200027c8:	46bd      	mov	sp, r7
200027ca:	f85d 7b04 	ldr.w	r7, [sp], #4
200027ce:	4770      	bx	lr

200027d0 <TIM_SetCompare4>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare4: specifies the Capture Compare4 register new value.
  * @retval None
  */
void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
{
200027d0:	b480      	push	{r7}
200027d2:	b083      	sub	sp, #12
200027d4:	af00      	add	r7, sp, #0
200027d6:	6078      	str	r0, [r7, #4]
200027d8:	460b      	mov	r3, r1
200027da:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
200027dc:	687b      	ldr	r3, [r7, #4]
200027de:	887a      	ldrh	r2, [r7, #2]
200027e0:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
}
200027e4:	370c      	adds	r7, #12
200027e6:	46bd      	mov	sp, r7
200027e8:	f85d 7b04 	ldr.w	r7, [sp], #4
200027ec:	4770      	bx	lr
200027ee:	bf00      	nop

200027f0 <TIM_SetIC1Prescaler>:
  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
200027f0:	b480      	push	{r7}
200027f2:	b083      	sub	sp, #12
200027f4:	af00      	add	r7, sp, #0
200027f6:	6078      	str	r0, [r7, #4]
200027f8:	460b      	mov	r3, r1
200027fa:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
200027fc:	687b      	ldr	r3, [r7, #4]
200027fe:	8b1b      	ldrh	r3, [r3, #24]
20002800:	b29b      	uxth	r3, r3
20002802:	f023 030c 	bic.w	r3, r3, #12
20002806:	b29a      	uxth	r2, r3
20002808:	687b      	ldr	r3, [r7, #4]
2000280a:	831a      	strh	r2, [r3, #24]
  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
2000280c:	687b      	ldr	r3, [r7, #4]
2000280e:	8b1b      	ldrh	r3, [r3, #24]
20002810:	b29a      	uxth	r2, r3
20002812:	887b      	ldrh	r3, [r7, #2]
20002814:	4313      	orrs	r3, r2
20002816:	b29a      	uxth	r2, r3
20002818:	687b      	ldr	r3, [r7, #4]
2000281a:	831a      	strh	r2, [r3, #24]
}
2000281c:	370c      	adds	r7, #12
2000281e:	46bd      	mov	sp, r7
20002820:	f85d 7b04 	ldr.w	r7, [sp], #4
20002824:	4770      	bx	lr
20002826:	bf00      	nop

20002828 <TIM_SetIC2Prescaler>:
  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
20002828:	b480      	push	{r7}
2000282a:	b083      	sub	sp, #12
2000282c:	af00      	add	r7, sp, #0
2000282e:	6078      	str	r0, [r7, #4]
20002830:	460b      	mov	r3, r1
20002832:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
20002834:	687b      	ldr	r3, [r7, #4]
20002836:	8b1b      	ldrh	r3, [r3, #24]
20002838:	b29b      	uxth	r3, r3
2000283a:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
2000283e:	b29a      	uxth	r2, r3
20002840:	687b      	ldr	r3, [r7, #4]
20002842:	831a      	strh	r2, [r3, #24]
  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
20002844:	687b      	ldr	r3, [r7, #4]
20002846:	8b1b      	ldrh	r3, [r3, #24]
20002848:	b29a      	uxth	r2, r3
2000284a:	887b      	ldrh	r3, [r7, #2]
2000284c:	021b      	lsls	r3, r3, #8
2000284e:	b29b      	uxth	r3, r3
20002850:	4313      	orrs	r3, r2
20002852:	b29a      	uxth	r2, r3
20002854:	687b      	ldr	r3, [r7, #4]
20002856:	831a      	strh	r2, [r3, #24]
}
20002858:	370c      	adds	r7, #12
2000285a:	46bd      	mov	sp, r7
2000285c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002860:	4770      	bx	lr
20002862:	bf00      	nop

20002864 <TIM_SetIC3Prescaler>:
  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{
20002864:	b480      	push	{r7}
20002866:	b083      	sub	sp, #12
20002868:	af00      	add	r7, sp, #0
2000286a:	6078      	str	r0, [r7, #4]
2000286c:	460b      	mov	r3, r1
2000286e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
20002870:	687b      	ldr	r3, [r7, #4]
20002872:	8b9b      	ldrh	r3, [r3, #28]
20002874:	b29b      	uxth	r3, r3
20002876:	f023 030c 	bic.w	r3, r3, #12
2000287a:	b29a      	uxth	r2, r3
2000287c:	687b      	ldr	r3, [r7, #4]
2000287e:	839a      	strh	r2, [r3, #28]
  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
20002880:	687b      	ldr	r3, [r7, #4]
20002882:	8b9b      	ldrh	r3, [r3, #28]
20002884:	b29a      	uxth	r2, r3
20002886:	887b      	ldrh	r3, [r7, #2]
20002888:	4313      	orrs	r3, r2
2000288a:	b29a      	uxth	r2, r3
2000288c:	687b      	ldr	r3, [r7, #4]
2000288e:	839a      	strh	r2, [r3, #28]
}
20002890:	370c      	adds	r7, #12
20002892:	46bd      	mov	sp, r7
20002894:	f85d 7b04 	ldr.w	r7, [sp], #4
20002898:	4770      	bx	lr
2000289a:	bf00      	nop

2000289c <TIM_SetIC4Prescaler>:
  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events
  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events
  * @retval None
  */
void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
{  
2000289c:	b480      	push	{r7}
2000289e:	b083      	sub	sp, #12
200028a0:	af00      	add	r7, sp, #0
200028a2:	6078      	str	r0, [r7, #4]
200028a4:	460b      	mov	r3, r1
200028a6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
200028a8:	687b      	ldr	r3, [r7, #4]
200028aa:	8b9b      	ldrh	r3, [r3, #28]
200028ac:	b29b      	uxth	r3, r3
200028ae:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
200028b2:	b29a      	uxth	r2, r3
200028b4:	687b      	ldr	r3, [r7, #4]
200028b6:	839a      	strh	r2, [r3, #28]
  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
200028b8:	687b      	ldr	r3, [r7, #4]
200028ba:	8b9b      	ldrh	r3, [r3, #28]
200028bc:	b29a      	uxth	r2, r3
200028be:	887b      	ldrh	r3, [r7, #2]
200028c0:	021b      	lsls	r3, r3, #8
200028c2:	b29b      	uxth	r3, r3
200028c4:	4313      	orrs	r3, r2
200028c6:	b29a      	uxth	r2, r3
200028c8:	687b      	ldr	r3, [r7, #4]
200028ca:	839a      	strh	r2, [r3, #28]
}
200028cc:	370c      	adds	r7, #12
200028ce:	46bd      	mov	sp, r7
200028d0:	f85d 7b04 	ldr.w	r7, [sp], #4
200028d4:	4770      	bx	lr
200028d6:	bf00      	nop

200028d8 <TIM_SetClockDivision>:
  *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
  *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
  * @retval None
  */
void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
{
200028d8:	b480      	push	{r7}
200028da:	b083      	sub	sp, #12
200028dc:	af00      	add	r7, sp, #0
200028de:	6078      	str	r0, [r7, #4]
200028e0:	460b      	mov	r3, r1
200028e2:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
200028e4:	687b      	ldr	r3, [r7, #4]
200028e6:	881b      	ldrh	r3, [r3, #0]
200028e8:	b29b      	uxth	r3, r3
200028ea:	f423 7340 	bic.w	r3, r3, #768	; 0x300
200028ee:	b29a      	uxth	r2, r3
200028f0:	687b      	ldr	r3, [r7, #4]
200028f2:	801a      	strh	r2, [r3, #0]
  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
200028f4:	687b      	ldr	r3, [r7, #4]
200028f6:	881b      	ldrh	r3, [r3, #0]
200028f8:	b29a      	uxth	r2, r3
200028fa:	887b      	ldrh	r3, [r7, #2]
200028fc:	4313      	orrs	r3, r2
200028fe:	b29a      	uxth	r2, r3
20002900:	687b      	ldr	r3, [r7, #4]
20002902:	801a      	strh	r2, [r3, #0]
}
20002904:	370c      	adds	r7, #12
20002906:	46bd      	mov	sp, r7
20002908:	f85d 7b04 	ldr.w	r7, [sp], #4
2000290c:	4770      	bx	lr
2000290e:	bf00      	nop

20002910 <TIM_GetCapture1>:
  * @brief  Gets the TIMx Input Capture 1 value.
  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.
  * @retval Capture Compare 1 Register value.
  */
uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
{
20002910:	b480      	push	{r7}
20002912:	b083      	sub	sp, #12
20002914:	af00      	add	r7, sp, #0
20002916:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
20002918:	687b      	ldr	r3, [r7, #4]
2000291a:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
2000291c:	b29b      	uxth	r3, r3
}
2000291e:	4618      	mov	r0, r3
20002920:	370c      	adds	r7, #12
20002922:	46bd      	mov	sp, r7
20002924:	f85d 7b04 	ldr.w	r7, [sp], #4
20002928:	4770      	bx	lr
2000292a:	bf00      	nop

2000292c <TIM_GetCapture2>:
  * @brief  Gets the TIMx Input Capture 2 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.
  * @retval Capture Compare 2 Register value.
  */
uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
{
2000292c:	b480      	push	{r7}
2000292e:	b083      	sub	sp, #12
20002930:	af00      	add	r7, sp, #0
20002932:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
20002934:	687b      	ldr	r3, [r7, #4]
20002936:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
20002938:	b29b      	uxth	r3, r3
}
2000293a:	4618      	mov	r0, r3
2000293c:	370c      	adds	r7, #12
2000293e:	46bd      	mov	sp, r7
20002940:	f85d 7b04 	ldr.w	r7, [sp], #4
20002944:	4770      	bx	lr
20002946:	bf00      	nop

20002948 <TIM_GetCapture3>:
  * @brief  Gets the TIMx Input Capture 3 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 3 Register value.
  */
uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
{
20002948:	b480      	push	{r7}
2000294a:	b083      	sub	sp, #12
2000294c:	af00      	add	r7, sp, #0
2000294e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
20002950:	687b      	ldr	r3, [r7, #4]
20002952:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
20002954:	b29b      	uxth	r3, r3
}
20002956:	4618      	mov	r0, r3
20002958:	370c      	adds	r7, #12
2000295a:	46bd      	mov	sp, r7
2000295c:	f85d 7b04 	ldr.w	r7, [sp], #4
20002960:	4770      	bx	lr
20002962:	bf00      	nop

20002964 <TIM_GetCapture4>:
  * @brief  Gets the TIMx Input Capture 4 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 4 Register value.
  */
uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
{
20002964:	b480      	push	{r7}
20002966:	b083      	sub	sp, #12
20002968:	af00      	add	r7, sp, #0
2000296a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
2000296c:	687b      	ldr	r3, [r7, #4]
2000296e:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
20002972:	b29b      	uxth	r3, r3
}
20002974:	4618      	mov	r0, r3
20002976:	370c      	adds	r7, #12
20002978:	46bd      	mov	sp, r7
2000297a:	f85d 7b04 	ldr.w	r7, [sp], #4
2000297e:	4770      	bx	lr

20002980 <TIM_GetCounter>:
  * @brief  Gets the TIMx Counter value.
  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
  * @retval Counter Register value.
  */
uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
{
20002980:	b480      	push	{r7}
20002982:	b083      	sub	sp, #12
20002984:	af00      	add	r7, sp, #0
20002986:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Get the Counter Register value */
  return TIMx->CNT;
20002988:	687b      	ldr	r3, [r7, #4]
2000298a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
2000298c:	b29b      	uxth	r3, r3
}
2000298e:	4618      	mov	r0, r3
20002990:	370c      	adds	r7, #12
20002992:	46bd      	mov	sp, r7
20002994:	f85d 7b04 	ldr.w	r7, [sp], #4
20002998:	4770      	bx	lr
2000299a:	bf00      	nop

2000299c <TIM_GetPrescaler>:
  * @brief  Gets the TIMx Prescaler value.
  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.
  * @retval Prescaler Register value.
  */
uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
{
2000299c:	b480      	push	{r7}
2000299e:	b083      	sub	sp, #12
200029a0:	af00      	add	r7, sp, #0
200029a2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  /* Get the Prescaler Register value */
  return TIMx->PSC;
200029a4:	687b      	ldr	r3, [r7, #4]
200029a6:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
200029a8:	b29b      	uxth	r3, r3
}
200029aa:	4618      	mov	r0, r3
200029ac:	370c      	adds	r7, #12
200029ae:	46bd      	mov	sp, r7
200029b0:	f85d 7b04 	ldr.w	r7, [sp], #4
200029b4:	4770      	bx	lr
200029b6:	bf00      	nop

200029b8 <TIM_GetFlagStatus>:
  *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
  *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
  * @retval The new state of TIM_FLAG (SET or RESET).
  */
FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{ 
200029b8:	b480      	push	{r7}
200029ba:	b085      	sub	sp, #20
200029bc:	af00      	add	r7, sp, #0
200029be:	6078      	str	r0, [r7, #4]
200029c0:	460b      	mov	r3, r1
200029c2:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
200029c4:	2300      	movs	r3, #0
200029c6:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
  
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
200029c8:	687b      	ldr	r3, [r7, #4]
200029ca:	8a1b      	ldrh	r3, [r3, #16]
200029cc:	b29a      	uxth	r2, r3
200029ce:	887b      	ldrh	r3, [r7, #2]
200029d0:	4013      	ands	r3, r2
200029d2:	b29b      	uxth	r3, r3
200029d4:	2b00      	cmp	r3, #0
200029d6:	d002      	beq.n	200029de <TIM_GetFlagStatus+0x26>
  {
    bitstatus = SET;
200029d8:	2301      	movs	r3, #1
200029da:	73fb      	strb	r3, [r7, #15]
200029dc:	e001      	b.n	200029e2 <TIM_GetFlagStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
200029de:	2300      	movs	r3, #0
200029e0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
200029e2:	7bfb      	ldrb	r3, [r7, #15]
}
200029e4:	4618      	mov	r0, r3
200029e6:	3714      	adds	r7, #20
200029e8:	46bd      	mov	sp, r7
200029ea:	f85d 7b04 	ldr.w	r7, [sp], #4
200029ee:	4770      	bx	lr

200029f0 <TIM_ClearFlag>:
  *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15. 
  *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.   
  * @retval None
  */
void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{  
200029f0:	b480      	push	{r7}
200029f2:	b083      	sub	sp, #12
200029f4:	af00      	add	r7, sp, #0
200029f6:	6078      	str	r0, [r7, #4]
200029f8:	460b      	mov	r3, r1
200029fa:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
200029fc:	887b      	ldrh	r3, [r7, #2]
200029fe:	43db      	mvns	r3, r3
20002a00:	b29a      	uxth	r2, r3
20002a02:	687b      	ldr	r3, [r7, #4]
20002a04:	821a      	strh	r2, [r3, #16]
}
20002a06:	370c      	adds	r7, #12
20002a08:	46bd      	mov	sp, r7
20002a0a:	f85d 7b04 	ldr.w	r7, [sp], #4
20002a0e:	4770      	bx	lr

20002a10 <TIM_GetITStatus>:
  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.  
  * @retval The new state of the TIM_IT(SET or RESET).
  */
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
20002a10:	b480      	push	{r7}
20002a12:	b085      	sub	sp, #20
20002a14:	af00      	add	r7, sp, #0
20002a16:	6078      	str	r0, [r7, #4]
20002a18:	460b      	mov	r3, r1
20002a1a:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
20002a1c:	2300      	movs	r3, #0
20002a1e:	73fb      	strb	r3, [r7, #15]
  uint16_t itstatus = 0x0, itenable = 0x0;
20002a20:	2300      	movs	r3, #0
20002a22:	81bb      	strh	r3, [r7, #12]
20002a24:	2300      	movs	r3, #0
20002a26:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
20002a28:	687b      	ldr	r3, [r7, #4]
20002a2a:	8a1b      	ldrh	r3, [r3, #16]
20002a2c:	b29a      	uxth	r2, r3
20002a2e:	887b      	ldrh	r3, [r7, #2]
20002a30:	4013      	ands	r3, r2
20002a32:	81bb      	strh	r3, [r7, #12]
  
  itenable = TIMx->DIER & TIM_IT;
20002a34:	687b      	ldr	r3, [r7, #4]
20002a36:	899b      	ldrh	r3, [r3, #12]
20002a38:	b29a      	uxth	r2, r3
20002a3a:	887b      	ldrh	r3, [r7, #2]
20002a3c:	4013      	ands	r3, r2
20002a3e:	817b      	strh	r3, [r7, #10]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
20002a40:	89bb      	ldrh	r3, [r7, #12]
20002a42:	2b00      	cmp	r3, #0
20002a44:	d005      	beq.n	20002a52 <TIM_GetITStatus+0x42>
20002a46:	897b      	ldrh	r3, [r7, #10]
20002a48:	2b00      	cmp	r3, #0
20002a4a:	d002      	beq.n	20002a52 <TIM_GetITStatus+0x42>
  {
    bitstatus = SET;
20002a4c:	2301      	movs	r3, #1
20002a4e:	73fb      	strb	r3, [r7, #15]
20002a50:	e001      	b.n	20002a56 <TIM_GetITStatus+0x46>
  }
  else
  {
    bitstatus = RESET;
20002a52:	2300      	movs	r3, #0
20002a54:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
20002a56:	7bfb      	ldrb	r3, [r7, #15]
}
20002a58:	4618      	mov	r0, r3
20002a5a:	3714      	adds	r7, #20
20002a5c:	46bd      	mov	sp, r7
20002a5e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002a62:	4770      	bx	lr

20002a64 <TIM_ClearITPendingBit>:
  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15. 
  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.    
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
20002a64:	b480      	push	{r7}
20002a66:	b083      	sub	sp, #12
20002a68:	af00      	add	r7, sp, #0
20002a6a:	6078      	str	r0, [r7, #4]
20002a6c:	460b      	mov	r3, r1
20002a6e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
20002a70:	887b      	ldrh	r3, [r7, #2]
20002a72:	43db      	mvns	r3, r3
20002a74:	b29a      	uxth	r2, r3
20002a76:	687b      	ldr	r3, [r7, #4]
20002a78:	821a      	strh	r2, [r3, #16]
}
20002a7a:	370c      	adds	r7, #12
20002a7c:	46bd      	mov	sp, r7
20002a7e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002a82:	4770      	bx	lr

20002a84 <TI1_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
20002a84:	b480      	push	{r7}
20002a86:	b087      	sub	sp, #28
20002a88:	af00      	add	r7, sp, #0
20002a8a:	60f8      	str	r0, [r7, #12]
20002a8c:	8179      	strh	r1, [r7, #10]
20002a8e:	813a      	strh	r2, [r7, #8]
20002a90:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0;
20002a92:	2300      	movs	r3, #0
20002a94:	82bb      	strh	r3, [r7, #20]
20002a96:	2300      	movs	r3, #0
20002a98:	82fb      	strh	r3, [r7, #22]
  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
20002a9a:	68fb      	ldr	r3, [r7, #12]
20002a9c:	8c1b      	ldrh	r3, [r3, #32]
20002a9e:	b29b      	uxth	r3, r3
20002aa0:	f023 0301 	bic.w	r3, r3, #1
20002aa4:	b29a      	uxth	r2, r3
20002aa6:	68fb      	ldr	r3, [r7, #12]
20002aa8:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
20002aaa:	68fb      	ldr	r3, [r7, #12]
20002aac:	8b1b      	ldrh	r3, [r3, #24]
20002aae:	82bb      	strh	r3, [r7, #20]
  tmpccer = TIMx->CCER;
20002ab0:	68fb      	ldr	r3, [r7, #12]
20002ab2:	8c1b      	ldrh	r3, [r3, #32]
20002ab4:	82fb      	strh	r3, [r7, #22]
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
20002ab6:	8abb      	ldrh	r3, [r7, #20]
20002ab8:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
20002abc:	82bb      	strh	r3, [r7, #20]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
20002abe:	88fb      	ldrh	r3, [r7, #6]
20002ac0:	011b      	lsls	r3, r3, #4
20002ac2:	b29a      	uxth	r2, r3
20002ac4:	893b      	ldrh	r3, [r7, #8]
20002ac6:	4313      	orrs	r3, r2
20002ac8:	b29a      	uxth	r2, r3
20002aca:	8abb      	ldrh	r3, [r7, #20]
20002acc:	4313      	orrs	r3, r2
20002ace:	82bb      	strh	r3, [r7, #20]
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
20002ad0:	68fa      	ldr	r2, [r7, #12]
20002ad2:	4b1c      	ldr	r3, [pc, #112]	; (20002b44 <TI1_Config+0xc0>)
20002ad4:	429a      	cmp	r2, r3
20002ad6:	d013      	beq.n	20002b00 <TI1_Config+0x7c>
20002ad8:	68fa      	ldr	r2, [r7, #12]
20002ada:	4b1b      	ldr	r3, [pc, #108]	; (20002b48 <TI1_Config+0xc4>)
20002adc:	429a      	cmp	r2, r3
20002ade:	d00f      	beq.n	20002b00 <TI1_Config+0x7c>
20002ae0:	68fb      	ldr	r3, [r7, #12]
20002ae2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20002ae6:	d00b      	beq.n	20002b00 <TI1_Config+0x7c>
20002ae8:	68fa      	ldr	r2, [r7, #12]
20002aea:	4b18      	ldr	r3, [pc, #96]	; (20002b4c <TI1_Config+0xc8>)
20002aec:	429a      	cmp	r2, r3
20002aee:	d007      	beq.n	20002b00 <TI1_Config+0x7c>
20002af0:	68fa      	ldr	r2, [r7, #12]
20002af2:	4b17      	ldr	r3, [pc, #92]	; (20002b50 <TI1_Config+0xcc>)
20002af4:	429a      	cmp	r2, r3
20002af6:	d003      	beq.n	20002b00 <TI1_Config+0x7c>
     (TIMx == TIM4) ||(TIMx == TIM5))
20002af8:	68fa      	ldr	r2, [r7, #12]
20002afa:	4b16      	ldr	r3, [pc, #88]	; (20002b54 <TI1_Config+0xd0>)
20002afc:	429a      	cmp	r2, r3
20002afe:	d10b      	bne.n	20002b18 <TI1_Config+0x94>
  {
    /* Select the Polarity and set the CC1E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
20002b00:	8afb      	ldrh	r3, [r7, #22]
20002b02:	f023 0302 	bic.w	r3, r3, #2
20002b06:	82fb      	strh	r3, [r7, #22]
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
20002b08:	897a      	ldrh	r2, [r7, #10]
20002b0a:	8afb      	ldrh	r3, [r7, #22]
20002b0c:	4313      	orrs	r3, r2
20002b0e:	b29b      	uxth	r3, r3
20002b10:	f043 0301 	orr.w	r3, r3, #1
20002b14:	82fb      	strh	r3, [r7, #22]
20002b16:	e00a      	b.n	20002b2e <TI1_Config+0xaa>
  }
  else
  {
    /* Select the Polarity and set the CC1E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
20002b18:	8afb      	ldrh	r3, [r7, #22]
20002b1a:	f023 030a 	bic.w	r3, r3, #10
20002b1e:	82fb      	strh	r3, [r7, #22]
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
20002b20:	897a      	ldrh	r2, [r7, #10]
20002b22:	8afb      	ldrh	r3, [r7, #22]
20002b24:	4313      	orrs	r3, r2
20002b26:	b29b      	uxth	r3, r3
20002b28:	f043 0301 	orr.w	r3, r3, #1
20002b2c:	82fb      	strh	r3, [r7, #22]
  }

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
20002b2e:	68fb      	ldr	r3, [r7, #12]
20002b30:	8aba      	ldrh	r2, [r7, #20]
20002b32:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
20002b34:	68fb      	ldr	r3, [r7, #12]
20002b36:	8afa      	ldrh	r2, [r7, #22]
20002b38:	841a      	strh	r2, [r3, #32]
}
20002b3a:	371c      	adds	r7, #28
20002b3c:	46bd      	mov	sp, r7
20002b3e:	f85d 7b04 	ldr.w	r7, [sp], #4
20002b42:	4770      	bx	lr
20002b44:	40012c00 	.word	0x40012c00
20002b48:	40013400 	.word	0x40013400
20002b4c:	40000400 	.word	0x40000400
20002b50:	40000800 	.word	0x40000800
20002b54:	40000c00 	.word	0x40000c00

20002b58 <TI2_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
20002b58:	b480      	push	{r7}
20002b5a:	b087      	sub	sp, #28
20002b5c:	af00      	add	r7, sp, #0
20002b5e:	60f8      	str	r0, [r7, #12]
20002b60:	8179      	strh	r1, [r7, #10]
20002b62:	813a      	strh	r2, [r7, #8]
20002b64:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
20002b66:	2300      	movs	r3, #0
20002b68:	82bb      	strh	r3, [r7, #20]
20002b6a:	2300      	movs	r3, #0
20002b6c:	82fb      	strh	r3, [r7, #22]
20002b6e:	2300      	movs	r3, #0
20002b70:	827b      	strh	r3, [r7, #18]
  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
20002b72:	68fb      	ldr	r3, [r7, #12]
20002b74:	8c1b      	ldrh	r3, [r3, #32]
20002b76:	b29b      	uxth	r3, r3
20002b78:	f023 0310 	bic.w	r3, r3, #16
20002b7c:	b29a      	uxth	r2, r3
20002b7e:	68fb      	ldr	r3, [r7, #12]
20002b80:	841a      	strh	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
20002b82:	68fb      	ldr	r3, [r7, #12]
20002b84:	8b1b      	ldrh	r3, [r3, #24]
20002b86:	82bb      	strh	r3, [r7, #20]
  tmpccer = TIMx->CCER;
20002b88:	68fb      	ldr	r3, [r7, #12]
20002b8a:	8c1b      	ldrh	r3, [r3, #32]
20002b8c:	82fb      	strh	r3, [r7, #22]
  tmp = (uint16_t)(TIM_ICPolarity << 4);
20002b8e:	897b      	ldrh	r3, [r7, #10]
20002b90:	011b      	lsls	r3, r3, #4
20002b92:	827b      	strh	r3, [r7, #18]
  /* Select the Input and set the filter */
  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
20002b94:	8abb      	ldrh	r3, [r7, #20]
20002b96:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20002b9a:	051b      	lsls	r3, r3, #20
20002b9c:	0d1b      	lsrs	r3, r3, #20
20002b9e:	82bb      	strh	r3, [r7, #20]
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
20002ba0:	88fb      	ldrh	r3, [r7, #6]
20002ba2:	031b      	lsls	r3, r3, #12
20002ba4:	b29a      	uxth	r2, r3
20002ba6:	8abb      	ldrh	r3, [r7, #20]
20002ba8:	4313      	orrs	r3, r2
20002baa:	82bb      	strh	r3, [r7, #20]
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
20002bac:	893b      	ldrh	r3, [r7, #8]
20002bae:	021b      	lsls	r3, r3, #8
20002bb0:	b29a      	uxth	r2, r3
20002bb2:	8abb      	ldrh	r3, [r7, #20]
20002bb4:	4313      	orrs	r3, r2
20002bb6:	82bb      	strh	r3, [r7, #20]
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
20002bb8:	68fa      	ldr	r2, [r7, #12]
20002bba:	4b1c      	ldr	r3, [pc, #112]	; (20002c2c <TI2_Config+0xd4>)
20002bbc:	429a      	cmp	r2, r3
20002bbe:	d013      	beq.n	20002be8 <TI2_Config+0x90>
20002bc0:	68fa      	ldr	r2, [r7, #12]
20002bc2:	4b1b      	ldr	r3, [pc, #108]	; (20002c30 <TI2_Config+0xd8>)
20002bc4:	429a      	cmp	r2, r3
20002bc6:	d00f      	beq.n	20002be8 <TI2_Config+0x90>
20002bc8:	68fb      	ldr	r3, [r7, #12]
20002bca:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20002bce:	d00b      	beq.n	20002be8 <TI2_Config+0x90>
20002bd0:	68fa      	ldr	r2, [r7, #12]
20002bd2:	4b18      	ldr	r3, [pc, #96]	; (20002c34 <TI2_Config+0xdc>)
20002bd4:	429a      	cmp	r2, r3
20002bd6:	d007      	beq.n	20002be8 <TI2_Config+0x90>
20002bd8:	68fa      	ldr	r2, [r7, #12]
20002bda:	4b17      	ldr	r3, [pc, #92]	; (20002c38 <TI2_Config+0xe0>)
20002bdc:	429a      	cmp	r2, r3
20002bde:	d003      	beq.n	20002be8 <TI2_Config+0x90>
     (TIMx == TIM4) ||(TIMx == TIM5))
20002be0:	68fa      	ldr	r2, [r7, #12]
20002be2:	4b16      	ldr	r3, [pc, #88]	; (20002c3c <TI2_Config+0xe4>)
20002be4:	429a      	cmp	r2, r3
20002be6:	d10b      	bne.n	20002c00 <TI2_Config+0xa8>
  {
    /* Select the Polarity and set the CC2E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
20002be8:	8afb      	ldrh	r3, [r7, #22]
20002bea:	f023 0320 	bic.w	r3, r3, #32
20002bee:	82fb      	strh	r3, [r7, #22]
    tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
20002bf0:	8a7a      	ldrh	r2, [r7, #18]
20002bf2:	8afb      	ldrh	r3, [r7, #22]
20002bf4:	4313      	orrs	r3, r2
20002bf6:	b29b      	uxth	r3, r3
20002bf8:	f043 0310 	orr.w	r3, r3, #16
20002bfc:	82fb      	strh	r3, [r7, #22]
20002bfe:	e00a      	b.n	20002c16 <TI2_Config+0xbe>
  }
  else
  {
    /* Select the Polarity and set the CC2E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
20002c00:	8afb      	ldrh	r3, [r7, #22]
20002c02:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
20002c06:	82fb      	strh	r3, [r7, #22]
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
20002c08:	897a      	ldrh	r2, [r7, #10]
20002c0a:	8afb      	ldrh	r3, [r7, #22]
20002c0c:	4313      	orrs	r3, r2
20002c0e:	b29b      	uxth	r3, r3
20002c10:	f043 0310 	orr.w	r3, r3, #16
20002c14:	82fb      	strh	r3, [r7, #22]
  }
  
  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
20002c16:	68fb      	ldr	r3, [r7, #12]
20002c18:	8aba      	ldrh	r2, [r7, #20]
20002c1a:	831a      	strh	r2, [r3, #24]
  TIMx->CCER = tmpccer;
20002c1c:	68fb      	ldr	r3, [r7, #12]
20002c1e:	8afa      	ldrh	r2, [r7, #22]
20002c20:	841a      	strh	r2, [r3, #32]
}
20002c22:	371c      	adds	r7, #28
20002c24:	46bd      	mov	sp, r7
20002c26:	f85d 7b04 	ldr.w	r7, [sp], #4
20002c2a:	4770      	bx	lr
20002c2c:	40012c00 	.word	0x40012c00
20002c30:	40013400 	.word	0x40013400
20002c34:	40000400 	.word	0x40000400
20002c38:	40000800 	.word	0x40000800
20002c3c:	40000c00 	.word	0x40000c00

20002c40 <TI3_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
20002c40:	b480      	push	{r7}
20002c42:	b087      	sub	sp, #28
20002c44:	af00      	add	r7, sp, #0
20002c46:	60f8      	str	r0, [r7, #12]
20002c48:	8179      	strh	r1, [r7, #10]
20002c4a:	813a      	strh	r2, [r7, #8]
20002c4c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
20002c4e:	2300      	movs	r3, #0
20002c50:	82bb      	strh	r3, [r7, #20]
20002c52:	2300      	movs	r3, #0
20002c54:	82fb      	strh	r3, [r7, #22]
20002c56:	2300      	movs	r3, #0
20002c58:	827b      	strh	r3, [r7, #18]
  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
20002c5a:	68fb      	ldr	r3, [r7, #12]
20002c5c:	8c1b      	ldrh	r3, [r3, #32]
20002c5e:	b29b      	uxth	r3, r3
20002c60:	f423 7380 	bic.w	r3, r3, #256	; 0x100
20002c64:	b29a      	uxth	r2, r3
20002c66:	68fb      	ldr	r3, [r7, #12]
20002c68:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
20002c6a:	68fb      	ldr	r3, [r7, #12]
20002c6c:	8b9b      	ldrh	r3, [r3, #28]
20002c6e:	82bb      	strh	r3, [r7, #20]
  tmpccer = TIMx->CCER;
20002c70:	68fb      	ldr	r3, [r7, #12]
20002c72:	8c1b      	ldrh	r3, [r3, #32]
20002c74:	82fb      	strh	r3, [r7, #22]
  tmp = (uint16_t)(TIM_ICPolarity << 8);
20002c76:	897b      	ldrh	r3, [r7, #10]
20002c78:	021b      	lsls	r3, r3, #8
20002c7a:	827b      	strh	r3, [r7, #18]
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
20002c7c:	8abb      	ldrh	r3, [r7, #20]
20002c7e:	f023 03f3 	bic.w	r3, r3, #243	; 0xf3
20002c82:	82bb      	strh	r3, [r7, #20]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
20002c84:	88fb      	ldrh	r3, [r7, #6]
20002c86:	011b      	lsls	r3, r3, #4
20002c88:	b29a      	uxth	r2, r3
20002c8a:	893b      	ldrh	r3, [r7, #8]
20002c8c:	4313      	orrs	r3, r2
20002c8e:	b29a      	uxth	r2, r3
20002c90:	8abb      	ldrh	r3, [r7, #20]
20002c92:	4313      	orrs	r3, r2
20002c94:	82bb      	strh	r3, [r7, #20]
    
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
20002c96:	68fa      	ldr	r2, [r7, #12]
20002c98:	4b1c      	ldr	r3, [pc, #112]	; (20002d0c <TI3_Config+0xcc>)
20002c9a:	429a      	cmp	r2, r3
20002c9c:	d013      	beq.n	20002cc6 <TI3_Config+0x86>
20002c9e:	68fa      	ldr	r2, [r7, #12]
20002ca0:	4b1b      	ldr	r3, [pc, #108]	; (20002d10 <TI3_Config+0xd0>)
20002ca2:	429a      	cmp	r2, r3
20002ca4:	d00f      	beq.n	20002cc6 <TI3_Config+0x86>
20002ca6:	68fb      	ldr	r3, [r7, #12]
20002ca8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20002cac:	d00b      	beq.n	20002cc6 <TI3_Config+0x86>
20002cae:	68fa      	ldr	r2, [r7, #12]
20002cb0:	4b18      	ldr	r3, [pc, #96]	; (20002d14 <TI3_Config+0xd4>)
20002cb2:	429a      	cmp	r2, r3
20002cb4:	d007      	beq.n	20002cc6 <TI3_Config+0x86>
20002cb6:	68fa      	ldr	r2, [r7, #12]
20002cb8:	4b17      	ldr	r3, [pc, #92]	; (20002d18 <TI3_Config+0xd8>)
20002cba:	429a      	cmp	r2, r3
20002cbc:	d003      	beq.n	20002cc6 <TI3_Config+0x86>
     (TIMx == TIM4) ||(TIMx == TIM5))
20002cbe:	68fa      	ldr	r2, [r7, #12]
20002cc0:	4b16      	ldr	r3, [pc, #88]	; (20002d1c <TI3_Config+0xdc>)
20002cc2:	429a      	cmp	r2, r3
20002cc4:	d10b      	bne.n	20002cde <TI3_Config+0x9e>
  {
    /* Select the Polarity and set the CC3E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));
20002cc6:	8afb      	ldrh	r3, [r7, #22]
20002cc8:	f423 7300 	bic.w	r3, r3, #512	; 0x200
20002ccc:	82fb      	strh	r3, [r7, #22]
    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
20002cce:	8a7a      	ldrh	r2, [r7, #18]
20002cd0:	8afb      	ldrh	r3, [r7, #22]
20002cd2:	4313      	orrs	r3, r2
20002cd4:	b29b      	uxth	r3, r3
20002cd6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20002cda:	82fb      	strh	r3, [r7, #22]
20002cdc:	e00a      	b.n	20002cf4 <TI3_Config+0xb4>
  }
  else
  {
    /* Select the Polarity and set the CC3E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
20002cde:	8afb      	ldrh	r3, [r7, #22]
20002ce0:	f423 6320 	bic.w	r3, r3, #2560	; 0xa00
20002ce4:	82fb      	strh	r3, [r7, #22]
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);
20002ce6:	897a      	ldrh	r2, [r7, #10]
20002ce8:	8afb      	ldrh	r3, [r7, #22]
20002cea:	4313      	orrs	r3, r2
20002cec:	b29b      	uxth	r3, r3
20002cee:	f443 7380 	orr.w	r3, r3, #256	; 0x100
20002cf2:	82fb      	strh	r3, [r7, #22]
  }
  
  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
20002cf4:	68fb      	ldr	r3, [r7, #12]
20002cf6:	8aba      	ldrh	r2, [r7, #20]
20002cf8:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer;
20002cfa:	68fb      	ldr	r3, [r7, #12]
20002cfc:	8afa      	ldrh	r2, [r7, #22]
20002cfe:	841a      	strh	r2, [r3, #32]
}
20002d00:	371c      	adds	r7, #28
20002d02:	46bd      	mov	sp, r7
20002d04:	f85d 7b04 	ldr.w	r7, [sp], #4
20002d08:	4770      	bx	lr
20002d0a:	bf00      	nop
20002d0c:	40012c00 	.word	0x40012c00
20002d10:	40013400 	.word	0x40013400
20002d14:	40000400 	.word	0x40000400
20002d18:	40000800 	.word	0x40000800
20002d1c:	40000c00 	.word	0x40000c00

20002d20 <TI4_Config>:
  *   This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
20002d20:	b480      	push	{r7}
20002d22:	b087      	sub	sp, #28
20002d24:	af00      	add	r7, sp, #0
20002d26:	60f8      	str	r0, [r7, #12]
20002d28:	8179      	strh	r1, [r7, #10]
20002d2a:	813a      	strh	r2, [r7, #8]
20002d2c:	80fb      	strh	r3, [r7, #6]
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
20002d2e:	2300      	movs	r3, #0
20002d30:	82bb      	strh	r3, [r7, #20]
20002d32:	2300      	movs	r3, #0
20002d34:	82fb      	strh	r3, [r7, #22]
20002d36:	2300      	movs	r3, #0
20002d38:	827b      	strh	r3, [r7, #18]

   /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
20002d3a:	68fb      	ldr	r3, [r7, #12]
20002d3c:	8c1b      	ldrh	r3, [r3, #32]
20002d3e:	b29b      	uxth	r3, r3
20002d40:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
20002d44:	b29a      	uxth	r2, r3
20002d46:	68fb      	ldr	r3, [r7, #12]
20002d48:	841a      	strh	r2, [r3, #32]
  tmpccmr2 = TIMx->CCMR2;
20002d4a:	68fb      	ldr	r3, [r7, #12]
20002d4c:	8b9b      	ldrh	r3, [r3, #28]
20002d4e:	82bb      	strh	r3, [r7, #20]
  tmpccer = TIMx->CCER;
20002d50:	68fb      	ldr	r3, [r7, #12]
20002d52:	8c1b      	ldrh	r3, [r3, #32]
20002d54:	82fb      	strh	r3, [r7, #22]
  tmp = (uint16_t)(TIM_ICPolarity << 12);
20002d56:	897b      	ldrh	r3, [r7, #10]
20002d58:	031b      	lsls	r3, r3, #12
20002d5a:	827b      	strh	r3, [r7, #18]
  /* Select the Input and set the filter */
  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
20002d5c:	8abb      	ldrh	r3, [r7, #20]
20002d5e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
20002d62:	051b      	lsls	r3, r3, #20
20002d64:	0d1b      	lsrs	r3, r3, #20
20002d66:	82bb      	strh	r3, [r7, #20]
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
20002d68:	893b      	ldrh	r3, [r7, #8]
20002d6a:	021b      	lsls	r3, r3, #8
20002d6c:	b29a      	uxth	r2, r3
20002d6e:	8abb      	ldrh	r3, [r7, #20]
20002d70:	4313      	orrs	r3, r2
20002d72:	82bb      	strh	r3, [r7, #20]
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
20002d74:	88fb      	ldrh	r3, [r7, #6]
20002d76:	031b      	lsls	r3, r3, #12
20002d78:	b29a      	uxth	r2, r3
20002d7a:	8abb      	ldrh	r3, [r7, #20]
20002d7c:	4313      	orrs	r3, r2
20002d7e:	82bb      	strh	r3, [r7, #20]
  
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
20002d80:	68fa      	ldr	r2, [r7, #12]
20002d82:	4b1d      	ldr	r3, [pc, #116]	; (20002df8 <TI4_Config+0xd8>)
20002d84:	429a      	cmp	r2, r3
20002d86:	d013      	beq.n	20002db0 <TI4_Config+0x90>
20002d88:	68fa      	ldr	r2, [r7, #12]
20002d8a:	4b1c      	ldr	r3, [pc, #112]	; (20002dfc <TI4_Config+0xdc>)
20002d8c:	429a      	cmp	r2, r3
20002d8e:	d00f      	beq.n	20002db0 <TI4_Config+0x90>
20002d90:	68fb      	ldr	r3, [r7, #12]
20002d92:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
20002d96:	d00b      	beq.n	20002db0 <TI4_Config+0x90>
20002d98:	68fa      	ldr	r2, [r7, #12]
20002d9a:	4b19      	ldr	r3, [pc, #100]	; (20002e00 <TI4_Config+0xe0>)
20002d9c:	429a      	cmp	r2, r3
20002d9e:	d007      	beq.n	20002db0 <TI4_Config+0x90>
20002da0:	68fa      	ldr	r2, [r7, #12]
20002da2:	4b18      	ldr	r3, [pc, #96]	; (20002e04 <TI4_Config+0xe4>)
20002da4:	429a      	cmp	r2, r3
20002da6:	d003      	beq.n	20002db0 <TI4_Config+0x90>
     (TIMx == TIM4) ||(TIMx == TIM5))
20002da8:	68fa      	ldr	r2, [r7, #12]
20002daa:	4b17      	ldr	r3, [pc, #92]	; (20002e08 <TI4_Config+0xe8>)
20002dac:	429a      	cmp	r2, r3
20002dae:	d10b      	bne.n	20002dc8 <TI4_Config+0xa8>
  {
    /* Select the Polarity and set the CC4E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
20002db0:	8afb      	ldrh	r3, [r7, #22]
20002db2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
20002db6:	82fb      	strh	r3, [r7, #22]
    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
20002db8:	8a7a      	ldrh	r2, [r7, #18]
20002dba:	8afb      	ldrh	r3, [r7, #22]
20002dbc:	4313      	orrs	r3, r2
20002dbe:	b29b      	uxth	r3, r3
20002dc0:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
20002dc4:	82fb      	strh	r3, [r7, #22]
20002dc6:	e00c      	b.n	20002de2 <TI4_Config+0xc2>
  }
  else
  {
    /* Select the Polarity and set the CC4E Bit */
    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));
20002dc8:	8afb      	ldrh	r3, [r7, #22]
20002dca:	f423 7300 	bic.w	r3, r3, #512	; 0x200
20002dce:	045b      	lsls	r3, r3, #17
20002dd0:	0c5b      	lsrs	r3, r3, #17
20002dd2:	82fb      	strh	r3, [r7, #22]
    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);
20002dd4:	897a      	ldrh	r2, [r7, #10]
20002dd6:	8afb      	ldrh	r3, [r7, #22]
20002dd8:	4313      	orrs	r3, r2
20002dda:	b29b      	uxth	r3, r3
20002ddc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
20002de0:	82fb      	strh	r3, [r7, #22]
  }
  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
20002de2:	68fb      	ldr	r3, [r7, #12]
20002de4:	8aba      	ldrh	r2, [r7, #20]
20002de6:	839a      	strh	r2, [r3, #28]
  TIMx->CCER = tmpccer;
20002de8:	68fb      	ldr	r3, [r7, #12]
20002dea:	8afa      	ldrh	r2, [r7, #22]
20002dec:	841a      	strh	r2, [r3, #32]
}
20002dee:	371c      	adds	r7, #28
20002df0:	46bd      	mov	sp, r7
20002df2:	f85d 7b04 	ldr.w	r7, [sp], #4
20002df6:	4770      	bx	lr
20002df8:	40012c00 	.word	0x40012c00
20002dfc:	40013400 	.word	0x40013400
20002e00:	40000400 	.word	0x40000400
20002e04:	40000800 	.word	0x40000800
20002e08:	40000c00 	.word	0x40000c00

20002e0c <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
20002e0c:	b580      	push	{r7, lr}
20002e0e:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
20002e10:	4b15      	ldr	r3, [pc, #84]	; (20002e68 <SystemInit+0x5c>)
20002e12:	4a15      	ldr	r2, [pc, #84]	; (20002e68 <SystemInit+0x5c>)
20002e14:	6812      	ldr	r2, [r2, #0]
20002e16:	f042 0201 	orr.w	r2, r2, #1
20002e1a:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
20002e1c:	4a12      	ldr	r2, [pc, #72]	; (20002e68 <SystemInit+0x5c>)
20002e1e:	4b12      	ldr	r3, [pc, #72]	; (20002e68 <SystemInit+0x5c>)
20002e20:	6859      	ldr	r1, [r3, #4]
20002e22:	4b12      	ldr	r3, [pc, #72]	; (20002e6c <SystemInit+0x60>)
20002e24:	400b      	ands	r3, r1
20002e26:	6053      	str	r3, [r2, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
20002e28:	4a0f      	ldr	r2, [pc, #60]	; (20002e68 <SystemInit+0x5c>)
20002e2a:	4b0f      	ldr	r3, [pc, #60]	; (20002e68 <SystemInit+0x5c>)
20002e2c:	681b      	ldr	r3, [r3, #0]
20002e2e:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
20002e32:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20002e36:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
20002e38:	4b0b      	ldr	r3, [pc, #44]	; (20002e68 <SystemInit+0x5c>)
20002e3a:	4a0b      	ldr	r2, [pc, #44]	; (20002e68 <SystemInit+0x5c>)
20002e3c:	6812      	ldr	r2, [r2, #0]
20002e3e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
20002e42:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
20002e44:	4b08      	ldr	r3, [pc, #32]	; (20002e68 <SystemInit+0x5c>)
20002e46:	4a08      	ldr	r2, [pc, #32]	; (20002e68 <SystemInit+0x5c>)
20002e48:	6852      	ldr	r2, [r2, #4]
20002e4a:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
20002e4e:	605a      	str	r2, [r3, #4]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
20002e50:	4b05      	ldr	r3, [pc, #20]	; (20002e68 <SystemInit+0x5c>)
20002e52:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
20002e56:	609a      	str	r2, [r3, #8]
  #endif /* DATA_IN_ExtSRAM */
#endif 

  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
  /* Configure the Flash Latency cycles and enable prefetch buffer */
  SetSysClock();
20002e58:	f000 f878 	bl	20002f4c <SetSysClock>

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
20002e5c:	4b04      	ldr	r3, [pc, #16]	; (20002e70 <SystemInit+0x64>)
20002e5e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
20002e62:	609a      	str	r2, [r3, #8]
#endif 
}
20002e64:	bd80      	pop	{r7, pc}
20002e66:	bf00      	nop
20002e68:	40021000 	.word	0x40021000
20002e6c:	f8ff0000 	.word	0xf8ff0000
20002e70:	e000ed00 	.word	0xe000ed00

20002e74 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
20002e74:	b480      	push	{r7}
20002e76:	b085      	sub	sp, #20
20002e78:	af00      	add	r7, sp, #0
  uint32_t tmp = 0, pllmull = 0, pllsource = 0;
20002e7a:	2300      	movs	r3, #0
20002e7c:	60fb      	str	r3, [r7, #12]
20002e7e:	2300      	movs	r3, #0
20002e80:	60bb      	str	r3, [r7, #8]
20002e82:	2300      	movs	r3, #0
20002e84:	607b      	str	r3, [r7, #4]
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
20002e86:	4b2c      	ldr	r3, [pc, #176]	; (20002f38 <SystemCoreClockUpdate+0xc4>)
20002e88:	685b      	ldr	r3, [r3, #4]
20002e8a:	f003 030c 	and.w	r3, r3, #12
20002e8e:	60fb      	str	r3, [r7, #12]
  
  switch (tmp)
20002e90:	68fb      	ldr	r3, [r7, #12]
20002e92:	2b04      	cmp	r3, #4
20002e94:	d007      	beq.n	20002ea6 <SystemCoreClockUpdate+0x32>
20002e96:	2b08      	cmp	r3, #8
20002e98:	d009      	beq.n	20002eae <SystemCoreClockUpdate+0x3a>
20002e9a:	2b00      	cmp	r3, #0
20002e9c:	d134      	bne.n	20002f08 <SystemCoreClockUpdate+0x94>
  {
    case 0x00:  /* HSI used as system clock */
      SystemCoreClock = HSI_VALUE;
20002e9e:	4b27      	ldr	r3, [pc, #156]	; (20002f3c <SystemCoreClockUpdate+0xc8>)
20002ea0:	4a27      	ldr	r2, [pc, #156]	; (20002f40 <SystemCoreClockUpdate+0xcc>)
20002ea2:	601a      	str	r2, [r3, #0]
      break;
20002ea4:	e034      	b.n	20002f10 <SystemCoreClockUpdate+0x9c>
    case 0x04:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
20002ea6:	4b25      	ldr	r3, [pc, #148]	; (20002f3c <SystemCoreClockUpdate+0xc8>)
20002ea8:	4a25      	ldr	r2, [pc, #148]	; (20002f40 <SystemCoreClockUpdate+0xcc>)
20002eaa:	601a      	str	r2, [r3, #0]
      break;
20002eac:	e030      	b.n	20002f10 <SystemCoreClockUpdate+0x9c>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
20002eae:	4b22      	ldr	r3, [pc, #136]	; (20002f38 <SystemCoreClockUpdate+0xc4>)
20002eb0:	685b      	ldr	r3, [r3, #4]
20002eb2:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
20002eb6:	60bb      	str	r3, [r7, #8]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
20002eb8:	4b1f      	ldr	r3, [pc, #124]	; (20002f38 <SystemCoreClockUpdate+0xc4>)
20002eba:	685b      	ldr	r3, [r3, #4]
20002ebc:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
20002ec0:	607b      	str	r3, [r7, #4]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
20002ec2:	68bb      	ldr	r3, [r7, #8]
20002ec4:	0c9b      	lsrs	r3, r3, #18
20002ec6:	3302      	adds	r3, #2
20002ec8:	60bb      	str	r3, [r7, #8]
      
      if (pllsource == 0x00)
20002eca:	687b      	ldr	r3, [r7, #4]
20002ecc:	2b00      	cmp	r3, #0
20002ece:	d106      	bne.n	20002ede <SystemCoreClockUpdate+0x6a>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
20002ed0:	68bb      	ldr	r3, [r7, #8]
20002ed2:	4a1c      	ldr	r2, [pc, #112]	; (20002f44 <SystemCoreClockUpdate+0xd0>)
20002ed4:	fb02 f203 	mul.w	r2, r2, r3
20002ed8:	4b18      	ldr	r3, [pc, #96]	; (20002f3c <SystemCoreClockUpdate+0xc8>)
20002eda:	601a      	str	r2, [r3, #0]
20002edc:	e013      	b.n	20002f06 <SystemCoreClockUpdate+0x92>
       prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
       /* HSE oscillator clock selected as PREDIV1 clock entry */
       SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 #else
        /* HSE selected as PLL clock entry */
        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
20002ede:	4b16      	ldr	r3, [pc, #88]	; (20002f38 <SystemCoreClockUpdate+0xc4>)
20002ee0:	685b      	ldr	r3, [r3, #4]
20002ee2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20002ee6:	2b00      	cmp	r3, #0
20002ee8:	d006      	beq.n	20002ef8 <SystemCoreClockUpdate+0x84>
        {/* HSE oscillator clock divided by 2 */
          SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
20002eea:	68bb      	ldr	r3, [r7, #8]
20002eec:	4a15      	ldr	r2, [pc, #84]	; (20002f44 <SystemCoreClockUpdate+0xd0>)
20002eee:	fb02 f203 	mul.w	r2, r2, r3
20002ef2:	4b12      	ldr	r3, [pc, #72]	; (20002f3c <SystemCoreClockUpdate+0xc8>)
20002ef4:	601a      	str	r2, [r3, #0]
20002ef6:	e006      	b.n	20002f06 <SystemCoreClockUpdate+0x92>
        }
        else
        {
          SystemCoreClock = HSE_VALUE * pllmull;
20002ef8:	68bb      	ldr	r3, [r7, #8]
20002efa:	4a11      	ldr	r2, [pc, #68]	; (20002f40 <SystemCoreClockUpdate+0xcc>)
20002efc:	fb02 f203 	mul.w	r2, r2, r3
20002f00:	4b0e      	ldr	r3, [pc, #56]	; (20002f3c <SystemCoreClockUpdate+0xc8>)
20002f02:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
20002f04:	e004      	b.n	20002f10 <SystemCoreClockUpdate+0x9c>
20002f06:	e003      	b.n	20002f10 <SystemCoreClockUpdate+0x9c>

    default:
      SystemCoreClock = HSI_VALUE;
20002f08:	4b0c      	ldr	r3, [pc, #48]	; (20002f3c <SystemCoreClockUpdate+0xc8>)
20002f0a:	4a0d      	ldr	r2, [pc, #52]	; (20002f40 <SystemCoreClockUpdate+0xcc>)
20002f0c:	601a      	str	r2, [r3, #0]
      break;
20002f0e:	bf00      	nop
  }
  
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
20002f10:	4b09      	ldr	r3, [pc, #36]	; (20002f38 <SystemCoreClockUpdate+0xc4>)
20002f12:	685b      	ldr	r3, [r3, #4]
20002f14:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
20002f18:	091b      	lsrs	r3, r3, #4
20002f1a:	4a0b      	ldr	r2, [pc, #44]	; (20002f48 <SystemCoreClockUpdate+0xd4>)
20002f1c:	5cd3      	ldrb	r3, [r2, r3]
20002f1e:	b2db      	uxtb	r3, r3
20002f20:	60fb      	str	r3, [r7, #12]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
20002f22:	4b06      	ldr	r3, [pc, #24]	; (20002f3c <SystemCoreClockUpdate+0xc8>)
20002f24:	681a      	ldr	r2, [r3, #0]
20002f26:	68fb      	ldr	r3, [r7, #12]
20002f28:	40da      	lsrs	r2, r3
20002f2a:	4b04      	ldr	r3, [pc, #16]	; (20002f3c <SystemCoreClockUpdate+0xc8>)
20002f2c:	601a      	str	r2, [r3, #0]
}
20002f2e:	3714      	adds	r7, #20
20002f30:	46bd      	mov	sp, r7
20002f32:	f85d 7b04 	ldr.w	r7, [sp], #4
20002f36:	4770      	bx	lr
20002f38:	40021000 	.word	0x40021000
20002f3c:	20005014 	.word	0x20005014
20002f40:	007a1200 	.word	0x007a1200
20002f44:	003d0900 	.word	0x003d0900
20002f48:	20005018 	.word	0x20005018

20002f4c <SetSysClock>:
  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
20002f4c:	b580      	push	{r7, lr}
20002f4e:	af00      	add	r7, sp, #0
#elif defined SYSCLK_FREQ_48MHz
  SetSysClockTo48();
#elif defined SYSCLK_FREQ_56MHz
  SetSysClockTo56();  
#elif defined SYSCLK_FREQ_72MHz
  SetSysClockTo72();
20002f50:	f000 f802 	bl	20002f58 <SetSysClockTo72>
#endif
 
 /* If none of the define above is enabled, the HSI is used as System clock
    source (default after reset) */ 
}
20002f54:	bd80      	pop	{r7, pc}
20002f56:	bf00      	nop

20002f58 <SetSysClockTo72>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
20002f58:	b480      	push	{r7}
20002f5a:	b083      	sub	sp, #12
20002f5c:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
20002f5e:	2300      	movs	r3, #0
20002f60:	607b      	str	r3, [r7, #4]
20002f62:	2300      	movs	r3, #0
20002f64:	603b      	str	r3, [r7, #0]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
20002f66:	4b3a      	ldr	r3, [pc, #232]	; (20003050 <SetSysClockTo72+0xf8>)
20002f68:	4a39      	ldr	r2, [pc, #228]	; (20003050 <SetSysClockTo72+0xf8>)
20002f6a:	6812      	ldr	r2, [r2, #0]
20002f6c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
20002f70:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
20002f72:	4b37      	ldr	r3, [pc, #220]	; (20003050 <SetSysClockTo72+0xf8>)
20002f74:	681b      	ldr	r3, [r3, #0]
20002f76:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20002f7a:	603b      	str	r3, [r7, #0]
    StartUpCounter++;  
20002f7c:	687b      	ldr	r3, [r7, #4]
20002f7e:	3301      	adds	r3, #1
20002f80:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
20002f82:	683b      	ldr	r3, [r7, #0]
20002f84:	2b00      	cmp	r3, #0
20002f86:	d103      	bne.n	20002f90 <SetSysClockTo72+0x38>
20002f88:	687b      	ldr	r3, [r7, #4]
20002f8a:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
20002f8e:	d1f0      	bne.n	20002f72 <SetSysClockTo72+0x1a>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
20002f90:	4b2f      	ldr	r3, [pc, #188]	; (20003050 <SetSysClockTo72+0xf8>)
20002f92:	681b      	ldr	r3, [r3, #0]
20002f94:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
20002f98:	2b00      	cmp	r3, #0
20002f9a:	d002      	beq.n	20002fa2 <SetSysClockTo72+0x4a>
  {
    HSEStatus = (uint32_t)0x01;
20002f9c:	2301      	movs	r3, #1
20002f9e:	603b      	str	r3, [r7, #0]
20002fa0:	e001      	b.n	20002fa6 <SetSysClockTo72+0x4e>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
20002fa2:	2300      	movs	r3, #0
20002fa4:	603b      	str	r3, [r7, #0]
  }  

  if (HSEStatus == (uint32_t)0x01)
20002fa6:	683b      	ldr	r3, [r7, #0]
20002fa8:	2b01      	cmp	r3, #1
20002faa:	d14b      	bne.n	20003044 <SetSysClockTo72+0xec>
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
20002fac:	4b29      	ldr	r3, [pc, #164]	; (20003054 <SetSysClockTo72+0xfc>)
20002fae:	4a29      	ldr	r2, [pc, #164]	; (20003054 <SetSysClockTo72+0xfc>)
20002fb0:	6812      	ldr	r2, [r2, #0]
20002fb2:	f042 0210 	orr.w	r2, r2, #16
20002fb6:	601a      	str	r2, [r3, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
20002fb8:	4b26      	ldr	r3, [pc, #152]	; (20003054 <SetSysClockTo72+0xfc>)
20002fba:	4a26      	ldr	r2, [pc, #152]	; (20003054 <SetSysClockTo72+0xfc>)
20002fbc:	6812      	ldr	r2, [r2, #0]
20002fbe:	f022 0203 	bic.w	r2, r2, #3
20002fc2:	601a      	str	r2, [r3, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
20002fc4:	4b23      	ldr	r3, [pc, #140]	; (20003054 <SetSysClockTo72+0xfc>)
20002fc6:	4a23      	ldr	r2, [pc, #140]	; (20003054 <SetSysClockTo72+0xfc>)
20002fc8:	6812      	ldr	r2, [r2, #0]
20002fca:	f042 0202 	orr.w	r2, r2, #2
20002fce:	601a      	str	r2, [r3, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
20002fd0:	4b1f      	ldr	r3, [pc, #124]	; (20003050 <SetSysClockTo72+0xf8>)
20002fd2:	4a1f      	ldr	r2, [pc, #124]	; (20003050 <SetSysClockTo72+0xf8>)
20002fd4:	6852      	ldr	r2, [r2, #4]
20002fd6:	605a      	str	r2, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
20002fd8:	4b1d      	ldr	r3, [pc, #116]	; (20003050 <SetSysClockTo72+0xf8>)
20002fda:	4a1d      	ldr	r2, [pc, #116]	; (20003050 <SetSysClockTo72+0xf8>)
20002fdc:	6852      	ldr	r2, [r2, #4]
20002fde:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
20002fe0:	4b1b      	ldr	r3, [pc, #108]	; (20003050 <SetSysClockTo72+0xf8>)
20002fe2:	4a1b      	ldr	r2, [pc, #108]	; (20003050 <SetSysClockTo72+0xf8>)
20002fe4:	6852      	ldr	r2, [r2, #4]
20002fe6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
20002fea:	605a      	str	r2, [r3, #4]
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
                            RCC_CFGR_PLLMULL9); 
#else    
    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
20002fec:	4b18      	ldr	r3, [pc, #96]	; (20003050 <SetSysClockTo72+0xf8>)
20002fee:	4a18      	ldr	r2, [pc, #96]	; (20003050 <SetSysClockTo72+0xf8>)
20002ff0:	6852      	ldr	r2, [r2, #4]
20002ff2:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
20002ff6:	605a      	str	r2, [r3, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
20002ff8:	4b15      	ldr	r3, [pc, #84]	; (20003050 <SetSysClockTo72+0xf8>)
20002ffa:	4a15      	ldr	r2, [pc, #84]	; (20003050 <SetSysClockTo72+0xf8>)
20002ffc:	6852      	ldr	r2, [r2, #4]
20002ffe:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
20003002:	605a      	str	r2, [r3, #4]
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
20003004:	4b12      	ldr	r3, [pc, #72]	; (20003050 <SetSysClockTo72+0xf8>)
20003006:	4a12      	ldr	r2, [pc, #72]	; (20003050 <SetSysClockTo72+0xf8>)
20003008:	6812      	ldr	r2, [r2, #0]
2000300a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
2000300e:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
20003010:	bf00      	nop
20003012:	4b0f      	ldr	r3, [pc, #60]	; (20003050 <SetSysClockTo72+0xf8>)
20003014:	681b      	ldr	r3, [r3, #0]
20003016:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
2000301a:	2b00      	cmp	r3, #0
2000301c:	d0f9      	beq.n	20003012 <SetSysClockTo72+0xba>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
2000301e:	4b0c      	ldr	r3, [pc, #48]	; (20003050 <SetSysClockTo72+0xf8>)
20003020:	4a0b      	ldr	r2, [pc, #44]	; (20003050 <SetSysClockTo72+0xf8>)
20003022:	6852      	ldr	r2, [r2, #4]
20003024:	f022 0203 	bic.w	r2, r2, #3
20003028:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
2000302a:	4b09      	ldr	r3, [pc, #36]	; (20003050 <SetSysClockTo72+0xf8>)
2000302c:	4a08      	ldr	r2, [pc, #32]	; (20003050 <SetSysClockTo72+0xf8>)
2000302e:	6852      	ldr	r2, [r2, #4]
20003030:	f042 0202 	orr.w	r2, r2, #2
20003034:	605a      	str	r2, [r3, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
20003036:	bf00      	nop
20003038:	4b05      	ldr	r3, [pc, #20]	; (20003050 <SetSysClockTo72+0xf8>)
2000303a:	685b      	ldr	r3, [r3, #4]
2000303c:	f003 030c 	and.w	r3, r3, #12
20003040:	2b08      	cmp	r3, #8
20003042:	d1f9      	bne.n	20003038 <SetSysClockTo72+0xe0>
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }
}
20003044:	370c      	adds	r7, #12
20003046:	46bd      	mov	sp, r7
20003048:	f85d 7b04 	ldr.w	r7, [sp], #4
2000304c:	4770      	bx	lr
2000304e:	bf00      	nop
20003050:	40021000 	.word	0x40021000
20003054:	40022000 	.word	0x40022000

20003058 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
20003058:	2100      	movs	r1, #0
  b  LoopCopyDataInit
2000305a:	e003      	b.n	20003064 <LoopCopyDataInit>

2000305c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
2000305c:	4b0a      	ldr	r3, [pc, #40]	; (20003088 <LoopFillZerobss+0x10>)
  ldr  r3, [r3, r1]
2000305e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
20003060:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
20003062:	3104      	adds	r1, #4

20003064 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
20003064:	4809      	ldr	r0, [pc, #36]	; (2000308c <LoopFillZerobss+0x14>)
  ldr  r3, =_edata
20003066:	4b0a      	ldr	r3, [pc, #40]	; (20003090 <LoopFillZerobss+0x18>)
  adds  r2, r0, r1
20003068:	1842      	adds	r2, r0, r1
  cmp  r2, r3
2000306a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
2000306c:	d3f6      	bcc.n	2000305c <CopyDataInit>
  ldr  r2, =_sbss
2000306e:	4a09      	ldr	r2, [pc, #36]	; (20003094 <LoopFillZerobss+0x1c>)
  b  LoopFillZerobss
20003070:	e002      	b.n	20003078 <LoopFillZerobss>

20003072 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
20003072:	2300      	movs	r3, #0
  str  r3, [r2], #4
20003074:	f842 3b04 	str.w	r3, [r2], #4

20003078 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
20003078:	4b07      	ldr	r3, [pc, #28]	; (20003098 <LoopFillZerobss+0x20>)
  cmp  r2, r3
2000307a:	429a      	cmp	r2, r3
  bcc  FillZerobss
2000307c:	d3f9      	bcc.n	20003072 <FillZerobss>
/* Call the clock system intitialization function.*/
  bl  SystemInit   
2000307e:	f7ff fec5 	bl	20002e0c <SystemInit>
/* Call the application's entry point.*/
  bl  main
20003082:	f7fd f8ed 	bl	20000260 <main>
  bx  lr    
20003086:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
20003088:	200030a0 	.word	0x200030a0
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
2000308c:	20005000 	.word	0x20005000
  ldr  r3, =_edata
20003090:	20005028 	.word	0x20005028
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
20003094:	20005028 	.word	0x20005028
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
20003098:	20005028 	.word	0x20005028

2000309c <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
2000309c:	e7fe      	b.n	2000309c <ADC1_2_IRQHandler>
	...
